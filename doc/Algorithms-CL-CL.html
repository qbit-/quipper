<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Algorithms.CL.CL</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Algorithms-CL-CL.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/Algorithms/CL/CL.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">The Quipper System</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>None</td></tr></table><p class="caption">Algorithms.CL.CL</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Stage 1 (quantum): Approximate regulator to low precision</a></li><li><a href="#g:2">Stage 2 (classical): Compute the regulator more accurately. </a></li><li><a href="#g:3">Stage 3 (classical): Find generators of the class group.</a></li><li><a href="#g:4">Stage 4 (quantum): Find relations between generators.</a></li><li><a href="#g:5">Section 5 (classical): compute class number.</a></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>An implementation of the quantum algorithms, based on the works of Hallgren, to compute the class number of a real quadratic number field.</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><a href="#v:approximate_regulator_circuit">approximate_regulator_circuit</a> :: <a href="Algorithms-CL-Types.html#t:CLIntP">CLIntP</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a> -&gt; <a href="Algorithms-CL-Types.html#t:CLIntP">CLIntP</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> <a href="QuipperLib-Arith.html#t:CInt">CInt</a></li><li class="src short"><a href="#v:try_approximate_regulator">try_approximate_regulator</a> :: <a href="Algorithms-CL-Types.html#t:CLIntP">CLIntP</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/System-IO.html#t:IO">IO</a> (<a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Maybe.html#t:Maybe">Maybe</a> <a href="Algorithms-CL-Types.html#t:CLReal">CLReal</a>)</li><li class="src short"><a href="#v:verify_period_multiple">verify_period_multiple</a> :: <a href="Algorithms-CL-Types.html#t:CLIntP">CLIntP</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a> -&gt; <a href="Algorithms-CL-Types.html#t:CLInt">CLInt</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Bool.html#t:Bool">Bool</a></li><li class="src short"><a href="#v:approximate_regulator">approximate_regulator</a> :: <a href="Algorithms-CL-Types.html#t:CLIntP">CLIntP</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/System-IO.html#t:IO">IO</a> <a href="Algorithms-CL-Types.html#t:CLReal">CLReal</a></li><li class="src short"><a href="#v:improve_regulator_accuracy">improve_regulator_accuracy</a> :: <a href="Algorithms-CL-Types.html#t:CLReal">CLReal</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Prelude.html#t:Integer">Integer</a> -&gt; <a href="Algorithms-CL-Types.html#t:CLReal">CLReal</a></li><li class="src short"><a href="#v:compute_generators">compute_generators</a> :: <a href="Algorithms-CL-Types.html#t:CLIntP">CLIntP</a> -&gt; &#91;<a href="Algorithms-CL-Types.html#t:IdealRed">IdealRed</a>&#93;</li><li class="src short"><a href="#v:hI">hI</a> :: <a href="Algorithms-CL-Types.html#t:IdDist">IdDist</a> -&gt; <a href="Algorithms-CL-Types.html#t:CLInt">CLInt</a> -&gt; <a href="Algorithms-CL-Types.html#t:CLInt">CLInt</a> -&gt; <a href="Algorithms-CL-Types.html#t:CLInt">CLInt</a> -&gt; <a href="Algorithms-CL-Types.html#t:CLIntP">CLIntP</a> -&gt; <a href="Algorithms-CL-Types.html#t:CLIntP">CLIntP</a> -&gt; (<a href="Algorithms-CL-Types.html#t:IdDist">IdDist</a>, <a href="Algorithms-CL-Types.html#t:CLInt">CLInt</a>)</li><li class="src short"><a href="#v:compute_ghat">compute_ghat</a> :: <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Prelude.html#t:Integral">Integral</a> int =&gt; &#91;<a href="Algorithms-CL-Types.html#t:IdDist">IdDist</a>&#93; -&gt; &#91;int&#93; -&gt; <a href="Algorithms-CL-Types.html#t:IdDist">IdDist</a></li><li class="src short"><a href="#v:compute_i_N_at">compute_i_N_at</a> :: <a href="QuipperLib-Arith.html#t:QDInt">QDInt</a> -&gt; <a href="QuipperLib-Arith.html#t:QDInt">QDInt</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> ()</li><li class="src short"><a href="#v:register_sizes">register_sizes</a> :: <a href="Algorithms-CL-Types.html#t:CLIntP">CLIntP</a> -&gt; <a href="Algorithms-CL-Types.html#t:CLReal">CLReal</a> -&gt; (<a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a>, <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a>, <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a>, <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a>, <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a>, <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a>, <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a>)</li><li class="src short"><a href="#v:structure_circuit">structure_circuit</a> :: <a href="Algorithms-CL-Types.html#t:CLIntP">CLIntP</a> -&gt; <a href="Algorithms-CL-Types.html#t:CLReal">CLReal</a> -&gt; &#91;<a href="Algorithms-CL-Types.html#t:IdealRed">IdealRed</a>&#93; -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> &#91;<a href="QuipperLib-Arith.html#t:CInt">CInt</a>&#93;</li><li class="src short"><a href="#v:compute_relations">compute_relations</a> :: <a href="Algorithms-CL-Types.html#t:CLIntP">CLIntP</a> -&gt; <a href="Algorithms-CL-Types.html#t:CLReal">CLReal</a> -&gt; &#91;<a href="Algorithms-CL-Types.html#t:IdealRed">IdealRed</a>&#93; -&gt; <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/System-IO.html#t:IO">IO</a> &#91;<a href="Algorithms-CL-Types.html#t:CLInt">CLInt</a>&#93;</li><li class="src short"><a href="#v:class_number">class_number</a> :: <a href="Algorithms-CL-Types.html#t:CLIntP">CLIntP</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/System-IO.html#t:IO">IO</a> <a href="Algorithms-CL-Types.html#t:CLInt">CLInt</a></li></ul></div><div id="interface"><h1 id="g:1">Stage 1 (quantum): Approximate regulator to low precision</h1><div class="top"><p class="src"><a id="v:approximate_regulator_circuit" class="def">approximate_regulator_circuit</a> :: <a href="Algorithms-CL-Types.html#t:CLIntP">CLIntP</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a> -&gt; <a href="Algorithms-CL-Types.html#t:CLIntP">CLIntP</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> <a href="QuipperLib-Arith.html#t:CInt">CInt</a> <a href="src/Algorithms/CL/CL.html#line-38" class="link">Source</a> <a href="#v:approximate_regulator_circuit" class="selflink">#</a></p><div class="doc"><p>Quantum part of the procedure to approximate the regulator <em>R</em>.</p><p>Follows the procedure described in &#91;Jozsa 2003&#93;, Sec. 10. An adapted
 version of the Hidden Subgroup Problem (HSP) Algorithm is used to
 estimate the (irrational) period of the function <em>f</em> <sub><em>N</em></sub>
 (<code><a href="Algorithms-CL-RegulatorClassical.html#v:fN">fN</a></code>, <code><a href="Algorithms-CL-RegulatorQuantum.html#v:q_fN">q_fN</a></code>); this is the function <em>h</em> of &#91;Jozsa 2003&#93;, Sec. 9,
 discretized with precision <em>N</em> = 2 <sup>&#8722;<em>n</em></sup>, and so has weak
 period <em>S</em> = <em>NR</em>.  The precision <em>n</em> is determined by <code><a href="Algorithms-CL-Types.html#v:n_of_bigD">n_of_bigD</a></code>.</p><p>Inputs: &#916;; <em>i</em>, an assumed bound such that <em>S</em> &#8804; 2<sup><em>i</em></sup>; 
 and a random &#8220;jitter&#8221; parameter.</p></div></div><div class="top"><p class="src"><a id="v:try_approximate_regulator" class="def">try_approximate_regulator</a> :: <a href="Algorithms-CL-Types.html#t:CLIntP">CLIntP</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/System-IO.html#t:IO">IO</a> (<a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Maybe.html#t:Maybe">Maybe</a> <a href="Algorithms-CL-Types.html#t:CLReal">CLReal</a>) <a href="src/Algorithms/CL/CL.html#line-83" class="link">Source</a> <a href="#v:try_approximate_regulator" class="selflink">#</a></p><div class="doc"><p>Attempt to approximate the regulator <em>R</em>, given an assumed 
 bound <em>i</em> such that <em>S</em> &#8804; 2<sup><em>i</em></sup>, using the probabilistic 
 quantum computation <code>approximate_regulator_circuit</code> twice as
 described in &#91;Jozsa 2003&#93;, Sec. 10.</p><p>Check the result for success; if it fails, return <code><a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Maybe.html#v:Nothing">Nothing</a></code>.</p><p>(The <code><a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/System-IO.html#t:IO">IO</a></code> monad is slight overkill here: it is just to make a
 source of randomness available. A tighter approach could use e.g. a
 monad transformer such as <code>RandT</code>, applied to the <code><a href="Quipper-Monad.html#t:Circ">Circ</a></code> monad.)</p></div></div><div class="top"><p class="src"><a id="v:verify_period_multiple" class="def">verify_period_multiple</a> :: <a href="Algorithms-CL-Types.html#t:CLIntP">CLIntP</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a> -&gt; <a href="Algorithms-CL-Types.html#t:CLInt">CLInt</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Bool.html#t:Bool">Bool</a> <a href="src/Algorithms/CL/CL.html#line-109" class="link">Source</a> <a href="#v:verify_period_multiple" class="selflink">#</a></p><div class="doc"><p><code><code><a href="Algorithms-CL-CL.html#v:verify_period_multiple">verify_period_multiple</a></code> &#916; <em>n</em> <em>m</em></code>: 
 check whether <em>m</em> is within 1 of a multiple of the period <em>S</em> of <em>f</em><sub><em>N</em></sub>.</p><p>Since for any ideal <em>I</em>, &#961;(&#961;(<em>I</em>)) is distance &gt; ln 2 from <em>I</em>, it suffices 
 to check whether the unit ideal is within 4 steps either way of <em>f</em><a href="m">sub /N/</a>.</p></div></div><div class="top"><p class="src"><a id="v:approximate_regulator" class="def">approximate_regulator</a> :: <a href="Algorithms-CL-Types.html#t:CLIntP">CLIntP</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/System-IO.html#t:IO">IO</a> <a href="Algorithms-CL-Types.html#t:CLReal">CLReal</a> <a href="src/Algorithms/CL/CL.html#line-119" class="link">Source</a> <a href="#v:approximate_regulator" class="selflink">#</a></p><div class="doc"><p>Approximate the regulator for a given &#916; (<em>bigD</em>).</p><p>Repeatedly run <code><code><a href="Algorithms-CL-CL.html#v:try_approximate_regulator">try_approximate_regulator</a></code></code> enough times, with increasing
 <em>i</em>, that it eventually succeeds with high probability. </p></div></div><h1 id="g:2">Stage 2 (classical): Compute the regulator more accurately. </h1><div class="top"><p class="src"><a id="v:improve_regulator_accuracy" class="def">improve_regulator_accuracy</a> :: <a href="Algorithms-CL-Types.html#t:CLReal">CLReal</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Prelude.html#t:Integer">Integer</a> -&gt; <a href="Algorithms-CL-Types.html#t:CLReal">CLReal</a> <a href="src/Algorithms/CL/CL.html#line-137" class="link">Source</a> <a href="#v:improve_regulator_accuracy" class="selflink">#</a></p><div class="doc"><p>Improve the precision of the initial estimate of the regulator <em>R</em>, for 
 a quadratic discriminant &#916;.</p><p>The implementation is essentially based on the proof of Theorem 5 of 
 &#91;Jozsa 2003&#93;.</p></div></div><h1 id="g:3">Stage 3 (classical): Find generators of the class group.</h1><div class="top"><p class="src"><a id="v:compute_generators" class="def">compute_generators</a> :: <a href="Algorithms-CL-Types.html#t:CLIntP">CLIntP</a> -&gt; &#91;<a href="Algorithms-CL-Types.html#t:IdealRed">IdealRed</a>&#93; <a href="src/Algorithms/CL/CL.html#line-233" class="link">Source</a> <a href="#v:compute_generators" class="selflink">#</a></p><div class="doc"><p>A set of ideal classes generating <em>CL</em>(<em>K</em>).</p><p>Implementation: assuming the Generalized Riemann Hypothesis, it is
 enough to enumerate the non-principal prime ideals arising as
 factors of (<em>p</em>), for primes <em>p</em> &#8804; 12(ln &#916;)<sup>2</sup>. ([Haase and
 Maier 2006], Prop. 4.4.)  For each <em>p</em>, there are at most two such
 prime ideals, and they are easily described.</p></div></div><h1 id="g:4">Stage 4 (quantum): Find relations between generators.</h1><div class="doc"><p>Notation is as in &#91;Hallgren 2006, Section 5&#93;.  Note: Some
 components are currently missing here, and are marked
 &quot;incomplete&quot; in the code below.</p></div><div class="top"><p class="src"><a id="v:hI" class="def">hI</a> :: <a href="Algorithms-CL-Types.html#t:IdDist">IdDist</a> -&gt; <a href="Algorithms-CL-Types.html#t:CLInt">CLInt</a> -&gt; <a href="Algorithms-CL-Types.html#t:CLInt">CLInt</a> -&gt; <a href="Algorithms-CL-Types.html#t:CLInt">CLInt</a> -&gt; <a href="Algorithms-CL-Types.html#t:CLIntP">CLIntP</a> -&gt; <a href="Algorithms-CL-Types.html#t:CLIntP">CLIntP</a> -&gt; (<a href="Algorithms-CL-Types.html#t:IdDist">IdDist</a>, <a href="Algorithms-CL-Types.html#t:CLInt">CLInt</a>) <a href="src/Algorithms/CL/CL.html#line-280" class="link">Source</a> <a href="#v:hI" class="selflink">#</a></p><div class="doc"><p>Compute the generators of <em>CL</em>(<em>K</em>), function <em>hI</em>.</p></div></div><div class="top"><p class="src"><a id="v:compute_ghat" class="def">compute_ghat</a> :: <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Prelude.html#t:Integral">Integral</a> int =&gt; &#91;<a href="Algorithms-CL-Types.html#t:IdDist">IdDist</a>&#93; -&gt; &#91;int&#93; -&gt; <a href="Algorithms-CL-Types.html#t:IdDist">IdDist</a> <a href="src/Algorithms/CL/CL.html#line-304" class="link">Source</a> <a href="#v:compute_ghat" class="selflink">#</a></p><div class="doc"><p>Compute the ideals from the generators (&#285; function).</p></div></div><div class="top"><p class="src"><a id="v:compute_i_N_at" class="def">compute_i_N_at</a> :: <a href="QuipperLib-Arith.html#t:QDInt">QDInt</a> -&gt; <a href="QuipperLib-Arith.html#t:QDInt">QDInt</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> () <a href="src/Algorithms/CL/CL.html#line-316" class="link">Source</a> <a href="#v:compute_i_N_at" class="selflink">#</a></p><div class="doc"><p>Compute <em>i</em>/<em>N</em>. Incomplete.</p></div></div><div class="top"><p class="src"><a id="v:register_sizes" class="def">register_sizes</a> :: <a href="Algorithms-CL-Types.html#t:CLIntP">CLIntP</a> -&gt; <a href="Algorithms-CL-Types.html#t:CLReal">CLReal</a> -&gt; (<a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a>, <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a>, <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a>, <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a>, <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a>, <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a>, <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a>) <a href="src/Algorithms/CL/CL.html#line-325" class="link">Source</a> <a href="#v:register_sizes" class="selflink">#</a></p><div class="doc"><p>Compute register sizes for <code>structure_circuit</code>, given
  &#916; and a precise estimate of <em>R</em>. Return a 7-tuple
   (<em>q</em>,1,2,3,4,5,6) where <em>q</em> is the size of the first
   <em>k</em> registers, and 1&#8230;6 are the sizes of registers <em>k</em>+1&#8230;<em>k</em>+6.</p></div></div><div class="top"><p class="src"><a id="v:structure_circuit" class="def">structure_circuit</a> :: <a href="Algorithms-CL-Types.html#t:CLIntP">CLIntP</a> -&gt; <a href="Algorithms-CL-Types.html#t:CLReal">CLReal</a> -&gt; &#91;<a href="Algorithms-CL-Types.html#t:IdealRed">IdealRed</a>&#93; -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> &#91;<a href="QuipperLib-Arith.html#t:CInt">CInt</a>&#93; <a href="src/Algorithms/CL/CL.html#line-387" class="link">Source</a> <a href="#v:structure_circuit" class="selflink">#</a></p><div class="doc"><p>The quantum circuit used in computing the structure of <em>CL</em>(<em>K</em>),
 given &#916;, a precise estimate of <em>R</em>, and a generating set for <em>CL</em>(<em>K</em>).</p></div></div><div class="top"><p class="src"><a id="v:compute_relations" class="def">compute_relations</a> :: <a href="Algorithms-CL-Types.html#t:CLIntP">CLIntP</a> -&gt; <a href="Algorithms-CL-Types.html#t:CLReal">CLReal</a> -&gt; &#91;<a href="Algorithms-CL-Types.html#t:IdealRed">IdealRed</a>&#93; -&gt; <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/System-IO.html#t:IO">IO</a> &#91;<a href="Algorithms-CL-Types.html#t:CLInt">CLInt</a>&#93; <a href="src/Algorithms/CL/CL.html#line-442" class="link">Source</a> <a href="#v:compute_relations" class="selflink">#</a></p><div class="doc"><p>Compute the relations between a given set of reduced generators.</p></div></div><h1 id="g:5">Section 5 (classical): compute class number.</h1><div class="top"><p class="src"><a id="v:class_number" class="def">class_number</a> :: <a href="Algorithms-CL-Types.html#t:CLIntP">CLIntP</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/System-IO.html#t:IO">IO</a> <a href="Algorithms-CL-Types.html#t:CLInt">CLInt</a> <a href="src/Algorithms/CL/CL.html#line-455" class="link">Source</a> <a href="#v:class_number" class="selflink">#</a></p><div class="doc"><p>The full implementation of Hallgren&#8217;s algorithm.</p><p><code>class_number dd t</code>: computes the class number |<em>CL</em>(<em>K</em>)| for &#916; = <em>dd</em>,
 with success probability at least (1 - 1/2<sup><em>t</em></sup>).</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.17.3</p></div></body></html>
