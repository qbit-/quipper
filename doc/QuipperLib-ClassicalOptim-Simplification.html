<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>QuipperLib.ClassicalOptim.Simplification</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_QuipperLib-ClassicalOptim-Simplification.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/QuipperLib/ClassicalOptim/Simplification.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">The Quipper System</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>None</td></tr></table><p class="caption">QuipperLib.ClassicalOptim.Simplification</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Auxiliary definitions</a></li><li><a href="#g:2">Small, simple optimizations</a></li><li><a href="#g:3">Compression of wire numbering</a></li><li><a href="#g:4">A useful data structure</a></li><li><a href="#g:5">Algebraic optimization method</a><ul><li><a href="#g:6">State of the optimization automaton</a></li><li><a href="#g:7">The state monad</a></li><li><a href="#g:8">Low-level access functions</a></li><li><a href="#g:9">Higher-level access functions</a></li><li><a href="#g:10">Auxiliary functions</a></li><li><a href="#g:11">The algebraic optimization automaton          </a></li><li><a href="#g:12">Some wrappers</a></li></ul></li><li><a href="#g:13">Multi-pass optimization</a></li><li><a href="#section.orphans">Orphan instances</a></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>This module contains the core of the classical circuit
 optimization algorithm.</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><a href="#v:trace">trace</a> :: <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-String.html#t:String">String</a> -&gt; b -&gt; b</li><li class="src short"><a href="#v:moveWire">moveWire</a> :: <a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a> -&gt; <a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a> -&gt; <a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a> -&gt; <a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a></li><li class="src short"><a href="#v:flipCtl">flipCtl</a> :: <a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a> -&gt; <a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a> -&gt; <a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a></li><li class="src short"><a href="#v:moveWireFlip">moveWireFlip</a> :: <a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a> -&gt; <a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a> -&gt; <a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a> -&gt; <a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a></li><li class="src short"><a href="#v:suppress_garbage">suppress_garbage</a> :: &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>&#93; -&gt; <a href="http://hackage.haskell.org/package/containers-0.5.7.1/docs/Data-IntSet.html#t:IntSet">IntSet</a> -&gt; &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>&#93;</li><li class="src short"><a href="#v:suppressGarbageGates">suppressGarbageGates</a> :: (&#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>&#93;, &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>&#93;) -&gt; (&#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>&#93;, &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>&#93;)</li><li class="src short"><a href="#v:getAllWires">getAllWires</a> :: &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>&#93; -&gt; <a href="http://hackage.haskell.org/package/containers-0.5.7.1/docs/Data-IntSet.html#t:IntSet">IntSet</a></li><li class="src short"><a href="#v:getInitWires">getInitWires</a> :: &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>&#93; -&gt; <a href="http://hackage.haskell.org/package/containers-0.5.7.1/docs/Data-IntSet.html#t:IntSet">IntSet</a></li><li class="src short"><a href="#v:getInputWires">getInputWires</a> :: &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>&#93; -&gt; <a href="http://hackage.haskell.org/package/containers-0.5.7.1/docs/Data-IntSet.html#t:IntSet">IntSet</a></li><li class="src short"><a href="#v:compressWires">compressWires</a> :: &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>&#93; -&gt; (&#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>&#93;, &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>&#93;) -&gt; (&#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>&#93;, &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>&#93;)</li><li class="src short"><span class="keyword">type</span> <a href="#t:GateId">GateId</a> = <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a></li><li class="src short"><span class="keyword">type</span> <a href="#t:GateIdSet">GateIdSet</a> = <a href="http://hackage.haskell.org/package/containers-0.5.7.1/docs/Data-IntSet.html#t:IntSet">IntSet</a></li><li class="src short"><span class="keyword">type</span> <a href="#t:UsedWire">UsedWire</a> = <a href="http://hackage.haskell.org/package/containers-0.5.7.1/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> <a href="QuipperLib-ClassicalOptim-Simplification.html#t:GateIdSet">GateIdSet</a></li><li class="src short"><a href="#v:gateIdFindMin">gateIdFindMin</a> :: <a href="QuipperLib-ClassicalOptim-Simplification.html#t:GateIdSet">GateIdSet</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Maybe.html#t:Maybe">Maybe</a> <a href="QuipperLib-ClassicalOptim-Simplification.html#t:GateId">GateId</a></li><li class="src short"><a href="#v:gateIdFindMax">gateIdFindMax</a> :: <a href="QuipperLib-ClassicalOptim-Simplification.html#t:GateIdSet">GateIdSet</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Maybe.html#t:Maybe">Maybe</a> <a href="QuipperLib-ClassicalOptim-Simplification.html#t:GateId">GateId</a></li><li class="src short"><a href="#v:pairUsedWire">pairUsedWire</a> :: <a href="QuipperLib-ClassicalOptim-Simplification.html#t:UsedWire">UsedWire</a> -&gt; <a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a> -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:GateIdSet">GateIdSet</a></li><li class="src short"><a href="#v:firstUsedWire">firstUsedWire</a> :: <a href="QuipperLib-ClassicalOptim-Simplification.html#t:UsedWire">UsedWire</a> -&gt; <a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Maybe.html#t:Maybe">Maybe</a> <a href="QuipperLib-ClassicalOptim-Simplification.html#t:GateId">GateId</a></li><li class="src short"><a href="#v:lastUsedWire">lastUsedWire</a> :: <a href="QuipperLib-ClassicalOptim-Simplification.html#t:UsedWire">UsedWire</a> -&gt; <a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a> -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:GateId">GateId</a></li><li class="src short"><a href="#v:nextUsedGate">nextUsedGate</a> :: <a href="QuipperLib-ClassicalOptim-Simplification.html#t:UsedWire">UsedWire</a> -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:GateId">GateId</a> -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:GateId">GateId</a> -&gt; <a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a> -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:GateId">GateId</a></li><li class="src short"><a href="#v:circuitControlWires">circuitControlWires</a> :: <a href="QuipperLib-ClassicalOptim-Simplification.html#t:GateId">GateId</a> -&gt; &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>&#93; -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:UsedWire">UsedWire</a></li><li class="src short"><a href="#v:circuitNotWires">circuitNotWires</a> :: <a href="QuipperLib-ClassicalOptim-Simplification.html#t:GateId">GateId</a> -&gt; &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>&#93; -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:UsedWire">UsedWire</a></li><li class="src short"><a href="#v:exp_length">exp_length</a> :: <a href="QuipperLib-ClassicalOptim-AlgExp.html#t:Exp">Exp</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a></li><li class="src short"><a href="#v:exp_list_and">exp_list_and</a> :: &#91;Set <a href="QuipperLib-ClassicalOptim-AlgExp.html#t:Exp">Exp</a>&#93; -&gt; Set <a href="QuipperLib-ClassicalOptim-AlgExp.html#t:Exp">Exp</a></li><li class="src short"><a href="#v:expEvalCtl">expEvalCtl</a> :: <a href="http://hackage.haskell.org/package/containers-0.5.7.1/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> (Set (<a href="QuipperLib-ClassicalOptim-AlgExp.html#t:Exp">Exp</a>, <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a>)) -&gt; (<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>, <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Bool.html#t:Bool">Bool</a>) -&gt; Set <a href="QuipperLib-ClassicalOptim-AlgExp.html#t:Exp">Exp</a></li><li class="src short"><a href="#v:expEvalGate">expEvalGate</a> :: <a href="http://hackage.haskell.org/package/containers-0.5.7.1/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> (Set (<a href="QuipperLib-ClassicalOptim-AlgExp.html#t:Exp">Exp</a>, <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a>)) -&gt; <a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a> -&gt; <a href="http://hackage.haskell.org/package/containers-0.5.7.1/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> (Set (<a href="QuipperLib-ClassicalOptim-AlgExp.html#t:Exp">Exp</a>, <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a>))</li><li class="src short"><span class="keyword">data</span> <a href="#t:ExpState">ExpState</a> = <a href="#v:ExpState">ExpState</a> {<ul class="subs"><li><a href="#v:gates_to_skip">gates_to_skip</a> :: <a href="http://hackage.haskell.org/package/containers-0.5.7.1/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> <a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a></li><li><a href="#v:allWiresInCirc">allWiresInCirc</a> :: <a href="http://hackage.haskell.org/package/containers-0.5.7.1/docs/Data-IntSet.html#t:IntSet">IntSet</a></li><li><a href="#v:gateId">gateId</a> :: <a href="QuipperLib-ClassicalOptim-Simplification.html#t:GateId">GateId</a></li><li><a href="#v:usedControlWires">usedControlWires</a> :: <a href="QuipperLib-ClassicalOptim-Simplification.html#t:UsedWire">UsedWire</a></li><li><a href="#v:usedNotWires">usedNotWires</a> :: <a href="QuipperLib-ClassicalOptim-Simplification.html#t:UsedWire">UsedWire</a></li><li><a href="#v:future">future</a> :: &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>&#93;</li><li><a href="#v:past">past</a> :: &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>&#93;</li><li><a href="#v:expMap">expMap</a> :: <a href="http://hackage.haskell.org/package/containers-0.5.7.1/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> (Set (<a href="QuipperLib-ClassicalOptim-AlgExp.html#t:Exp">Exp</a>, <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a>))</li><li><a href="#v:freshVar">freshVar</a> :: <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Prelude.html#t:Integer">Integer</a></li><li><a href="#v:outWires">outWires</a> :: &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>&#93;</li><li><a href="#v:sizeCirc">sizeCirc</a> :: <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a></li></ul>}</li><li class="src short"><a href="#v:initExpState">initExpState</a> :: <a href="http://hackage.haskell.org/package/containers-0.5.7.1/docs/Data-IntSet.html#t:IntSet">IntSet</a> -&gt; &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>&#93; -&gt; &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>&#93; -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:ExpState">ExpState</a></li><li class="src short"><span class="keyword">data</span> <a href="#t:EvalCirc">EvalCirc</a> a = <a href="#v:EvalCirc">EvalCirc</a> (<a href="QuipperLib-ClassicalOptim-Simplification.html#t:ExpState">ExpState</a> -&gt; (<a href="QuipperLib-ClassicalOptim-Simplification.html#t:ExpState">ExpState</a>, a))</li><li class="src short"><a href="#v:runEvalCirc">runEvalCirc</a> :: <a href="http://hackage.haskell.org/package/containers-0.5.7.1/docs/Data-IntSet.html#t:IntSet">IntSet</a> -&gt; &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>&#93; -&gt; &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>&#93; -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a> a -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:ExpState">ExpState</a></li><li class="src short"><a href="#v:getExpState">getExpState</a> :: <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a> <a href="QuipperLib-ClassicalOptim-Simplification.html#t:ExpState">ExpState</a></li><li class="src short"><a href="#v:setExpState">setExpState</a> :: <a href="QuipperLib-ClassicalOptim-Simplification.html#t:ExpState">ExpState</a> -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a> ()</li><li class="src short"><a href="#v:newFreshVar">newFreshVar</a> :: <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a> <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Prelude.html#t:Integer">Integer</a></li><li class="src short"><a href="#v:pullNewGate">pullNewGate</a> :: <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a> (<a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Maybe.html#t:Maybe">Maybe</a> <a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>)</li><li class="src short"><a href="#v:changeFuture">changeFuture</a> :: &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>&#93; -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a> ()</li><li class="src short"><a href="#v:updateFuture">updateFuture</a> :: (<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a> -&gt; <a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>) -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a> (<a href="http://hackage.haskell.org/package/containers-0.5.7.1/docs/Data-IntSet.html#t:IntSet">IntSet</a>, <a href="http://hackage.haskell.org/package/containers-0.5.7.1/docs/Data-IntSet.html#t:IntSet">IntSet</a>)</li><li class="src short"><a href="#v:storeOldGate">storeOldGate</a> :: <a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a> -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a> ()</li><li class="src short"><a href="#v:incrGateId">incrGateId</a> :: <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a> ()</li><li class="src short"><a href="#v:getAllWiresInCirc">getAllWiresInCirc</a> :: <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a> <a href="http://hackage.haskell.org/package/containers-0.5.7.1/docs/Data-IntSet.html#t:IntSet">IntSet</a></li><li class="src short"><a href="#v:setAllWiresInCirc">setAllWiresInCirc</a> :: <a href="http://hackage.haskell.org/package/containers-0.5.7.1/docs/Data-IntSet.html#t:IntSet">IntSet</a> -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a> ()</li><li class="src short"><a href="#v:removeFromAllWiresInCirc">removeFromAllWiresInCirc</a> :: <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a> -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a> ()</li><li class="src short"><a href="#v:getExpMap">getExpMap</a> :: <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a> (<a href="http://hackage.haskell.org/package/containers-0.5.7.1/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> (Set (<a href="QuipperLib-ClassicalOptim-AlgExp.html#t:Exp">Exp</a>, <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a>)))</li><li class="src short"><a href="#v:setExpMap">setExpMap</a> :: <a href="http://hackage.haskell.org/package/containers-0.5.7.1/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> (Set (<a href="QuipperLib-ClassicalOptim-AlgExp.html#t:Exp">Exp</a>, <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a>)) -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a> ()</li><li class="src short"><a href="#v:updateUsedControlWires">updateUsedControlWires</a> :: (<a href="QuipperLib-ClassicalOptim-Simplification.html#t:UsedWire">UsedWire</a> -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:UsedWire">UsedWire</a>) -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a> ()</li><li class="src short"><a href="#v:updateUsedNotWires">updateUsedNotWires</a> :: (<a href="QuipperLib-ClassicalOptim-Simplification.html#t:UsedWire">UsedWire</a> -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:UsedWire">UsedWire</a>) -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a> ()</li><li class="src short"><a href="#v:updateOutWires">updateOutWires</a> :: (&#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>&#93; -&gt; &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>&#93;) -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a> ()</li><li class="src short"><a href="#v:addToSkipGates">addToSkipGates</a> :: <a href="QuipperLib-ClassicalOptim-Simplification.html#t:GateId">GateId</a> -&gt; <a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a> -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a> ()</li><li class="src short"><a href="#v:sendEndOfTime">sendEndOfTime</a> :: <a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a> -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a> ()</li><li class="src short"><a href="#v:shiftGate">shiftGate</a> :: <a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a> -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:GateId">GateId</a> -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a> ()</li><li class="src short"><a href="#v:pairEqualExp">pairEqualExp</a> :: <a href="http://hackage.haskell.org/package/containers-0.5.7.1/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> &#91;<a href="QuipperLib-ClassicalOptim-AlgExp.html#t:Exp">Exp</a>&#93; -&gt; <a href="http://hackage.haskell.org/package/containers-0.5.7.1/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> &#91;<a href="QuipperLib-ClassicalOptim-AlgExp.html#t:Exp">Exp</a>&#93; -&gt; &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>&#93; -&gt; &#91;(<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>, <a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>)&#93;</li><li class="src short"><a href="#v:pruneListExp">pruneListExp</a> :: <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a> -&gt; Set (<a href="QuipperLib-ClassicalOptim-AlgExp.html#t:Exp">Exp</a>, <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a>) -&gt; Set (<a href="QuipperLib-ClassicalOptim-AlgExp.html#t:Exp">Exp</a>, <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a>)</li><li class="src short"><a href="#v:stepEvalCirc">stepEvalCirc</a> :: <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a> <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Bool.html#t:Bool">Bool</a></li><li class="src short"><a href="#v:stepSwapCirc">stepSwapCirc</a> :: <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a> <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Bool.html#t:Bool">Bool</a></li><li class="src short"><a href="#v:stepSwapCirc_simple">stepSwapCirc_simple</a> :: <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a> <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Bool.html#t:Bool">Bool</a></li><li class="src short"><a href="#v:runWhile">runWhile</a> :: <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Control-Monad.html#t:Monad">Monad</a> m =&gt; (a -&gt; <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Bool.html#t:Bool">Bool</a>) -&gt; m a -&gt; m ()</li><li class="src short"><a href="#v:stripNoOp">stripNoOp</a> :: &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>&#93; -&gt; &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>&#93;</li><li class="src short"><a href="#v:alg_simplify">alg_simplify</a> :: (&#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>&#93;, &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>&#93;) -&gt; (&#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>&#93;, &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>&#93;)</li><li class="src short"><a href="#v:alg_swap">alg_swap</a> :: (&#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>&#93;, &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>&#93;) -&gt; (&#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>&#93;, &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>&#93;)</li><li class="src short"><a href="#v:alg_swap_simple">alg_swap_simple</a> :: (&#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>&#93;, &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>&#93;) -&gt; (&#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>&#93;, &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>&#93;)</li><li class="src short"><a href="#v:is_equal_list">is_equal_list</a> :: <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Eq.html#t:Eq">Eq</a> a =&gt; &#91;a&#93; -&gt; &#91;a&#93; -&gt; <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a> -&gt; (<a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a>, <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Bool.html#t:Bool">Bool</a>)</li><li class="src short"><a href="#v:get_list_init">get_list_init</a> :: &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>&#93; -&gt; &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>&#93;</li><li class="src short"><a href="#v:simplRec-39-">simplRec'</a> :: (&#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>&#93;, &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>&#93;) -&gt; (&#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>&#93;, &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>&#93;)</li><li class="src short"><a href="#v:simplRec">simplRec</a> :: (&#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>&#93;, &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>&#93;) -&gt; (&#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>&#93;, &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>&#93;)</li></ul></div><div id="interface"><h1 id="g:1">Auxiliary definitions</h1><div class="top"><p class="src"><a id="v:trace" class="def">trace</a> :: <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-String.html#t:String">String</a> -&gt; b -&gt; b <a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-29" class="link">Source</a> <a href="#v:trace" class="selflink">#</a></p><div class="doc"><p>Internal definition of a trace, for debugging purposes. This is a
 no-op, but can be replaced to turn on debugging.</p></div></div><div class="top"><p class="src"><a id="v:moveWire" class="def">moveWire</a> :: <a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a> -&gt; <a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a> -&gt; <a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a> -&gt; <a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a> <a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-34" class="link">Source</a> <a href="#v:moveWire" class="selflink">#</a></p><div class="doc"><p>Change a wire ID in a gate. The first two arguments are the old
 and the new wire ID.</p></div></div><div class="top"><p class="src"><a id="v:flipCtl" class="def">flipCtl</a> :: <a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a> -&gt; <a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a> -&gt; <a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a> <a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-45" class="link">Source</a> <a href="#v:flipCtl" class="selflink">#</a></p><div class="doc"><p>Flip the control on the given wire (from positive to negative or
 vice versa).</p></div></div><div class="top"><p class="src"><a id="v:moveWireFlip" class="def">moveWireFlip</a> :: <a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a> -&gt; <a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a> -&gt; <a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a> -&gt; <a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a> <a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-51" class="link">Source</a> <a href="#v:moveWireFlip" class="selflink">#</a></p><div class="doc"><p>Change a wire ID in a gate and flip the potential control.</p></div></div><h1 id="g:2">Small, simple optimizations</h1><div class="top"><p class="src"><a id="v:suppress_garbage" class="def">suppress_garbage</a> :: &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>&#93; -&gt; <a href="http://hackage.haskell.org/package/containers-0.5.7.1/docs/Data-IntSet.html#t:IntSet">IntSet</a> -&gt; &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>&#93; <a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-64" class="link">Source</a> <a href="#v:suppress_garbage" class="selflink">#</a></p><div class="doc"><p>Suppress gates acting on garbage wires, i.e., wires that are not in the input set. </p></div></div><div class="top"><p class="src"><a id="v:suppressGarbageGates" class="def">suppressGarbageGates</a> :: (&#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>&#93;, &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>&#93;) -&gt; (&#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>&#93;, &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>&#93;) <a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-79" class="link">Source</a> <a href="#v:suppressGarbageGates" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="QuipperLib-ClassicalOptim-Simplification.html#v:suppress_garbage">suppress_garbage</a></code>, but packaged in a manner that is friendly for composition.</p></div></div><h1 id="g:3">Compression of wire numbering</h1><div class="doc"><p>As the optimization process goes on, many <em>init</em> gates will end
 up being discarded. The function <code><a href="QuipperLib-ClassicalOptim-Simplification.html#v:compressWires">compressWires</a></code> compacts the wire
 numbering scheme to make a smaller circuit.</p></div><div class="top"><p class="src"><a id="v:getAllWires" class="def">getAllWires</a> :: &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>&#93; -&gt; <a href="http://hackage.haskell.org/package/containers-0.5.7.1/docs/Data-IntSet.html#t:IntSet">IntSet</a> <a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-92" class="link">Source</a> <a href="#v:getAllWires" class="selflink">#</a></p><div class="doc"><p>Get the set of all wires used by the circuit.</p></div></div><div class="top"><p class="src"><a id="v:getInitWires" class="def">getInitWires</a> :: &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>&#93; -&gt; <a href="http://hackage.haskell.org/package/containers-0.5.7.1/docs/Data-IntSet.html#t:IntSet">IntSet</a> <a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-100" class="link">Source</a> <a href="#v:getInitWires" class="selflink">#</a></p><div class="doc"><p>Get the set of wires initialized by the circuit.</p></div></div><div class="top"><p class="src"><a id="v:getInputWires" class="def">getInputWires</a> :: &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>&#93; -&gt; <a href="http://hackage.haskell.org/package/containers-0.5.7.1/docs/Data-IntSet.html#t:IntSet">IntSet</a> <a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-108" class="link">Source</a> <a href="#v:getInputWires" class="selflink">#</a></p><div class="doc"><p>Get the set of input wires, i.e., the ones that are used but not initialized.</p></div></div><div class="top"><p class="src"><a id="v:compressWires" class="def">compressWires</a> :: &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>&#93; -&gt; (&#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>&#93;, &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>&#93;) -&gt; (&#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>&#93;, &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>&#93;) <a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-112" class="link">Source</a> <a href="#v:compressWires" class="selflink">#</a></p><div class="doc"><p>Compress the wire numbering.</p></div></div><h1 id="g:4">A useful data structure</h1><div class="doc"><p>When considering a particular point in a circuit (i.e., in a list
 of gates), to decide whether a given wire is used or controlled
 before or after, we keep a data-structure <code><a href="QuipperLib-ClassicalOptim-Simplification.html#t:UsedWire">UsedWire</a></code>.</p></div><div class="top"><p class="src"><span class="keyword">type</span> <a id="t:GateId" class="def">GateId</a> = <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a> <a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-138" class="link">Source</a> <a href="#t:GateId" class="selflink">#</a></p><div class="doc"><p>The type of gate ID's.</p></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a id="t:GateIdSet" class="def">GateIdSet</a> = <a href="http://hackage.haskell.org/package/containers-0.5.7.1/docs/Data-IntSet.html#t:IntSet">IntSet</a> <a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-141" class="link">Source</a> <a href="#t:GateIdSet" class="selflink">#</a></p><div class="doc"><p>A set of gate ID's.</p></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a id="t:UsedWire" class="def">UsedWire</a> = <a href="http://hackage.haskell.org/package/containers-0.5.7.1/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> <a href="QuipperLib-ClassicalOptim-Simplification.html#t:GateIdSet">GateIdSet</a> <a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-146" class="link">Source</a> <a href="#t:UsedWire" class="selflink">#</a></p><div class="doc"><p>A map from wires to pairs of <code><a href="QuipperLib-ClassicalOptim-Simplification.html#t:GateId">GateId</a></code>s. The left member gives the
 ID of the first gate using the wire, and the right member gives the
 ID of the last gate using the wire.</p></div></div><div class="top"><p class="src"><a id="v:gateIdFindMin" class="def">gateIdFindMin</a> :: <a href="QuipperLib-ClassicalOptim-Simplification.html#t:GateIdSet">GateIdSet</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Maybe.html#t:Maybe">Maybe</a> <a href="QuipperLib-ClassicalOptim-Simplification.html#t:GateId">GateId</a> <a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-149" class="link">Source</a> <a href="#v:gateIdFindMin" class="selflink">#</a></p><div class="doc"><p>Get the minimum of a set of gate ID's.</p></div></div><div class="top"><p class="src"><a id="v:gateIdFindMax" class="def">gateIdFindMax</a> :: <a href="QuipperLib-ClassicalOptim-Simplification.html#t:GateIdSet">GateIdSet</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Maybe.html#t:Maybe">Maybe</a> <a href="QuipperLib-ClassicalOptim-Simplification.html#t:GateId">GateId</a> <a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-153" class="link">Source</a> <a href="#v:gateIdFindMax" class="selflink">#</a></p><div class="doc"><p>Get the maximum of a set of gate ID's.</p></div></div><div class="top"><p class="src"><a id="v:pairUsedWire" class="def">pairUsedWire</a> :: <a href="QuipperLib-ClassicalOptim-Simplification.html#t:UsedWire">UsedWire</a> -&gt; <a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a> -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:GateIdSet">GateIdSet</a> <a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-157" class="link">Source</a> <a href="#v:pairUsedWire" class="selflink">#</a></p><div class="doc"><p>Get the pair corresponding to the given wire.</p></div></div><div class="top"><p class="src"><a id="v:firstUsedWire" class="def">firstUsedWire</a> :: <a href="QuipperLib-ClassicalOptim-Simplification.html#t:UsedWire">UsedWire</a> -&gt; <a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Maybe.html#t:Maybe">Maybe</a> <a href="QuipperLib-ClassicalOptim-Simplification.html#t:GateId">GateId</a> <a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-161" class="link">Source</a> <a href="#v:firstUsedWire" class="selflink">#</a></p><div class="doc"><p>Get the first gate using the wire in the future.</p></div></div><div class="top"><p class="src"><a id="v:lastUsedWire" class="def">lastUsedWire</a> :: <a href="QuipperLib-ClassicalOptim-Simplification.html#t:UsedWire">UsedWire</a> -&gt; <a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a> -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:GateId">GateId</a> <a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-165" class="link">Source</a> <a href="#v:lastUsedWire" class="selflink">#</a></p><div class="doc"><p>Get the last gate using the wire in the past. Return 0 if none.</p></div></div><div class="top"><p class="src"><a id="v:nextUsedGate" class="def">nextUsedGate</a> :: <a href="QuipperLib-ClassicalOptim-Simplification.html#t:UsedWire">UsedWire</a> -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:GateId">GateId</a> -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:GateId">GateId</a> -&gt; <a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a> -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:GateId">GateId</a> <a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-173" class="link">Source</a> <a href="#v:nextUsedGate" class="selflink">#</a></p><div class="doc"><p><code><a href="QuipperLib-ClassicalOptim-Simplification.html#v:nextUsedGate">nextUsedGate</a></code> <em>ws</em> <em>g</em> <em>g</em>' <em>w</em>: Look for the next gate in <em>ws</em>
 corresponding to wire <em>w</em>, starting from <em>g</em>. Return <em>g</em>' if none.</p></div></div><div class="top"><p class="src"><a id="v:circuitControlWires" class="def">circuitControlWires</a> :: <a href="QuipperLib-ClassicalOptim-Simplification.html#t:GateId">GateId</a> -&gt; &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>&#93; -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:UsedWire">UsedWire</a> <a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-180" class="link">Source</a> <a href="#v:circuitControlWires" class="selflink">#</a></p><div class="doc"><p>For each wire, find the set of gates placing a control on it.</p></div></div><div class="top"><p class="src"><a id="v:circuitNotWires" class="def">circuitNotWires</a> :: <a href="QuipperLib-ClassicalOptim-Simplification.html#t:GateId">GateId</a> -&gt; &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>&#93; -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:UsedWire">UsedWire</a> <a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-194" class="link">Source</a> <a href="#v:circuitNotWires" class="selflink">#</a></p><div class="doc"><p>For each wire, find the set of gates acting on it with NOT.</p></div></div><h1 id="g:5">Algebraic optimization method</h1><div class="doc"><p>To each wire in a circuit, we attach a set of formulas.  At each
 iteration, the wire that gets modified is updated with its new
 value, using all the possible values, possibly together with a
 fresh variable.  At each iteration, we also strip away the
 expressions that get too large. Here, the size of an algebraic
 expression is measured by the <code><a href="QuipperLib-ClassicalOptim-Simplification.html#v:exp_length">exp_length</a></code> function.</p></div><div class="top"><p class="src"><a id="v:exp_length" class="def">exp_length</a> :: <a href="QuipperLib-ClassicalOptim-AlgExp.html#t:Exp">Exp</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a> <a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-217" class="link">Source</a> <a href="#v:exp_length" class="selflink">#</a></p><div class="doc"><p>Calculate the size of an algebraic expression.</p></div></div><div class="top"><p class="src"><a id="v:exp_list_and" class="def">exp_list_and</a> :: &#91;Set <a href="QuipperLib-ClassicalOptim-AlgExp.html#t:Exp">Exp</a>&#93; -&gt; Set <a href="QuipperLib-ClassicalOptim-AlgExp.html#t:Exp">Exp</a> <a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-225" class="link">Source</a> <a href="#v:exp_list_and" class="selflink">#</a></p><div class="doc"><p>Given a list of sets of expressions, form the conjunction of
 every possible choice of one expression from each set. For example.</p><pre>exp_list_and &#91;{a,b}, {c,d}, {e,f}&#93; = 
    &#91;a&amp;#8743;c&amp;#8743;e, a&amp;#8743;c&amp;#8743;f, a&amp;#8743;d&amp;#8743;e, a&amp;#8743;d&amp;#8743;f, b&amp;#8743;c&amp;#8743;e, b&amp;#8743;c&amp;#8743;f, b&amp;#8743;d&amp;#8743;e, b&amp;#8743;d&amp;#8743;f&#93;.</pre></div></div><div class="top"><p class="src"><a id="v:expEvalCtl" class="def">expEvalCtl</a> :: <a href="http://hackage.haskell.org/package/containers-0.5.7.1/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> (Set (<a href="QuipperLib-ClassicalOptim-AlgExp.html#t:Exp">Exp</a>, <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a>)) -&gt; (<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>, <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Bool.html#t:Bool">Bool</a>) -&gt; Set <a href="QuipperLib-ClassicalOptim-AlgExp.html#t:Exp">Exp</a> <a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-231" class="link">Source</a> <a href="#v:expEvalCtl" class="selflink">#</a></p><div class="doc"><p>Evaluate a control with respect to a state.</p></div></div><div class="top"><p class="src"><a id="v:expEvalGate" class="def">expEvalGate</a> :: <a href="http://hackage.haskell.org/package/containers-0.5.7.1/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> (Set (<a href="QuipperLib-ClassicalOptim-AlgExp.html#t:Exp">Exp</a>, <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a>)) -&gt; <a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a> -&gt; <a href="http://hackage.haskell.org/package/containers-0.5.7.1/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> (Set (<a href="QuipperLib-ClassicalOptim-AlgExp.html#t:Exp">Exp</a>, <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a>)) <a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-236" class="link">Source</a> <a href="#v:expEvalGate" class="selflink">#</a></p><div class="doc"><p>Evaluate a gate with respect to a state.</p></div></div><h2 id="g:6">State of the optimization automaton</h2><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:ExpState" class="def">ExpState</a> <a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-254" class="link">Source</a> <a href="#t:ExpState" class="selflink">#</a></p><div class="doc"><p>The state of the automaton. This contains in particular the
 current state, the past and future gates, and a fresh variable.</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a id="v:ExpState" class="def">ExpState</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><ul><li><dfn class="src"><a id="v:gates_to_skip" class="def">gates_to_skip</a> :: <a href="http://hackage.haskell.org/package/containers-0.5.7.1/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> <a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a></dfn><div class="doc"><p>For use with <code><a href="QuipperLib-ClassicalOptim-Simplification.html#v:stepSwapCirc">stepSwapCirc</a></code>.</p></div></li><li><dfn class="src"><a id="v:allWiresInCirc" class="def">allWiresInCirc</a> :: <a href="http://hackage.haskell.org/package/containers-0.5.7.1/docs/Data-IntSet.html#t:IntSet">IntSet</a></dfn><div class="doc"><p>All the wires in the circuit.</p></div></li><li><dfn class="src"><a id="v:gateId" class="def">gateId</a> :: <a href="QuipperLib-ClassicalOptim-Simplification.html#t:GateId">GateId</a></dfn><div class="doc"><p>ID of the first gate in the future (starts at 1).</p></div></li><li><dfn class="src"><a id="v:usedControlWires" class="def">usedControlWires</a> :: <a href="QuipperLib-ClassicalOptim-Simplification.html#t:UsedWire">UsedWire</a></dfn><div class="doc"><p>Location of the controls.</p></div></li><li><dfn class="src"><a id="v:usedNotWires" class="def">usedNotWires</a> :: <a href="QuipperLib-ClassicalOptim-Simplification.html#t:UsedWire">UsedWire</a></dfn><div class="doc"><p>Location of the NOT gates.</p></div></li><li><dfn class="src"><a id="v:future" class="def">future</a> :: &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>&#93;</dfn><div class="doc"><p>Gates left to explore.</p></div></li><li><dfn class="src"><a id="v:past" class="def">past</a> :: &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>&#93;</dfn><div class="doc"><p>Gates already explored.</p></div></li><li><dfn class="src"><a id="v:expMap" class="def">expMap</a> :: <a href="http://hackage.haskell.org/package/containers-0.5.7.1/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> (Set (<a href="QuipperLib-ClassicalOptim-AlgExp.html#t:Exp">Exp</a>, <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a>))</dfn><div class="doc"><p>Algebraic state of the wires. Also contains the size of the expression, so we don't have to recompute it each time.</p></div></li><li><dfn class="src"><a id="v:freshVar" class="def">freshVar</a> :: <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Prelude.html#t:Integer">Integer</a></dfn><div class="doc"><p>The next fresh wire.</p></div></li><li><dfn class="src"><a id="v:outWires" class="def">outWires</a> :: &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>&#93;</dfn><div class="doc"><p>The output wires.</p></div></li><li><dfn class="src"><a id="v:sizeCirc" class="def">sizeCirc</a> :: <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a></dfn><div class="doc"><p>Size of the circuit.</p></div></li></ul></div></td></tr></table></div></div><div class="top"><p class="src"><a id="v:initExpState" class="def">initExpState</a> :: <a href="http://hackage.haskell.org/package/containers-0.5.7.1/docs/Data-IntSet.html#t:IntSet">IntSet</a> -&gt; &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>&#93; -&gt; &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>&#93; -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:ExpState">ExpState</a> <a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-280" class="link">Source</a> <a href="#v:initExpState" class="selflink">#</a></p><div class="doc"><p>The initial state for a given set of parameters.</p></div></div><h2 id="g:7">The state monad</h2><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:EvalCirc" class="def">EvalCirc</a> a <a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-299" class="link">Source</a> <a href="#t:EvalCirc" class="selflink">#</a></p><div class="doc"><p>The state monad corresponding to <code><a href="QuipperLib-ClassicalOptim-Simplification.html#t:ExpState">ExpState</a></code>.</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a id="v:EvalCirc" class="def">EvalCirc</a> (<a href="QuipperLib-ClassicalOptim-Simplification.html#t:ExpState">ExpState</a> -&gt; (<a href="QuipperLib-ClassicalOptim-Simplification.html#t:ExpState">ExpState</a>, a))</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><p id="control.i:EvalCirc" class="caption collapser" onclick="toggleSection('i:EvalCirc')">Instances</p><div id="section.i:EvalCirc" class="show"><table><tr><td class="src clearfix"><span class="inst-left"><span id="control.i:id:EvalCirc:Monad:1" class="instance expander" onclick="toggleSection('i:id:EvalCirc:Monad:1')"></span> <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Control-Monad.html#t:Monad">Monad</a> <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a></span> <a href="#t:EvalCirc" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div id="section.i:id:EvalCirc:Monad:1" class="inst-details hide"><div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:-62--62--61-">(&gt;&gt;=)</a> :: <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a> a -&gt; (a -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a> b) -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a> b <a href="#v:-62--62--61-" class="selflink">#</a></p><p class="src"><a href="#v:-62--62-">(&gt;&gt;)</a> :: <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a> a -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a> b -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a> b <a href="#v:-62--62-" class="selflink">#</a></p><p class="src"><a href="#v:return">return</a> :: a -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a> a <a href="#v:return" class="selflink">#</a></p><p class="src"><a href="#v:fail">fail</a> :: <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-String.html#t:String">String</a> -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a> a <a href="#v:fail" class="selflink">#</a></p></div></div></td></tr><tr><td class="src clearfix"><span class="inst-left"><span id="control.i:id:EvalCirc:Functor:2" class="instance expander" onclick="toggleSection('i:id:EvalCirc:Functor:2')"></span> <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Functor.html#t:Functor">Functor</a> <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a></span> <a href="#t:EvalCirc" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div id="section.i:id:EvalCirc:Functor:2" class="inst-details hide"><div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:fmap">fmap</a> :: (a -&gt; b) -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a> a -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a> b <a href="#v:fmap" class="selflink">#</a></p><p class="src"><a href="#v:-60--36-">(&lt;$)</a> :: a -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a> b -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a> a <a href="#v:-60--36-" class="selflink">#</a></p></div></div></td></tr><tr><td class="src clearfix"><span class="inst-left"><span id="control.i:id:EvalCirc:Applicative:3" class="instance expander" onclick="toggleSection('i:id:EvalCirc:Applicative:3')"></span> <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Control-Applicative.html#t:Applicative">Applicative</a> <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a></span> <a href="#t:EvalCirc" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div id="section.i:id:EvalCirc:Applicative:3" class="inst-details hide"><div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:pure">pure</a> :: a -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a> a <a href="#v:pure" class="selflink">#</a></p><p class="src"><a href="#v:-60--42--62-">(&lt;*&gt;)</a> :: <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a> (a -&gt; b) -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a> a -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a> b <a href="#v:-60--42--62-" class="selflink">#</a></p><p class="src"><a href="#v:-42--62-">(*&gt;)</a> :: <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a> a -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a> b -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a> b <a href="#v:-42--62-" class="selflink">#</a></p><p class="src"><a href="#v:-60--42-">(&lt;*)</a> :: <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a> a -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a> b -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a> a <a href="#v:-60--42-" class="selflink">#</a></p></div></div></td></tr></table></div></div></div><h2 id="g:8">Low-level access functions</h2><div class="top"><p class="src"><a id="v:runEvalCirc" class="def">runEvalCirc</a> :: <a href="http://hackage.haskell.org/package/containers-0.5.7.1/docs/Data-IntSet.html#t:IntSet">IntSet</a> -&gt; &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>&#93; -&gt; &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>&#93; -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a> a -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:ExpState">ExpState</a> <a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-318" class="link">Source</a> <a href="#v:runEvalCirc" class="selflink">#</a></p><div class="doc"><p>Construct an <code><code><a href="QuipperLib-ClassicalOptim-Simplification.html#t:ExpState">ExpState</a></code></code> out of an <code><code><a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a></code></code>.</p></div></div><div class="top"><p class="src"><a id="v:getExpState" class="def">getExpState</a> :: <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a> <a href="QuipperLib-ClassicalOptim-Simplification.html#t:ExpState">ExpState</a> <a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-322" class="link">Source</a> <a href="#v:getExpState" class="selflink">#</a></p><div class="doc"><p>Retrieve the state.</p></div></div><div class="top"><p class="src"><a id="v:setExpState" class="def">setExpState</a> :: <a href="QuipperLib-ClassicalOptim-Simplification.html#t:ExpState">ExpState</a> -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a> () <a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-326" class="link">Source</a> <a href="#v:setExpState" class="selflink">#</a></p><div class="doc"><p>Set the state.</p></div></div><h2 id="g:9">Higher-level access functions</h2><div class="top"><p class="src"><a id="v:newFreshVar" class="def">newFreshVar</a> :: <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a> <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Prelude.html#t:Integer">Integer</a> <a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-333" class="link">Source</a> <a href="#v:newFreshVar" class="selflink">#</a></p><div class="doc"><p>Create a fresh variable</p></div></div><div class="top"><p class="src"><a id="v:pullNewGate" class="def">pullNewGate</a> :: <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a> (<a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Maybe.html#t:Maybe">Maybe</a> <a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>) <a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-341" class="link">Source</a> <a href="#v:pullNewGate" class="selflink">#</a></p><div class="doc"><p>Pull a new gate to be analyzed out of the future.</p></div></div><div class="top"><p class="src"><a id="v:changeFuture" class="def">changeFuture</a> :: &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>&#93; -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a> () <a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-350" class="link">Source</a> <a href="#v:changeFuture" class="selflink">#</a></p><div class="doc"><p>Modify the future gates.</p></div></div><div class="top"><p class="src"><a id="v:updateFuture" class="def">updateFuture</a> :: (<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a> -&gt; <a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>) -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a> (<a href="http://hackage.haskell.org/package/containers-0.5.7.1/docs/Data-IntSet.html#t:IntSet">IntSet</a>, <a href="http://hackage.haskell.org/package/containers-0.5.7.1/docs/Data-IntSet.html#t:IntSet">IntSet</a>) <a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-359" class="link">Source</a> <a href="#v:updateFuture" class="selflink">#</a></p><div class="doc"><p>Update the future using the given parameter function. Return two sets
 of <code><a href="QuipperLib-ClassicalOptim-Simplification.html#v:gateId">gateId</a></code>s that got modified: the first set concerns the controls,
 the second set the NOT gates.</p></div></div><div class="top"><p class="src"><a id="v:storeOldGate" class="def">storeOldGate</a> :: <a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a> -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a> () <a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-382" class="link">Source</a> <a href="#v:storeOldGate" class="selflink">#</a></p><div class="doc"><p>Store a gate in the past.</p></div></div><div class="top"><p class="src"><a id="v:incrGateId" class="def">incrGateId</a> :: <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a> () <a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-390" class="link">Source</a> <a href="#v:incrGateId" class="selflink">#</a></p><div class="doc"><p>Increase the '@gateId@' (i.e., go forward).</p></div></div><div class="top"><p class="src"><a id="v:getAllWiresInCirc" class="def">getAllWiresInCirc</a> :: <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a> <a href="http://hackage.haskell.org/package/containers-0.5.7.1/docs/Data-IntSet.html#t:IntSet">IntSet</a> <a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-397" class="link">Source</a> <a href="#v:getAllWiresInCirc" class="selflink">#</a></p><div class="doc"><p>Get the set of all wires.</p></div></div><div class="top"><p class="src"><a id="v:setAllWiresInCirc" class="def">setAllWiresInCirc</a> :: <a href="http://hackage.haskell.org/package/containers-0.5.7.1/docs/Data-IntSet.html#t:IntSet">IntSet</a> -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a> () <a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-403" class="link">Source</a> <a href="#v:setAllWiresInCirc" class="selflink">#</a></p><div class="doc"><p>Set the set of all wires.</p></div></div><div class="top"><p class="src"><a id="v:removeFromAllWiresInCirc" class="def">removeFromAllWiresInCirc</a> :: <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a> -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a> () <a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-410" class="link">Source</a> <a href="#v:removeFromAllWiresInCirc" class="selflink">#</a></p><div class="doc"><p>Remove a gate from the set of all wires.</p></div></div><div class="top"><p class="src"><a id="v:getExpMap" class="def">getExpMap</a> :: <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a> (<a href="http://hackage.haskell.org/package/containers-0.5.7.1/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> (Set (<a href="QuipperLib-ClassicalOptim-AlgExp.html#t:Exp">Exp</a>, <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a>))) <a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-417" class="link">Source</a> <a href="#v:getExpMap" class="selflink">#</a></p><div class="doc"><p>Get the algebraic representation of the set of wires.</p></div></div><div class="top"><p class="src"><a id="v:setExpMap" class="def">setExpMap</a> :: <a href="http://hackage.haskell.org/package/containers-0.5.7.1/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> (Set (<a href="QuipperLib-ClassicalOptim-AlgExp.html#t:Exp">Exp</a>, <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a>)) -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a> () <a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-423" class="link">Source</a> <a href="#v:setExpMap" class="selflink">#</a></p><div class="doc"><p>Set the algebraic representation of the state of wires.</p></div></div><div class="top"><p class="src"><a id="v:updateUsedControlWires" class="def">updateUsedControlWires</a> :: (<a href="QuipperLib-ClassicalOptim-Simplification.html#t:UsedWire">UsedWire</a> -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:UsedWire">UsedWire</a>) -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a> () <a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-430" class="link">Source</a> <a href="#v:updateUsedControlWires" class="selflink">#</a></p><div class="doc"><p>Update the database recording the controlled wires.</p></div></div><div class="top"><p class="src"><a id="v:updateUsedNotWires" class="def">updateUsedNotWires</a> :: (<a href="QuipperLib-ClassicalOptim-Simplification.html#t:UsedWire">UsedWire</a> -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:UsedWire">UsedWire</a>) -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a> () <a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-438" class="link">Source</a> <a href="#v:updateUsedNotWires" class="selflink">#</a></p><div class="doc"><p>Update the database recording the NOT gates.</p></div></div><div class="top"><p class="src"><a id="v:updateOutWires" class="def">updateOutWires</a> :: (&#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>&#93; -&gt; &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>&#93;) -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a> () <a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-446" class="link">Source</a> <a href="#v:updateOutWires" class="selflink">#</a></p><div class="doc"><p>Update the list of output wires.</p></div></div><div class="top"><p class="src"><a id="v:addToSkipGates" class="def">addToSkipGates</a> :: <a href="QuipperLib-ClassicalOptim-Simplification.html#t:GateId">GateId</a> -&gt; <a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a> -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a> () <a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-454" class="link">Source</a> <a href="#v:addToSkipGates" class="selflink">#</a></p><div class="doc"><p>Add a gate ID to the list of gates to skip.</p></div></div><div class="top"><p class="src"><a id="v:sendEndOfTime" class="def">sendEndOfTime</a> :: <a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a> -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a> () <a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-462" class="link">Source</a> <a href="#v:sendEndOfTime" class="selflink">#</a></p><div class="doc"><p>Send a gate to the end of the future.</p></div></div><div class="top"><p class="src"><a id="v:shiftGate" class="def">shiftGate</a> :: <a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a> -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:GateId">GateId</a> -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a> () <a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-469" class="link">Source</a> <a href="#v:shiftGate" class="selflink">#</a></p><div class="doc"><p>Place a gate at the given gate ID in the future.</p></div></div><h2 id="g:10">Auxiliary functions</h2><div class="top"><p class="src"><a id="v:pairEqualExp" class="def">pairEqualExp</a> :: <a href="http://hackage.haskell.org/package/containers-0.5.7.1/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> &#91;<a href="QuipperLib-ClassicalOptim-AlgExp.html#t:Exp">Exp</a>&#93; -&gt; <a href="http://hackage.haskell.org/package/containers-0.5.7.1/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> &#91;<a href="QuipperLib-ClassicalOptim-AlgExp.html#t:Exp">Exp</a>&#93; -&gt; &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>&#93; -&gt; &#91;(<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>, <a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>)&#93; <a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-482" class="link">Source</a> <a href="#v:pairEqualExp" class="selflink">#</a></p><div class="doc"><p><code>pairEqualExp m1 m2 ws</code>: returns a list of pairs of wires <code>(x,y)</code>
 such that <code>m2 x = m1 x = m1 y</code>.</p></div></div><div class="top"><p class="src"><a id="v:pruneListExp" class="def">pruneListExp</a> :: <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a> -&gt; Set (<a href="QuipperLib-ClassicalOptim-AlgExp.html#t:Exp">Exp</a>, <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a>) -&gt; Set (<a href="QuipperLib-ClassicalOptim-AlgExp.html#t:Exp">Exp</a>, <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a>) <a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-493" class="link">Source</a> <a href="#v:pruneListExp" class="selflink">#</a></p><div class="doc"><p>From a set of expressions (annotated with sizes), prune the ones
 whose size is larger than <em>n</em>.</p></div></div><h2 id="g:11">The algebraic optimization automaton          </h2><div class="top"><p class="src"><a id="v:stepEvalCirc" class="def">stepEvalCirc</a> :: <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a> <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Bool.html#t:Bool">Bool</a> <a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-512" class="link">Source</a> <a href="#v:stepEvalCirc" class="selflink">#</a></p><div class="doc"><p>Perform a set of filters acting on one gate at a time, looking
 for:</p><ul><li>gates having no effect;</li><li>orphan NOT-gates (i.e. NOT gates negating an out-wire) ;</li><li>simple copy-cats (both positive and negative) ;</li><li>hidden copy-cats.</li></ul><p>Return <code><a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Bool.html#v:False">False</a></code> when the end of the circuit is reached, <code><a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Bool.html#v:True">True</a></code> otherwise. </p></div></div><div class="top"><p class="src"><a id="v:stepSwapCirc" class="def">stepSwapCirc</a> :: <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a> <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Bool.html#t:Bool">Bool</a> <a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-804" class="link">Source</a> <a href="#v:stepSwapCirc" class="selflink">#</a></p><div class="doc"><p>Shuffle the circuit by sending the CNOT gates as far as
 possible (i.e., until they hit a control, or to the end).
 Return <code><a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Bool.html#v:False">False</a></code> when the end of the circuit is reached, <code><a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Bool.html#v:True">True</a></code> otherwise. </p></div></div><div class="top"><p class="src"><a id="v:stepSwapCirc_simple" class="def">stepSwapCirc_simple</a> :: <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a> <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Bool.html#t:Bool">Bool</a> <a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-899" class="link">Source</a> <a href="#v:stepSwapCirc_simple" class="selflink">#</a></p><div class="doc"><p>A more elementary version of <code><code><a href="QuipperLib-ClassicalOptim-Simplification.html#v:stepSwapCirc">stepSwapCirc</a></code></code>: shuffle the
 circuit by sending to the end all the NOT gates that can be sent
 there. Return <code><a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Bool.html#v:False">False</a></code> when the end of the circuit is reached,
 <code><a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Bool.html#v:True">True</a></code> otherwise.</p></div></div><h2 id="g:12">Some wrappers</h2><div class="top"><p class="src"><a id="v:runWhile" class="def">runWhile</a> :: <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Control-Monad.html#t:Monad">Monad</a> m =&gt; (a -&gt; <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Bool.html#t:Bool">Bool</a>) -&gt; m a -&gt; m () <a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-933" class="link">Source</a> <a href="#v:runWhile" class="selflink">#</a></p><div class="doc"><p>Run the monad until <code><a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Bool.html#v:False">False</a></code> occurs.</p></div></div><div class="top"><p class="src"><a id="v:stripNoOp" class="def">stripNoOp</a> :: &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>&#93; -&gt; &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>&#93; <a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-939" class="link">Source</a> <a href="#v:stripNoOp" class="selflink">#</a></p><div class="doc"><p>Strip the <code><a href="QuipperLib-ClassicalOptim-Circuit.html#v:NoOp">NoOp</a></code> gates from a list of gates.</p></div></div><div class="top"><p class="src"><a id="v:alg_simplify" class="def">alg_simplify</a> :: (&#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>&#93;, &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>&#93;) -&gt; (&#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>&#93;, &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>&#93;) <a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-943" class="link">Source</a> <a href="#v:alg_simplify" class="selflink">#</a></p><div class="doc"><p>Wrapper around <code><a href="QuipperLib-ClassicalOptim-Simplification.html#v:stepEvalCirc">stepEvalCirc</a></code>.</p></div></div><div class="top"><p class="src"><a id="v:alg_swap" class="def">alg_swap</a> :: (&#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>&#93;, &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>&#93;) -&gt; (&#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>&#93;, &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>&#93;) <a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-952" class="link">Source</a> <a href="#v:alg_swap" class="selflink">#</a></p><div class="doc"><p>Wrapper around <code><a href="QuipperLib-ClassicalOptim-Simplification.html#v:stepSwapCirc">stepSwapCirc</a></code>.</p></div></div><div class="top"><p class="src"><a id="v:alg_swap_simple" class="def">alg_swap_simple</a> :: (&#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>&#93;, &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>&#93;) -&gt; (&#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>&#93;, &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>&#93;) <a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-962" class="link">Source</a> <a href="#v:alg_swap_simple" class="selflink">#</a></p><div class="doc"><p>Wrapper around <code><a href="QuipperLib-ClassicalOptim-Simplification.html#v:stepSwapCirc_simple">stepSwapCirc_simple</a></code>.</p></div></div><h1 id="g:13">Multi-pass optimization</h1><div class="top"><p class="src"><a id="v:is_equal_list" class="def">is_equal_list</a> :: <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Eq.html#t:Eq">Eq</a> a =&gt; &#91;a&#93; -&gt; &#91;a&#93; -&gt; <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a> -&gt; (<a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a>, <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Bool.html#t:Bool">Bool</a>) <a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-975" class="link">Source</a> <a href="#v:is_equal_list" class="selflink">#</a></p><div class="doc"><p>Auxiliary function. Simultaneously compute the maximum of the
 lengths of two lists, and their point-wise equality.</p></div></div><div class="top"><p class="src"><a id="v:get_list_init" class="def">get_list_init</a> :: &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>&#93; -&gt; &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>&#93; <a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-982" class="link">Source</a> <a href="#v:get_list_init" class="selflink">#</a></p><div class="doc"><p>Get the list of initialized wires from a circuit.</p></div></div><div class="top"><p class="src"><a id="v:simplRec-39-" class="def">simplRec'</a> :: (&#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>&#93;, &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>&#93;) -&gt; (&#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>&#93;, &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>&#93;) <a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-988" class="link">Source</a> <a href="#v:simplRec-39-" class="selflink">#</a></p><div class="doc"><p>Do several passes of <code><code><a href="QuipperLib-ClassicalOptim-Simplification.html#v:alg_simplify">alg_simplify</a></code></code> until it reaches a fixed point.</p></div></div><div class="top"><p class="src"><a id="v:simplRec" class="def">simplRec</a> :: (&#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>&#93;, &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>&#93;) -&gt; (&#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>&#93;, &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>&#93;) <a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-997" class="link">Source</a> <a href="#v:simplRec" class="selflink">#</a></p><div class="doc"><p>Do several passed of <code><code><a href="QuipperLib-ClassicalOptim-Simplification.html#v:alg_swap">alg_swap</a></code></code> followed with <code><code><a href="QuipperLib-ClassicalOptim-Simplification.html#v:simplRec">simplRec</a></code></code>
 until it reaches a fixed point.</p></div></div><h1>Orphan instances</h1><div id="section.orphans" class="show"><table><tr><td class="src clearfix"><span class="inst-left"><span id="control.i:o:ic:NFData:NFData:1" class="instance expander" onclick="toggleSection('i:o:ic:NFData:NFData:1')"></span> NFData <a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a></span> <a href="#v:-36-fNFDataGate" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div id="section.i:o:ic:NFData:NFData:1" class="inst-details hide"><div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:rnf">rnf</a> :: <a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a> -&gt; ()</p></div></div></td></tr></table></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.17.3</p></div></body></html>
