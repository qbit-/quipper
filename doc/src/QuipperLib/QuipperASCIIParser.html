<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<!-- Generated by HsColour, http://code.haskell.org/~malcolm/hscolour/ -->
<title>Haskell code</title>
</head>
<body>
<pre><a name="line-1"></a><font color=Blue><i>-- ----------------------------------------------------------------------</i></font>
<a name="line-2"></a><font color=Blue><i>-- | This module is the main interface to the QuipperASCIIParser</i></font>
<a name="line-3"></a><font color=Blue><i>-- library.  It provides functions for parsing circuits in the ASCII</i></font>
<a name="line-4"></a><font color=Blue><i>-- format written by 'print_generic' and similar functions.</i></font>
<a name="line-5"></a>
<a name="line-6"></a><font color=Green><u>module</u></font> QuipperLib<font color=Cyan>.</font>QuipperASCIIParser <font color=Green><u>where</u></font>
<a name="line-7"></a>
<a name="line-8"></a><font color=Green><u>import</u></font> <font color=Green><u>qualified</u></font> QuipperLib<font color=Cyan>.</font>QuipperASCIIParser<font color=Cyan>.</font>CircInfo <font color=Green><u>as</u></font> CI
<a name="line-9"></a><font color=Green><u>import</u></font> <font color=Green><u>qualified</u></font> QuipperLib<font color=Cyan>.</font>QuipperASCIIParser<font color=Cyan>.</font>ASCIICirc <font color=Green><u>as</u></font> AC
<a name="line-10"></a>
<a name="line-11"></a><font color=Green><u>import</u></font> Quipper
<a name="line-12"></a><font color=Green><u>import</u></font> Quipper<font color=Cyan>.</font>Monad
<a name="line-13"></a>
<a name="line-14"></a><font color=Green><u>import</u></font> Libraries<font color=Cyan>.</font>PortableSignals
<a name="line-15"></a><font color=Green><u>import</u></font> System<font color=Cyan>.</font>IO
<a name="line-16"></a><font color=Green><u>import</u></font> Data<font color=Cyan>.</font>List
<a name="line-17"></a>
<a name="line-18"></a><a name="parse_circuit"></a><font color=Blue><i>-- | Parse a string containing a circuit in the format output by</i></font>
<a name="line-19"></a><font color=Blue><i>-- Quipper's ASCII format. Return a circuit producing function of the</i></font>
<a name="line-20"></a><font color=Blue><i>-- parsed circuit, along with a specimen \"shape\" for the input of</i></font>
<a name="line-21"></a><font color=Blue><i>-- the parsed circuit.</i></font>
<a name="line-22"></a><font color=Blue>parse_circuit</font> <font color=Red>::</font> String <font color=Red>-&gt;</font> <font color=Cyan>(</font><font color=Red>[</font>Endpoint<font color=Red>]</font><font color=Cyan>,</font><font color=Red>[</font>Endpoint<font color=Red>]</font> <font color=Red>-&gt;</font> Circ <font color=Red>[</font>Endpoint<font color=Red>]</font><font color=Cyan>)</font>
<a name="line-23"></a><font color=Blue>parse_circuit</font> all_lines <font color=Red>=</font> AC<font color=Cyan>.</font>run mins gates subs circ_info
<a name="line-24"></a> <font color=Green><u>where</u></font>
<a name="line-25"></a>  split_lines <font color=Red>=</font> lines' all_lines
<a name="line-26"></a>  <font color=Cyan>(</font>mins<font color=Cyan>,</font> ci<font color=Cyan>)</font> <font color=Red>=</font> CI<font color=Cyan>.</font>run_ascii_lines split_lines
<a name="line-27"></a>  <font color=Cyan>(</font>gates<font color=Cyan>,</font>subs<font color=Cyan>,</font>circ_info<font color=Cyan>)</font> <font color=Red>=</font> CI<font color=Cyan>.</font>run ci
<a name="line-28"></a>
<a name="line-29"></a>
<a name="line-30"></a><a name="lines'"></a><font color=Blue><i>-- | Like 'lines', except that the last line is omitted if it doesn't</i></font>
<a name="line-31"></a><font color=Blue><i>-- end with a newline character</i></font>
<a name="line-32"></a><font color=Blue>lines'</font> <font color=Red>::</font> String <font color=Red>-&gt;</font> <font color=Red>[</font>String<font color=Red>]</font>
<a name="line-33"></a><font color=Blue>lines'</font> [] <font color=Red>=</font> []
<a name="line-34"></a><font color=Blue>lines'</font> s <font color=Red>=</font> <font color=Green><u>case</u></font> elemIndex <font color=Magenta>'\n'</font> s <font color=Green><u>of</u></font>
<a name="line-35"></a>            Nothing <font color=Red>-&gt;</font> []
<a name="line-36"></a>            Just n <font color=Red>-&gt;</font> <font color=Cyan>(</font>take <font color=Cyan>(</font>n<font color=Cyan>)</font> s<font color=Cyan>)</font><font color=Red><b>:</b></font>lines' <font color=Cyan>(</font>drop <font color=Cyan>(</font>n<font color=Cyan>+</font><font color=Magenta>1</font><font color=Cyan>)</font> s<font color=Cyan>)</font>
<a name="line-37"></a>
<a name="line-38"></a><a name="parse_from_stdin"></a><font color=Blue><i>-- | Like 'parse_circuit', but read the circuit from the standard</i></font>
<a name="line-39"></a><font color=Blue><i>-- input stream, rather than from a string. This can be used to build</i></font>
<a name="line-40"></a><font color=Blue><i>-- stand-alone tools that process circuits in a pipeline. </i></font>
<a name="line-41"></a><font color=Blue>parse_from_stdin</font> <font color=Red>::</font> IO <font color=Cyan>(</font><font color=Red>[</font>Endpoint<font color=Red>]</font><font color=Cyan>,</font> <font color=Red>[</font>Endpoint<font color=Red>]</font> <font color=Red>-&gt;</font> Circ <font color=Red>[</font>Endpoint<font color=Red>]</font><font color=Cyan>)</font>
<a name="line-42"></a><font color=Blue>parse_from_stdin</font> <font color=Red>=</font> <font color=Green><u>do</u></font>
<a name="line-43"></a>  all_lines <font color=Red>&lt;-</font> hGetContents stdin  
<a name="line-44"></a>  return <font color=Cyan>$</font> parse_circuit all_lines
<a name="line-45"></a>
<a name="line-46"></a><a name="parse_from_stdin_with_handler"></a><font color=Blue><i>-- | Like 'parse_from_stdin', but as a special convenience, this </i></font>
<a name="line-47"></a><font color=Blue><i>-- function also installs a signal handler that will intercept the first </i></font>
<a name="line-48"></a><font color=Blue><i>-- kill signal (e.g., Ctrl-C) and close the standard input stream. </i></font>
<a name="line-49"></a><font color=Blue><i>-- This means that whichever part of the circuit was generated before the </i></font>
<a name="line-50"></a><font color=Blue><i>-- first Ctrl-C can still be processed as a partial circuit. Note that the </i></font>
<a name="line-51"></a><font color=Blue><i>-- second kill signal will still kill the program. Note that this is only</i></font>
<a name="line-52"></a><font color=Blue><i>-- defined for Non-Windows OS environments.</i></font>
<a name="line-53"></a><font color=Blue>parse_from_stdin_with_handler</font> <font color=Red>::</font> IO <font color=Cyan>(</font><font color=Red>[</font>Endpoint<font color=Red>]</font><font color=Cyan>,</font> <font color=Red>[</font>Endpoint<font color=Red>]</font> <font color=Red>-&gt;</font> Circ <font color=Red>[</font>Endpoint<font color=Red>]</font><font color=Cyan>)</font>
<a name="line-54"></a><font color=Blue>parse_from_stdin_with_handler</font> <font color=Red>=</font> <font color=Green><u>do</u></font>
<a name="line-55"></a>  installHandler Interrupt <font color=Cyan>(</font>CatchOnce <font color=Cyan>(</font>hClose stdin<font color=Cyan>)</font><font color=Cyan>)</font>
<a name="line-56"></a>  all_lines <font color=Red>&lt;-</font> hGetContents stdin  
<a name="line-57"></a>  return <font color=Cyan>$</font> parse_circuit all_lines
</pre>
</body>
</html>