<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<!-- Generated by HsColour, http://code.haskell.org/~malcolm/hscolour/ -->
<title>Haskell code</title>
</head>
<body>
<pre><a name="line-1"></a><font color=Blue><i>{-# LANGUAGE FlexibleInstances #-}</i></font>
<a name="line-2"></a><font color=Blue><i>{-# LANGUAGE MultiParamTypeClasses #-}</i></font>
<a name="line-3"></a><font color=Blue><i>{-# LANGUAGE FunctionalDependencies #-}</i></font>
<a name="line-4"></a><font color=Blue><i>{-# LANGUAGE UndecidableInstances #-}</i></font>
<a name="line-5"></a><font color=Blue><i>{-# LANGUAGE TypeSynonymInstances #-}</i></font>
<a name="line-6"></a><font color=Blue><i>{-# LANGUAGE ScopedTypeVariables #-}</i></font>
<a name="line-7"></a><font color=Blue><i>{-# LANGUAGE FlexibleContexts  #-}</i></font>
<a name="line-8"></a><font color=Blue><i>{-# LANGUAGE TypeFamilies #-}</i></font>
<a name="line-9"></a><font color=Blue><i>{-# LANGUAGE Rank2Types #-}</i></font>
<a name="line-10"></a>
<a name="line-11"></a><font color=Blue><i>-- | This module provides functions for simulating circuits, </i></font>
<a name="line-12"></a><font color=Blue><i>-- for testing and debugging purposes. </i></font>
<a name="line-13"></a><font color=Blue><i>-- It borrows ideas from the implementation of the Quantum IO Monad.</i></font>
<a name="line-14"></a><font color=Blue><i>-- </i></font>
<a name="line-15"></a><font color=Blue><i>-- This module provides the internal implementation of the library,</i></font>
<a name="line-16"></a><font color=Blue><i>-- and can be imported by other libraries. The public interface to</i></font>
<a name="line-17"></a><font color=Blue><i>-- simulation is "QuipperLib.Simulation".</i></font>
<a name="line-18"></a>
<a name="line-19"></a><font color=Green><u>module</u></font> QuipperLib<font color=Cyan>.</font>Simulation<font color=Cyan>.</font>QuantumSimulation <font color=Green><u>where</u></font>
<a name="line-20"></a>
<a name="line-21"></a><font color=Green><u>import</u></font> Quipper
<a name="line-22"></a><font color=Green><u>import</u></font> Quipper<font color=Cyan>.</font>Internal
<a name="line-23"></a>
<a name="line-24"></a><font color=Blue><i>-- The following is a bunch of stuff we need to import because,</i></font>
<a name="line-25"></a><font color=Blue><i>-- temporarily, QuantumSimulation.hs uses low-level interfaces. It</i></font>
<a name="line-26"></a><font color=Blue><i>-- should be re-implemented using only high-level interfaces, or in</i></font>
<a name="line-27"></a><font color=Blue><i>-- some cases, more stuff should be exported from Quipper.hs.</i></font>
<a name="line-28"></a><font color=Green><u>import</u></font> Quipper<font color=Cyan>.</font>Circuit
<a name="line-29"></a><font color=Green><u>import</u></font> Quipper<font color=Cyan>.</font>Transformer
<a name="line-30"></a><font color=Green><u>import</u></font> Quipper<font color=Cyan>.</font>Monad <font color=Cyan>(</font>qubit_of_wire<font color=Cyan>)</font>
<a name="line-31"></a><font color=Green><u>import</u></font> Quipper<font color=Cyan>.</font>Generic <font color=Cyan>(</font>encapsulate_dynamic<font color=Cyan>,</font> qc_unbind<font color=Cyan>)</font>
<a name="line-32"></a>
<a name="line-33"></a><font color=Green><u>import</u></font> Libraries<font color=Cyan>.</font>Auxiliary
<a name="line-34"></a>
<a name="line-35"></a><font color=Blue><i>-- we use the state monad to hold our \"quantum\" state</i></font>
<a name="line-36"></a><font color=Green><u>import</u></font> Control<font color=Cyan>.</font>Monad<font color=Cyan>.</font>State
<a name="line-37"></a><font color=Blue><i>-- we use complex numbers as our probability amplitudes</i></font>
<a name="line-38"></a><font color=Green><u>import</u></font> Quantum<font color=Cyan>.</font>Synthesis<font color=Cyan>.</font>Ring <font color=Cyan>(</font>Cplx <font color=Cyan>(</font><font color=Red>..</font><font color=Cyan>)</font><font color=Cyan>,</font> i<font color=Cyan>)</font>
<a name="line-39"></a><font color=Blue><i>-- we use a random number generator to simulate \"quantum randomness\"</i></font>
<a name="line-40"></a><font color=Green><u>import</u></font> System<font color=Cyan>.</font>Random hiding <font color=Cyan>(</font>split<font color=Cyan>)</font>
<a name="line-41"></a><font color=Blue><i>-- we store \"basis\" states as a map, </i></font>
<a name="line-42"></a><font color=Green><u>import</u></font> Data<font color=Cyan>.</font>Map <font color=Cyan>(</font>Map<font color=Cyan>)</font>
<a name="line-43"></a><font color=Green><u>import</u></font> <font color=Green><u>qualified</u></font> Data<font color=Cyan>.</font>Map <font color=Green><u>as</u></font> Map
<a name="line-44"></a>
<a name="line-45"></a><font color=Green><u>import</u></font> Data<font color=Cyan>.</font>List <font color=Cyan>(</font>partition<font color=Cyan>)</font>
<a name="line-46"></a>
<a name="line-47"></a><font color=Green><u>import</u></font> Control<font color=Cyan>.</font>Applicative <font color=Cyan>(</font>Applicative<font color=Cyan>(</font><font color=Red>..</font><font color=Cyan>)</font><font color=Cyan>)</font>
<a name="line-48"></a><font color=Green><u>import</u></font> Control<font color=Cyan>.</font>Monad <font color=Cyan>(</font>liftM<font color=Cyan>,</font> ap<font color=Cyan>)</font>
<a name="line-49"></a>
<a name="line-50"></a><font color=Green><u>import</u></font> <font color=Green><u>qualified</u></font> Debug<font color=Cyan>.</font>Trace <font color=Blue><i>-- used in tracing the simulation of quipper computations</i></font>
<a name="line-51"></a>
<a name="line-52"></a><a name="trace"></a><font color=Blue><i>-- | We define our own trace function that only calls trace if the boolean</i></font>
<a name="line-53"></a><font color=Blue><i>-- argument is true.</i></font>
<a name="line-54"></a><font color=Blue>trace</font> <font color=Red>::</font> Bool <font color=Red>-&gt;</font> String <font color=Red>-&gt;</font> a <font color=Red>-&gt;</font> a
<a name="line-55"></a><font color=Blue>trace</font> False <font color=Green><u>_</u></font> a <font color=Red>=</font> a
<a name="line-56"></a><font color=Blue>trace</font> True message a <font color=Red>=</font> Debug<font color=Cyan>.</font>Trace<font color=Cyan>.</font>trace message a
<a name="line-57"></a>
<a name="line-58"></a><font color=Blue><i>-- ======================================================================</i></font>
<a name="line-59"></a><font color=Blue><i>-- * Simulation as a Transformer</i></font>
<a name="line-60"></a>
<a name="line-61"></a><font color=Blue><i>-- $ The quantum simulator takes a Quipper circuit producing function,</i></font>
<a name="line-62"></a><font color=Blue><i>-- and uses a transformer to simulate the resulting circuit, one gate at a time.</i></font>
<a name="line-63"></a><font color=Blue><i>-- This allows the simulation to progress in a lazy manner, allowing dynamic</i></font>
<a name="line-64"></a><font color=Blue><i>-- lifting results to be passed back to the circuit producing function as</i></font>
<a name="line-65"></a><font color=Blue><i>-- and when they are required (to generate further gates in the circuit).</i></font>
<a name="line-66"></a>
<a name="line-67"></a><font color=Blue><i>-- $ The implementation of the quantum simulator makes use of a /State/ monad</i></font>
<a name="line-68"></a><font color=Blue><i>-- to carry an underlying quantum state throughout the computation. This /State/</i></font>
<a name="line-69"></a><font color=Blue><i>-- is updated by each quantum operation within the circuit. A quantum</i></font>
<a name="line-70"></a><font color=Blue><i>-- state is a vector of 'basis' states, along with complex amplitudes.</i></font>
<a name="line-71"></a>
<a name="line-72"></a><a name="GateR"></a><font color=Blue><i>-- | Gates that act on a single qubit can be defined by essentially a 2-by-2 matrix.</i></font>
<a name="line-73"></a><a name="GateR"></a><font color=Blue><i>-- A GateR is written by rows, such that a matrix:</i></font>
<a name="line-74"></a><a name="GateR"></a><font color=Blue><i>--</i></font>
<a name="line-75"></a><a name="GateR"></a><font color=Blue><i>-- \[image GateR.png] </i></font>
<a name="line-76"></a><a name="GateR"></a><font color=Blue><i>--</i></font>
<a name="line-77"></a><a name="GateR"></a><font color=Blue><i>-- would be written as (m00,m01,m10,m11).</i></font>
<a name="line-78"></a><a name="GateR"></a><font color=Green><u>type</u></font> GateR r <font color=Red>=</font> <font color=Cyan>(</font>Cplx r<font color=Cyan>,</font>Cplx r<font color=Cyan>,</font> Cplx r<font color=Cyan>,</font> Cplx r<font color=Cyan>)</font>
<a name="line-79"></a>
<a name="line-80"></a><a name="scale"></a><font color=Blue><i>-- | Scalar multiplication of a 2-by-2 matrix by a given scalar.</i></font>
<a name="line-81"></a><font color=Blue>scale</font> <font color=Red>::</font> <font color=Cyan>(</font>Floating r<font color=Cyan>)</font> <font color=Red>=&gt;</font> Cplx r <font color=Red>-&gt;</font> GateR r <font color=Red>-&gt;</font> GateR r
<a name="line-82"></a><font color=Blue>scale</font> e <font color=Cyan>(</font>a<font color=Cyan>,</font>b<font color=Cyan>,</font>c<font color=Cyan>,</font>d<font color=Cyan>)</font> <font color=Red>=</font> <font color=Cyan>(</font>e<font color=Cyan>*</font>a<font color=Cyan>,</font>e<font color=Cyan>*</font>b<font color=Cyan>,</font>e<font color=Cyan>*</font>c<font color=Cyan>,</font>e<font color=Cyan>*</font>d<font color=Cyan>)</font> 
<a name="line-83"></a>
<a name="line-84"></a><a name="reverseR"></a><font color=Blue><i>-- | The inverse of a 'GateR' is its conjugate transpose.</i></font>
<a name="line-85"></a><font color=Blue>reverseR</font> <font color=Red>::</font> <font color=Cyan>(</font>Floating r<font color=Cyan>)</font> <font color=Red>=&gt;</font> GateR r <font color=Red>-&gt;</font> GateR r
<a name="line-86"></a><font color=Blue>reverseR</font> <font color=Cyan>(</font>m00<font color=Cyan>,</font>m01<font color=Cyan>,</font>m10<font color=Cyan>,</font>m11<font color=Cyan>)</font> <font color=Red>=</font> <font color=Cyan>(</font>conjugate m00<font color=Cyan>,</font> conjugate m10<font color=Cyan>,</font> conjugate m01<font color=Cyan>,</font> conjugate m11<font color=Cyan>)</font>
<a name="line-87"></a> <font color=Green><u>where</u></font>
<a name="line-88"></a>  conjugate <font color=Cyan>(</font>Cplx a b<font color=Cyan>)</font> <font color=Red>=</font> Cplx a <font color=Cyan>(</font><font color=Blue><i>-</i></font>b<font color=Cyan>)</font> 
<a name="line-89"></a>
<a name="line-90"></a><a name="gateQ"></a><font color=Blue><i>-- | A simple pattern matching function that gives each \"gate name\"</i></font>
<a name="line-91"></a><font color=Blue><i>-- a /GateR/ representation.  Adding (single qubit) quantum gates to</i></font>
<a name="line-92"></a><font color=Blue><i>-- this function will give them an implementation in the</i></font>
<a name="line-93"></a><font color=Blue><i>-- simulator. Any single qubit named quantum gate that needs to be</i></font>
<a name="line-94"></a><font color=Blue><i>-- simulated must have a clause in this function, along with a given</i></font>
<a name="line-95"></a><font color=Blue><i>-- /GateR/ that is its matrix representation. Note that unitarity is</i></font>
<a name="line-96"></a><font color=Blue><i>-- not enforced, so defined gates must be checked manually to be</i></font>
<a name="line-97"></a><font color=Blue><i>-- unitary operators.</i></font>
<a name="line-98"></a><font color=Blue><i>-- </i></font>
<a name="line-99"></a><font color=Blue><i>-- &gt; Example Gates:</i></font>
<a name="line-100"></a><font color=Blue><i>-- &gt; gateQ "x" = (0,1,1,0)</i></font>
<a name="line-101"></a><font color=Blue><i>-- &gt; gateQ "hadamard" = (h, h, h,-h) where h = (1/sqrt 2)</i></font>
<a name="line-102"></a><font color=Blue>gateQ</font> <font color=Red>::</font> <font color=Cyan>(</font>Floating r<font color=Cyan>)</font> <font color=Red>=&gt;</font> String <font color=Red>-&gt;</font> GateR r
<a name="line-103"></a><font color=Blue>gateQ</font> <font color=Magenta>"x"</font> <font color=Red>=</font> <font color=Cyan>(</font><font color=Magenta>0</font><font color=Cyan>,</font><font color=Magenta>1</font><font color=Cyan>,</font><font color=Magenta>1</font><font color=Cyan>,</font><font color=Magenta>0</font><font color=Cyan>)</font>
<a name="line-104"></a><font color=Blue>gateQ</font> <font color=Magenta>"hadamard"</font> <font color=Red>=</font> <font color=Cyan>(</font>h<font color=Cyan>,</font> h<font color=Cyan>,</font> h<font color=Cyan>,</font><font color=Blue><i>-</i></font>h<font color=Cyan>)</font> <font color=Green><u>where</u></font> h <font color=Red>=</font> Cplx <font color=Cyan>(</font><font color=Magenta>1</font><font color=Cyan>/</font>sqrt <font color=Magenta>2</font><font color=Cyan>)</font> <font color=Magenta>0</font>
<a name="line-105"></a><font color=Blue>gateQ</font> <font color=Magenta>"X"</font> <font color=Red>=</font> <font color=Cyan>(</font><font color=Magenta>0</font><font color=Cyan>,</font><font color=Magenta>1</font><font color=Cyan>,</font><font color=Magenta>1</font><font color=Cyan>,</font><font color=Magenta>0</font><font color=Cyan>)</font>
<a name="line-106"></a><font color=Blue>gateQ</font> <font color=Magenta>"Y"</font> <font color=Red>=</font> <font color=Cyan>(</font><font color=Magenta>0</font><font color=Cyan>,</font><font color=Blue><i>-</i></font>i<font color=Cyan>,</font>i<font color=Cyan>,</font><font color=Magenta>0</font><font color=Cyan>)</font>
<a name="line-107"></a><font color=Blue>gateQ</font> <font color=Magenta>"Z"</font> <font color=Red>=</font> <font color=Cyan>(</font><font color=Magenta>1</font><font color=Cyan>,</font><font color=Magenta>0</font><font color=Cyan>,</font><font color=Magenta>0</font><font color=Cyan>,</font><font color=Blue><i>-</i></font><font color=Magenta>1</font><font color=Cyan>)</font>
<a name="line-108"></a><font color=Blue>gateQ</font> <font color=Magenta>"S"</font> <font color=Red>=</font> <font color=Cyan>(</font><font color=Magenta>1</font><font color=Cyan>,</font><font color=Magenta>0</font><font color=Cyan>,</font><font color=Magenta>0</font><font color=Cyan>,</font>i<font color=Cyan>)</font>
<a name="line-109"></a><font color=Blue>gateQ</font> <font color=Magenta>"E"</font> <font color=Red>=</font> <font color=Cyan>(</font><font color=Cyan>(</font><font color=Blue><i>-</i></font><font color=Magenta>1</font><font color=Cyan>+</font>i<font color=Cyan>)</font><font color=Cyan>/</font><font color=Magenta>2</font><font color=Cyan>,</font> <font color=Cyan>(</font><font color=Magenta>1</font><font color=Cyan>+</font>i<font color=Cyan>)</font><font color=Cyan>/</font><font color=Magenta>2</font><font color=Cyan>,</font> <font color=Cyan>(</font><font color=Blue><i>-</i></font><font color=Magenta>1</font><font color=Cyan>+</font>i<font color=Cyan>)</font><font color=Cyan>/</font><font color=Magenta>2</font><font color=Cyan>,</font> <font color=Cyan>(</font><font color=Blue><i>-</i></font><font color=Magenta>1</font><font color=Blue><i>-</i></font>i<font color=Cyan>)</font><font color=Cyan>/</font><font color=Magenta>2</font><font color=Cyan>)</font>
<a name="line-110"></a><font color=Blue>gateQ</font> <font color=Magenta>"YY"</font> <font color=Red>=</font> <font color=Cyan>(</font>h<font color=Cyan>,</font>i<font color=Cyan>*</font>h<font color=Cyan>,</font>i<font color=Cyan>*</font>h<font color=Cyan>,</font>h<font color=Cyan>)</font> <font color=Green><u>where</u></font> h <font color=Red>=</font> Cplx <font color=Cyan>(</font><font color=Magenta>1</font><font color=Cyan>/</font>sqrt <font color=Magenta>2</font><font color=Cyan>)</font> <font color=Magenta>0</font>
<a name="line-111"></a><font color=Blue>gateQ</font> <font color=Magenta>"T"</font> <font color=Red>=</font> <font color=Cyan>(</font><font color=Magenta>1</font><font color=Cyan>,</font><font color=Magenta>0</font><font color=Cyan>,</font><font color=Magenta>0</font><font color=Cyan>,</font>omega<font color=Cyan>)</font> <font color=Green><u>where</u></font> omega <font color=Red>=</font> <font color=Cyan>(</font>Cplx <font color=Cyan>(</font><font color=Magenta>1</font> <font color=Cyan>/</font> sqrt <font color=Magenta>2</font><font color=Cyan>)</font> <font color=Cyan>(</font><font color=Magenta>1</font> <font color=Cyan>/</font> sqrt <font color=Magenta>2</font><font color=Cyan>)</font><font color=Cyan>)</font> 
<a name="line-112"></a><font color=Blue>gateQ</font> <font color=Magenta>"V"</font> <font color=Red>=</font> scale <font color=Magenta>0.5</font> <font color=Cyan>(</font>a<font color=Cyan>,</font>b<font color=Cyan>,</font>b<font color=Cyan>,</font>a<font color=Cyan>)</font> <font color=Green><u>where</u></font> a <font color=Red>=</font> Cplx <font color=Magenta>1</font> <font color=Cyan>(</font><font color=Blue><i>-</i></font><font color=Magenta>1</font><font color=Cyan>)</font>
<a name="line-113"></a>                                      b <font color=Red>=</font> Cplx <font color=Magenta>1</font> <font color=Magenta>1</font>
<a name="line-114"></a><font color=Blue>gateQ</font> <font color=Magenta>"omega"</font> <font color=Red>=</font> <font color=Cyan>(</font>omega<font color=Cyan>,</font><font color=Magenta>0</font><font color=Cyan>,</font><font color=Magenta>0</font><font color=Cyan>,</font>omega<font color=Cyan>)</font> <font color=Green><u>where</u></font> omega <font color=Red>=</font> <font color=Cyan>(</font>Cplx <font color=Cyan>(</font><font color=Magenta>1</font> <font color=Cyan>/</font> sqrt <font color=Magenta>2</font><font color=Cyan>)</font> <font color=Cyan>(</font><font color=Magenta>1</font> <font color=Cyan>/</font> sqrt <font color=Magenta>2</font><font color=Cyan>)</font><font color=Cyan>)</font>
<a name="line-115"></a><font color=Blue>gateQ</font> <font color=Magenta>"iX"</font> <font color=Red>=</font> <font color=Cyan>(</font><font color=Magenta>0</font><font color=Cyan>,</font>i<font color=Cyan>,</font>i<font color=Cyan>,</font><font color=Magenta>0</font><font color=Cyan>)</font>
<a name="line-116"></a><font color=Blue>gateQ</font> name <font color=Red>=</font> error <font color=Cyan>(</font><font color=Magenta>"quantum gate: "</font> <font color=Cyan>++</font> name <font color=Cyan>++</font> <font color=Magenta>" not implemented"</font><font color=Cyan>)</font>
<a name="line-117"></a>
<a name="line-118"></a><a name="gateQinv"></a><font color=Blue><i>-- | Like 'gateQ', but also conditionally invert the gate depending</i></font>
<a name="line-119"></a><font color=Blue><i>-- on InverseFlag.</i></font>
<a name="line-120"></a><font color=Blue>gateQinv</font> <font color=Red>::</font> <font color=Cyan>(</font>Floating r<font color=Cyan>)</font> <font color=Red>=&gt;</font> String <font color=Red>-&gt;</font> InverseFlag <font color=Red>-&gt;</font> GateR r
<a name="line-121"></a><font color=Blue>gateQinv</font> name False <font color=Red>=</font> gateQ name
<a name="line-122"></a><font color=Blue>gateQinv</font> name True <font color=Red>=</font> reverseR <font color=Cyan>(</font>gateQ name<font color=Cyan>)</font>
<a name="line-123"></a>
<a name="line-124"></a><a name="expC"></a><font color=Blue><i>-- | The exponential function for 'Cplx' numbers.</i></font>
<a name="line-125"></a><font color=Blue>expC</font> <font color=Red>::</font> <font color=Cyan>(</font>Floating r<font color=Cyan>)</font> <font color=Red>=&gt;</font> Cplx r <font color=Red>-&gt;</font> Cplx r
<a name="line-126"></a><font color=Blue>expC</font> <font color=Cyan>(</font>Cplx a b<font color=Cyan>)</font> <font color=Red>=</font> Cplx <font color=Cyan>(</font>exp a <font color=Cyan>*</font> cos b<font color=Cyan>)</font> <font color=Cyan>(</font>exp a <font color=Cyan>*</font> sin b<font color=Cyan>)</font>
<a name="line-127"></a>
<a name="line-128"></a><a name="piC"></a><font color=Blue><i>-- | The constant &#960;, as a complex number.</i></font>
<a name="line-129"></a><font color=Blue>piC</font> <font color=Red>::</font> <font color=Cyan>(</font>Floating r<font color=Cyan>)</font> <font color=Red>=&gt;</font> Cplx r
<a name="line-130"></a><font color=Blue>piC</font> <font color=Red>=</font> Cplx pi <font color=Magenta>0</font>
<a name="line-131"></a>
<a name="line-132"></a><a name="rotQ"></a><font color=Blue><i>-- | Like 'gateQ', but takes the name of a rotation and a real parameter. </i></font>
<a name="line-133"></a><font color=Blue>rotQ</font> <font color=Red>::</font> <font color=Cyan>(</font>Floating r<font color=Cyan>)</font> <font color=Red>=&gt;</font> String <font color=Red>-&gt;</font> Timestep <font color=Red>-&gt;</font> GateR r
<a name="line-134"></a><font color=Blue>rotQ</font> <font color=Magenta>"exp(-i%Z)"</font> theta <font color=Red>=</font> expZtR t
<a name="line-135"></a>  <font color=Green><u>where</u></font> t <font color=Red>=</font> fromRational <font color=Cyan>(</font>toRational theta<font color=Cyan>)</font>
<a name="line-136"></a><font color=Blue>rotQ</font> <font color=Magenta>"exp(% pi i)"</font> theta <font color=Red>=</font> gPhase t
<a name="line-137"></a>  <font color=Green><u>where</u></font> t <font color=Red>=</font> fromRational <font color=Cyan>(</font>toRational theta<font color=Cyan>)</font>
<a name="line-138"></a><font color=Blue>rotQ</font> <font color=Magenta>"R(2pi/%)"</font> theta <font color=Red>=</font> <font color=Cyan>(</font><font color=Magenta>1</font><font color=Cyan>,</font><font color=Magenta>0</font><font color=Cyan>,</font><font color=Magenta>0</font><font color=Cyan>,</font>expC <font color=Cyan>(</font><font color=Magenta>2</font><font color=Cyan>*</font>piC<font color=Cyan>*</font>i<font color=Cyan>/</font>t<font color=Cyan>)</font><font color=Cyan>)</font>
<a name="line-139"></a>  <font color=Green><u>where</u></font> t <font color=Red>=</font> fromRational <font color=Cyan>(</font>toRational theta<font color=Cyan>)</font>
<a name="line-140"></a><font color=Blue>rotQ</font> <font color=Magenta>"T(%)"</font> theta <font color=Red>=</font> <font color=Cyan>(</font><font color=Magenta>1</font><font color=Cyan>,</font><font color=Magenta>0</font><font color=Cyan>,</font><font color=Magenta>0</font><font color=Cyan>,</font>expC <font color=Cyan>(</font><font color=Blue><i>-</i></font>i<font color=Cyan>*</font>t<font color=Cyan>)</font><font color=Cyan>)</font>
<a name="line-141"></a>  <font color=Green><u>where</u></font> t <font color=Red>=</font> fromRational <font color=Cyan>(</font>toRational theta<font color=Cyan>)</font>
<a name="line-142"></a><font color=Blue>rotQ</font> <font color=Magenta>"G(%)"</font> theta <font color=Red>=</font> <font color=Cyan>(</font>expC <font color=Cyan>(</font><font color=Blue><i>-</i></font>i<font color=Cyan>*</font>t<font color=Cyan>)</font><font color=Cyan>,</font><font color=Magenta>0</font><font color=Cyan>,</font><font color=Magenta>0</font><font color=Cyan>,</font>expC <font color=Cyan>(</font><font color=Blue><i>-</i></font>i<font color=Cyan>*</font>t<font color=Cyan>)</font><font color=Cyan>)</font>
<a name="line-143"></a>  <font color=Green><u>where</u></font> t <font color=Red>=</font> fromRational <font color=Cyan>(</font>toRational theta<font color=Cyan>)</font>
<a name="line-144"></a><font color=Blue>rotQ</font> <font color=Magenta>"Rz(%)"</font> theta <font color=Red>=</font> <font color=Cyan>(</font>expC <font color=Cyan>(</font><font color=Blue><i>-</i></font>i<font color=Cyan>*</font>t<font color=Cyan>/</font><font color=Magenta>2</font><font color=Cyan>)</font><font color=Cyan>,</font><font color=Magenta>0</font><font color=Cyan>,</font><font color=Magenta>0</font><font color=Cyan>,</font>expC <font color=Cyan>(</font>i<font color=Cyan>*</font>t<font color=Cyan>/</font><font color=Magenta>2</font><font color=Cyan>)</font><font color=Cyan>)</font>
<a name="line-145"></a>  <font color=Green><u>where</u></font> t <font color=Red>=</font> fromRational <font color=Cyan>(</font>toRational theta<font color=Cyan>)</font>
<a name="line-146"></a><font color=Blue>rotQ</font> name theta <font color=Red>=</font> error <font color=Cyan>(</font><font color=Magenta>"quantum rotation: "</font> <font color=Cyan>++</font> name <font color=Cyan>++</font> <font color=Magenta>" not implemented"</font><font color=Cyan>)</font>
<a name="line-147"></a>
<a name="line-148"></a><a name="rotQinv"></a><font color=Blue><i>-- | Like 'rotQ', but also conditionally invert the gate depending on</i></font>
<a name="line-149"></a><font color=Blue><i>-- InverseFlag.</i></font>
<a name="line-150"></a><font color=Blue>rotQinv</font> <font color=Red>::</font> <font color=Cyan>(</font>Floating r<font color=Cyan>)</font> <font color=Red>=&gt;</font> String <font color=Red>-&gt;</font> InverseFlag <font color=Red>-&gt;</font> Timestep <font color=Red>-&gt;</font> GateR r
<a name="line-151"></a><font color=Blue>rotQinv</font> name False theta <font color=Red>=</font> rotQ name theta
<a name="line-152"></a><font color=Blue>rotQinv</font> name True theta <font color=Red>=</font> reverseR <font color=Cyan>(</font>rotQ name theta<font color=Cyan>)</font>
<a name="line-153"></a>
<a name="line-154"></a><a name="expZtR"></a><font color=Blue><i>-- | Return the matrix for the 'QexpZt' gate.</i></font>
<a name="line-155"></a><font color=Blue>expZtR</font> <font color=Red>::</font> <font color=Cyan>(</font>Floating r<font color=Cyan>)</font> <font color=Red>=&gt;</font> r <font color=Red>-&gt;</font> GateR r
<a name="line-156"></a><font color=Blue>expZtR</font> t <font color=Red>=</font> <font color=Cyan>(</font>expC <font color=Cyan>(</font>Cplx <font color=Magenta>0</font> <font color=Cyan>(</font><font color=Blue><i>-</i></font>t<font color=Cyan>)</font><font color=Cyan>)</font><font color=Cyan>,</font><font color=Magenta>0</font><font color=Cyan>,</font><font color=Magenta>0</font><font color=Cyan>,</font>expC <font color=Cyan>(</font>Cplx <font color=Magenta>0</font> t<font color=Cyan>)</font><font color=Cyan>)</font>
<a name="line-157"></a>
<a name="line-158"></a><a name="gPhase"></a><font color=Blue><i>-- | Return the matrix for the 'GPhase' gate.</i></font>
<a name="line-159"></a><font color=Blue>gPhase</font> <font color=Red>::</font> <font color=Cyan>(</font>Floating r<font color=Cyan>)</font> <font color=Red>=&gt;</font> r <font color=Red>-&gt;</font> GateR r
<a name="line-160"></a><font color=Blue>gPhase</font> t <font color=Red>=</font> <font color=Cyan>(</font>expC <font color=Cyan>(</font>Cplx <font color=Magenta>0</font> <font color=Cyan>(</font>t <font color=Cyan>*</font> pi<font color=Cyan>)</font><font color=Cyan>)</font><font color=Cyan>,</font><font color=Magenta>0</font><font color=Cyan>,</font><font color=Magenta>0</font><font color=Cyan>,</font>expC <font color=Cyan>(</font>Cplx <font color=Magenta>0</font> <font color=Cyan>(</font>t <font color=Cyan>*</font> pi<font color=Cyan>)</font><font color=Cyan>)</font><font color=Cyan>)</font>
<a name="line-161"></a>
<a name="line-162"></a><a name="gateC"></a><font color=Blue><i>-- | Translate a classical gate name into a boolean function.</i></font>
<a name="line-163"></a><font color=Blue><i>-- Adding classical gates to this function will give them an implementation in</i></font>
<a name="line-164"></a><font color=Blue><i>-- the simulator.</i></font>
<a name="line-165"></a><font color=Blue><i>-- </i></font>
<a name="line-166"></a><font color=Blue><i>-- &gt; Example Gate:</i></font>
<a name="line-167"></a><font color=Blue><i>-- &gt; gateC "if" [a,b,c] = if a then b else c </i></font>
<a name="line-168"></a><font color=Blue>gateC</font> <font color=Red>::</font> String <font color=Red>-&gt;</font> <font color=Cyan>(</font><font color=Red>[</font>Bool<font color=Red>]</font> <font color=Red>-&gt;</font> Bool<font color=Cyan>)</font>
<a name="line-169"></a><font color=Blue>gateC</font> <font color=Magenta>"if"</font> <font color=Red>[</font>a<font color=Cyan>,</font>b<font color=Cyan>,</font>c<font color=Red>]</font> <font color=Red>=</font> <font color=Green><u>if</u></font> a <font color=Green><u>then</u></font> b <font color=Green><u>else</u></font> c 
<a name="line-170"></a><font color=Blue>gateC</font> name inputs <font color=Red>=</font> error <font color=Cyan>(</font><font color=Magenta>"classical gate: "</font> <font color=Cyan>++</font> name <font color=Cyan>++</font> <font color=Magenta>", not implemented (at least for inputs: "</font> <font color=Cyan>++</font> show inputs <font color=Cyan>++</font> <font color=Magenta>" )"</font><font color=Cyan>)</font>
<a name="line-171"></a>
<a name="line-172"></a><a name="Vector"></a><font color=Blue><i>-- | The type of vectors with scalars in /n/ over the basis /a/. A</i></font>
<a name="line-173"></a><a name="Vector"></a><font color=Blue><i>-- vector is simply a list of pairs. </i></font>
<a name="line-174"></a><a name="Vector"></a><font color=Green><u>data</u></font> Vector n a <font color=Red>=</font> Vector <font color=Red>[</font><font color=Cyan>(</font>a<font color=Cyan>,</font>n<font color=Cyan>)</font><font color=Red>]</font>
<a name="line-175"></a>
<a name="line-176"></a><a name="Amplitudes"></a><font color=Blue><i>-- | An amplitude distribution gives each classical basis state an amplitude.</i></font>
<a name="line-177"></a><a name="Amplitudes"></a><font color=Green><u>type</u></font> Amplitudes r <font color=Red>=</font> Vector <font color=Cyan>(</font>Cplx r<font color=Cyan>)</font> <font color=Cyan>(</font>Map Qubit Bool<font color=Cyan>)</font>
<a name="line-178"></a>
<a name="line-179"></a><a name="ProbabilityDistribution"></a><font color=Blue><i>-- | A probability distribution gives each element a probability.</i></font>
<a name="line-180"></a><a name="ProbabilityDistribution"></a><font color=Green><u>type</u></font> ProbabilityDistribution r a <font color=Red>=</font> Vector r a
<a name="line-181"></a>
<a name="line-182"></a><a name="QuantumTrace"></a><font color=Blue><i>-- | A QuantumTrace is essentially a probability distribution for the current state</i></font>
<a name="line-183"></a><a name="QuantumTrace"></a><font color=Blue><i>-- of the qubits that have been traced. We can represent this using a Vector. The</i></font>
<a name="line-184"></a><a name="QuantumTrace"></a><font color=Blue><i>-- list of Booleans is in the same order as the list of Qubits that was being </i></font>
<a name="line-185"></a><a name="QuantumTrace"></a><font color=Blue><i>-- traced.</i></font>
<a name="line-186"></a><a name="QuantumTrace"></a><font color=Green><u>type</u></font> QuantumTrace r <font color=Red>=</font> ProbabilityDistribution r <font color=Red>[</font>Bool<font color=Red>]</font>
<a name="line-187"></a>
<a name="line-188"></a><a name="normalize"></a><font color=Blue><i>-- | Normalizing is used to make sure the probabilities add up to 1.</i></font>
<a name="line-189"></a><font color=Blue>normalize</font> <font color=Red>::</font> <font color=Cyan>(</font>Floating r<font color=Cyan>)</font> <font color=Red>=&gt;</font> QuantumTrace r <font color=Red>-&gt;</font> QuantumTrace r
<a name="line-190"></a><font color=Blue>normalize</font> <font color=Cyan>(</font>Vector xs<font color=Cyan>)</font> <font color=Red>=</font> Vector xs'
<a name="line-191"></a>  <font color=Green><u>where</u></font>
<a name="line-192"></a>    p' <font color=Red>=</font> Prelude<font color=Cyan>.</font>foldr <font color=Cyan>(</font><font color=Red>\</font><font color=Cyan>(</font><font color=Green><u>_</u></font><font color=Cyan>,</font>p<font color=Cyan>)</font> accum  <font color=Red>-&gt;</font> accum <font color=Cyan>+</font> p<font color=Cyan>)</font> <font color=Magenta>0.0</font> xs
<a name="line-193"></a>    xs' <font color=Red>=</font> map <font color=Cyan>(</font><font color=Red>\</font><font color=Cyan>(</font>bs<font color=Cyan>,</font>p<font color=Cyan>)</font> <font color=Red>-&gt;</font> <font color=Cyan>(</font>bs<font color=Cyan>,</font>p <font color=Cyan>/</font> p'<font color=Cyan>)</font><font color=Cyan>)</font> xs 
<a name="line-194"></a>
<a name="line-195"></a><a name="QuantumState"></a><font color=Blue><i>-- | A 'QuantumState' is the data structure containing the state that we update</i></font>
<a name="line-196"></a><a name="QuantumState"></a><font color=Blue><i>-- throughout the simulation. We need to keep track of the next available wire,</i></font>
<a name="line-197"></a><a name="QuantumState"></a><font color=Blue><i>-- and a quantum state in the form of a distribution of basis states. We also</i></font>
<a name="line-198"></a><a name="QuantumState"></a><font color=Blue><i>-- track a list of quantum traces, so that we have a \"tracing\" mechanism during</i></font>
<a name="line-199"></a><a name="QuantumState"></a><font color=Blue><i>-- the execution of quantum circuits.</i></font>
<a name="line-200"></a><a name="QuantumState"></a><font color=Green><u>data</u></font> QuantumState r <font color=Red>=</font> QState <font color=Cyan>{</font>
<a name="line-201"></a>    next_wire <font color=Red>::</font> Wire<font color=Cyan>,</font>
<a name="line-202"></a>    quantum_state <font color=Red>::</font> Amplitudes r<font color=Cyan>,</font>
<a name="line-203"></a>    traces <font color=Red>::</font> <font color=Red>[</font>QuantumTrace r<font color=Red>]</font><font color=Cyan>,</font> <font color=Blue><i>-- this will be stored in the reverse order in which</i></font>
<a name="line-204"></a>                             <font color=Blue><i>-- the traces occured in the circuit.</i></font>
<a name="line-205"></a>    namespace <font color=Red>::</font> Namespace<font color=Cyan>,</font> <font color=Blue><i>-- we need a namespace to keep track of subroutines</i></font>
<a name="line-206"></a>    trace_flag <font color=Red>::</font> Bool <font color=Blue><i>-- whether or not we trace comments during the simulation</i></font>
<a name="line-207"></a>  <font color=Cyan>}</font>
<a name="line-208"></a>
<a name="line-209"></a><a name="empty_quantum_state"></a><font color=Blue><i>-- | When we start a simulation, we need an empty starting state.</i></font>
<a name="line-210"></a><font color=Blue>empty_quantum_state</font> <font color=Red>::</font> <font color=Cyan>(</font>Floating r<font color=Cyan>)</font> <font color=Red>=&gt;</font> Bool <font color=Red>-&gt;</font> r <font color=Red>-&gt;</font> QuantumState r
<a name="line-211"></a><font color=Blue>empty_quantum_state</font> tf <font color=Green><u>_</u></font> <font color=Red>=</font> QState <font color=Cyan>{</font> next_wire <font color=Red>=</font> <font color=Magenta>0</font><font color=Cyan>,</font> quantum_state <font color=Red>=</font> Vector <font color=Red>[</font><font color=Cyan>(</font>Map<font color=Cyan>.</font>empty<font color=Cyan>,</font><font color=Magenta>1</font><font color=Cyan>)</font><font color=Red>]</font><font color=Cyan>,</font> traces <font color=Red>=</font> []<font color=Cyan>,</font> namespace <font color=Red>=</font> namespace_empty<font color=Cyan>,</font> trace_flag <font color=Red>=</font> tf<font color=Cyan>}</font>
<a name="line-212"></a>
<a name="line-213"></a><a name="classical_control"></a><font color=Blue><i>-- | It doesn't make sense having a quantum control on a classical gate, so</i></font>
<a name="line-214"></a><font color=Blue><i>-- we can throw an error if that is the case, and just collect the boolean</i></font>
<a name="line-215"></a><font color=Blue><i>-- result otherwise.</i></font>
<a name="line-216"></a><font color=Blue>classical_control</font> <font color=Red>::</font> Signed <font color=Cyan>(</font>B_Endpoint Qubit Bool<font color=Cyan>)</font> <font color=Red>-&gt;</font> Bool
<a name="line-217"></a><font color=Blue>classical_control</font> <font color=Cyan>(</font>Signed bep val<font color=Cyan>)</font> <font color=Red>=</font> <font color=Green><u>case</u></font> bep <font color=Green><u>of</u></font>
<a name="line-218"></a>  <font color=Cyan>(</font>Endpoint_Bit val'<font color=Cyan>)</font> <font color=Red>-&gt;</font> val <font color=Cyan>==</font> val'
<a name="line-219"></a>  <font color=Cyan>(</font>Endpoint_Qubit <font color=Green><u>_</u></font><font color=Cyan>)</font> <font color=Red>-&gt;</font> error <font color=Magenta>"CNot: Quantum Control on Classical Gate"</font>
<a name="line-220"></a>
<a name="line-221"></a><a name="classical_controls"></a><font color=Blue><i>-- | Map the 'classical_control' function to all the controls, and take the</i></font>
<a name="line-222"></a><font color=Blue><i>-- 'and' of the result</i></font>
<a name="line-223"></a><font color=Blue>classical_controls</font> <font color=Red>::</font> Ctrls Qubit Bool <font color=Red>-&gt;</font> Bool
<a name="line-224"></a><font color=Blue>classical_controls</font> cs <font color=Red>=</font> and <font color=Cyan>(</font>map classical_control cs<font color=Cyan>)</font>
<a name="line-225"></a>
<a name="line-226"></a><a name="qc_control"></a><font color=Blue><i>-- | When we want a quantum control, we will be working with one \"basis state\" at</i></font>
<a name="line-227"></a><font color=Blue><i>-- a time, and can look up the qubit's value in that basis state to see whether</i></font>
<a name="line-228"></a><font color=Blue><i>-- the control firs.</i></font>
<a name="line-229"></a><font color=Blue>qc_control</font> <font color=Red>::</font> Map Qubit Bool <font color=Red>-&gt;</font> Signed <font color=Cyan>(</font>B_Endpoint Qubit Bool<font color=Cyan>)</font> <font color=Red>-&gt;</font> Bool
<a name="line-230"></a><font color=Blue>qc_control</font> mqb <font color=Cyan>(</font>Signed bep val<font color=Cyan>)</font> <font color=Red>=</font> <font color=Green><u>case</u></font> bep <font color=Green><u>of</u></font>
<a name="line-231"></a>  <font color=Cyan>(</font>Endpoint_Bit val'<font color=Cyan>)</font> <font color=Red>-&gt;</font> val <font color=Cyan>==</font> val'
<a name="line-232"></a>  <font color=Cyan>(</font>Endpoint_Qubit q<font color=Cyan>)</font> <font color=Red>-&gt;</font> val <font color=Cyan>==</font> val' <font color=Green><u>where</u></font> val' <font color=Red>=</font> mqb Map<font color=Cyan>.!</font> q
<a name="line-233"></a>
<a name="line-234"></a><a name="qc_controls"></a><font color=Blue><i>-- | Map the 'qc_control' function to all the controls (under the given basis </i></font>
<a name="line-235"></a><font color=Blue><i>-- state), and take the 'and' of the result.</i></font>
<a name="line-236"></a><font color=Blue>qc_controls</font> <font color=Red>::</font> Map Qubit Bool <font color=Red>-&gt;</font> Ctrls Qubit Bool <font color=Red>-&gt;</font> Bool
<a name="line-237"></a><font color=Blue>qc_controls</font> mqb cs <font color=Red>=</font> and <font color=Cyan>(</font>map <font color=Cyan>(</font>qc_control mqb<font color=Cyan>)</font> cs<font color=Cyan>)</font>
<a name="line-238"></a>
<a name="line-239"></a><a name="magnitude"></a><font color=Blue><i>-- | We can calculate the magnitude of a complex number</i></font>
<a name="line-240"></a><font color=Blue>magnitude</font> <font color=Red>::</font> <font color=Cyan>(</font>Floating r<font color=Cyan>)</font> <font color=Red>=&gt;</font> Cplx r <font color=Red>-&gt;</font> r
<a name="line-241"></a><font color=Blue>magnitude</font> <font color=Cyan>(</font>Cplx a b<font color=Cyan>)</font> <font color=Red>=</font> sqrt <font color=Cyan>(</font>a<font color=Cyan>^</font><font color=Magenta>2</font> <font color=Cyan>+</font> b<font color=Cyan>^</font><font color=Magenta>2</font><font color=Cyan>)</font>
<a name="line-242"></a>
<a name="line-243"></a><a name="split"></a><font color=Blue><i>-- | The 'split' function splits a Amplitude distribution, by</i></font>
<a name="line-244"></a><font color=Blue><i>-- partitioning it around the state of the given qubit within each basis state. It</i></font>
<a name="line-245"></a><font color=Blue><i>-- also returns the probability of the qubit being True within the given </i></font>
<a name="line-246"></a><font color=Blue><i>-- Amplitudes. This function is used when we want to measure a qubit.</i></font>
<a name="line-247"></a><font color=Blue>split</font> <font color=Red>::</font> <font color=Cyan>(</font>Floating r<font color=Cyan>,</font> Eq r<font color=Cyan>,</font> Ord r<font color=Cyan>)</font> <font color=Red>=&gt;</font> Amplitudes r <font color=Red>-&gt;</font> Qubit <font color=Red>-&gt;</font> <font color=Cyan>(</font>r<font color=Cyan>,</font>Amplitudes r<font color=Cyan>,</font>Amplitudes r<font color=Cyan>)</font>
<a name="line-248"></a><font color=Blue>split</font> <font color=Cyan>(</font>Vector pas<font color=Cyan>)</font> q <font color=Red>=</font> <font color=Green><u>if</u></font> p <font color=Cyan>&lt;</font> <font color=Magenta>0</font> <font color=Cyan>||</font> p <font color=Cyan>&gt;</font> <font color=Magenta>1</font> 
<a name="line-249"></a>                       <font color=Green><u>then</u></font> error <font color=Magenta>"p &lt; 0 or &gt; 1"</font> 
<a name="line-250"></a>                       <font color=Green><u>else</u></font> <font color=Cyan>(</font>p<font color=Cyan>,</font>Vector ift<font color=Cyan>,</font>Vector iff<font color=Cyan>)</font>
<a name="line-251"></a> <font color=Green><u>where</u></font>
<a name="line-252"></a>  amp x <font color=Red>=</font> foldr <font color=Cyan>(</font><font color=Red>\</font><font color=Cyan>(</font><font color=Green><u>_</u></font><font color=Cyan>,</font>pa<font color=Cyan>)</font> p <font color=Red>-&gt;</font> p <font color=Cyan>+</font> <font color=Cyan>(</font><font color=Cyan>(</font>magnitude pa<font color=Cyan>)</font><font color=Cyan>*</font><font color=Cyan>(</font>magnitude pa<font color=Cyan>)</font><font color=Cyan>)</font><font color=Cyan>)</font> <font color=Magenta>0</font> x
<a name="line-253"></a>  apas <font color=Red>=</font> amp pas
<a name="line-254"></a>  <font color=Cyan>(</font>ift<font color=Cyan>,</font>iff<font color=Cyan>)</font> <font color=Red>=</font> partition <font color=Cyan>(</font><font color=Red>\</font><font color=Cyan>(</font>mqb<font color=Cyan>,</font><font color=Green><u>_</u></font><font color=Cyan>)</font> <font color=Red>-&gt;</font> <font color=Cyan>(</font>mqb Map<font color=Cyan>.!</font> q<font color=Cyan>)</font><font color=Cyan>)</font> pas  
<a name="line-255"></a>  p <font color=Red>=</font> <font color=Green><u>if</u></font> apas <font color=Cyan>==</font> <font color=Magenta>0</font> <font color=Green><u>then</u></font> <font color=Magenta>0</font> <font color=Green><u>else</u></font> <font color=Cyan>(</font>amp ift<font color=Cyan>)</font><font color=Cyan>/</font>apas
<a name="line-256"></a>
<a name="line-257"></a><a name="PMonad"></a><font color=Blue><i>-- | A PMonad is a Monad enriched with a 'merge' function that takes a probability,</i></font>
<a name="line-258"></a><a name="PMonad"></a><font color=Blue><i>-- and two results, and returns a merged version of these results under the given </i></font>
<a name="line-259"></a><a name="PMonad"></a><font color=Blue><i>-- monad. This idea is taken directly from QIO.</i></font>
<a name="line-260"></a><a name="PMonad"></a><font color=Green><u>class</u></font> <font color=Cyan>(</font>Floating r<font color=Cyan>,</font> Monad m<font color=Cyan>)</font> <font color=Red>=&gt;</font> PMonad r m <font color=Green><u>where</u></font>
<a name="line-261"></a>  merge <font color=Red>::</font> r <font color=Red>-&gt;</font> a <font color=Red>-&gt;</font> a <font color=Red>-&gt;</font> m a
<a name="line-262"></a>
<a name="line-263"></a><a name="merge_with_result"></a><font color=Blue><i>-- | We can merge two measurement outcomes, and explicitly keep the first outcome </i></font>
<a name="line-264"></a><font color=Blue><i>-- as the True result, and the second as the False result.</i></font>
<a name="line-265"></a><font color=Blue>merge_with_result</font> <font color=Red>::</font> PMonad r m <font color=Red>=&gt;</font> r <font color=Red>-&gt;</font> a <font color=Red>-&gt;</font> a <font color=Red>-&gt;</font> m <font color=Cyan>(</font>Bool<font color=Cyan>,</font>a<font color=Cyan>)</font>
<a name="line-266"></a><font color=Blue>merge_with_result</font> p ift iff <font color=Red>=</font> merge p <font color=Cyan>(</font>True<font color=Cyan>,</font>ift<font color=Cyan>)</font> <font color=Cyan>(</font>False<font color=Cyan>,</font>iff<font color=Cyan>)</font>
<a name="line-267"></a>
<a name="line-268"></a><a name="instance%20PMonad%20r%20IO"></a><font color=Blue><i>-- | IO forms a PMonad, where results are merged by choosing one probabilistically</i></font>
<a name="line-269"></a><a name="instance%20PMonad%20r%20IO"></a><font color=Blue><i>-- using a random number.</i></font>
<a name="line-270"></a><a name="instance%20PMonad%20r%20IO"></a><font color=Green><u>instance</u></font> <font color=Cyan>(</font>Floating r<font color=Cyan>,</font> Random r<font color=Cyan>,</font> Ord r<font color=Cyan>)</font> <font color=Red>=&gt;</font> PMonad r IO <font color=Green><u>where</u></font>
<a name="line-271"></a>  merge p ift iff <font color=Red>=</font> <font color=Green><u>do</u></font>
<a name="line-272"></a>   pp <font color=Red>&lt;-</font> randomRIO <font color=Cyan>(</font><font color=Magenta>0</font><font color=Cyan>,</font><font color=Magenta>1</font><font color=Cyan>)</font>
<a name="line-273"></a>   <font color=Green><u>let</u></font> res <font color=Red>=</font> <font color=Green><u>if</u></font> p <font color=Cyan>&gt;</font> pp <font color=Green><u>then</u></font> ift <font color=Green><u>else</u></font> iff
<a name="line-274"></a>   return res
<a name="line-275"></a>
<a name="line-276"></a><a name="instance%20PMonad%20r%20(State%20g)"></a><font color=Blue><i>-- | A State Monad holding a 'RandomGen' forms a 'PMonad', where results are </i></font>
<a name="line-277"></a><a name="instance%20PMonad%20r%20(State%20g)"></a><font color=Blue><i>-- merged by choosing one probabilistically using a random number from the </i></font>
<a name="line-278"></a><a name="instance%20PMonad%20r%20(State%20g)"></a><font color=Blue><i>-- 'RandomGen'.</i></font>
<a name="line-279"></a><a name="instance%20PMonad%20r%20(State%20g)"></a><font color=Green><u>instance</u></font> <font color=Cyan>(</font>Floating r<font color=Cyan>,</font> Random r<font color=Cyan>,</font> Ord r<font color=Cyan>,</font> RandomGen g<font color=Cyan>)</font> <font color=Red>=&gt;</font> PMonad r <font color=Cyan>(</font>State g<font color=Cyan>)</font> <font color=Green><u>where</u></font>
<a name="line-280"></a>  merge p ift iff <font color=Red>=</font> <font color=Green><u>do</u></font>
<a name="line-281"></a>   gen <font color=Red>&lt;-</font> get
<a name="line-282"></a>   <font color=Green><u>let</u></font> <font color=Cyan>(</font>pp<font color=Cyan>,</font>gen'<font color=Cyan>)</font> <font color=Red>=</font> randomR <font color=Cyan>(</font><font color=Magenta>0</font><font color=Cyan>,</font><font color=Magenta>1</font><font color=Cyan>)</font> gen
<a name="line-283"></a>   put gen'
<a name="line-284"></a>   <font color=Green><u>let</u></font> res <font color=Red>=</font> <font color=Green><u>if</u></font> p <font color=Cyan>&gt;</font> pp <font color=Green><u>then</u></font> ift <font color=Green><u>else</u></font> iff
<a name="line-285"></a>   return res
<a name="line-286"></a>
<a name="line-287"></a><a name="instance%20Monad%20(Vector%20n)"></a><font color=Blue><i>-- | Any numeric indexed vector forms a 'Monad'.</i></font>
<a name="line-288"></a><a name="instance%20Monad%20(Vector%20n)"></a><font color=Green><u>instance</u></font> <font color=Cyan>(</font>Num n<font color=Cyan>)</font> <font color=Red>=&gt;</font> Monad <font color=Cyan>(</font>Vector n<font color=Cyan>)</font> <font color=Green><u>where</u></font>
<a name="line-289"></a>        return a <font color=Red>=</font> Vector <font color=Red>[</font><font color=Cyan>(</font>a<font color=Cyan>,</font><font color=Magenta>1</font><font color=Cyan>)</font><font color=Red>]</font>
<a name="line-290"></a>        <font color=Cyan>(</font>Vector ps<font color=Cyan>)</font> <font color=Cyan>&gt;&gt;=</font> f <font color=Red>=</font> Vector <font color=Red>[</font><font color=Cyan>(</font>b<font color=Cyan>,</font>i<font color=Cyan>*</font>j<font color=Cyan>)</font> <font color=Red>|</font> <font color=Cyan>(</font>a<font color=Cyan>,</font>i<font color=Cyan>)</font> <font color=Red>&lt;-</font> ps<font color=Cyan>,</font> <font color=Cyan>(</font>b<font color=Cyan>,</font>j<font color=Cyan>)</font> <font color=Red>&lt;-</font> removeVector <font color=Cyan>(</font>f a<font color=Cyan>)</font><font color=Red>]</font> <font color=Green><u>where</u></font> removeVector <font color=Cyan>(</font>Vector <font color=Green><u>as</u></font><font color=Cyan>)</font> <font color=Red>=</font> <font color=Green><u>as</u></font> 
<a name="line-291"></a>
<a name="line-292"></a><a name="instance%20Applicative%20(Vector%20n)"></a><font color=Green><u>instance</u></font> <font color=Cyan>(</font>Num n<font color=Cyan>)</font> <font color=Red>=&gt;</font> Applicative <font color=Cyan>(</font>Vector n<font color=Cyan>)</font> <font color=Green><u>where</u></font>
<a name="line-293"></a>  pure <font color=Red>=</font> return
<a name="line-294"></a>  <font color=Cyan>(</font><font color=Cyan>&lt;*&gt;</font><font color=Cyan>)</font> <font color=Red>=</font> ap
<a name="line-295"></a>
<a name="line-296"></a><a name="instance%20Functor%20(Vector%20n)"></a><font color=Green><u>instance</u></font> <font color=Cyan>(</font>Num n<font color=Cyan>)</font> <font color=Red>=&gt;</font> Functor <font color=Cyan>(</font>Vector n<font color=Cyan>)</font> <font color=Green><u>where</u></font>
<a name="line-297"></a>  fmap <font color=Red>=</font> liftM
<a name="line-298"></a>
<a name="line-299"></a><a name="instance%20Show%20(Vector%20n%20a)"></a><font color=Blue><i>-- | We can show certain vectors, ignoring any 0 probabilities, and</i></font>
<a name="line-300"></a><a name="instance%20Show%20(Vector%20n%20a)"></a><font color=Blue><i>-- combining equal terms.</i></font>
<a name="line-301"></a><a name="instance%20Show%20(Vector%20n%20a)"></a><font color=Green><u>instance</u></font> <font color=Cyan>(</font>Show a<font color=Cyan>,</font>Eq a<font color=Cyan>,</font>Num n<font color=Cyan>,</font>Eq n<font color=Cyan>,</font>Show n<font color=Cyan>)</font> <font color=Red>=&gt;</font> Show <font color=Cyan>(</font>Vector n a<font color=Cyan>)</font> <font color=Green><u>where</u></font> 
<a name="line-302"></a>    show <font color=Cyan>(</font>Vector ps<font color=Cyan>)</font> <font color=Red>=</font> show <font color=Cyan>(</font>combine <font color=Cyan>(</font>filter <font color=Cyan>(</font><font color=Red>\</font> <font color=Cyan>(</font>a<font color=Cyan>,</font>p<font color=Cyan>)</font> <font color=Red>-&gt;</font> p <font color=Cyan>/=</font> <font color=Magenta>0</font><font color=Cyan>)</font> ps<font color=Cyan>)</font> []<font color=Cyan>)</font> 
<a name="line-303"></a>     <font color=Green><u>where</u></font>
<a name="line-304"></a>      combine [] <font color=Green><u>as</u></font> <font color=Red>=</font> <font color=Green><u>as</u></font>
<a name="line-305"></a>      combine <font color=Cyan>(</font>x<font color=Red><b>:</b></font>xs<font color=Cyan>)</font> <font color=Green><u>as</u></font> <font color=Red>=</font> combine xs <font color=Cyan>(</font>combine' x <font color=Green><u>as</u></font><font color=Cyan>)</font>
<a name="line-306"></a>      combine' <font color=Cyan>(</font>a<font color=Cyan>,</font>p<font color=Cyan>)</font> [] <font color=Red>=</font> <font color=Red>[</font><font color=Cyan>(</font>a<font color=Cyan>,</font>p<font color=Cyan>)</font><font color=Red>]</font>
<a name="line-307"></a>      combine' <font color=Cyan>(</font>a<font color=Cyan>,</font>p<font color=Cyan>)</font> <font color=Cyan>(</font><font color=Cyan>(</font>a'<font color=Cyan>,</font>p'<font color=Cyan>)</font><font color=Red><b>:</b></font>xs<font color=Cyan>)</font> <font color=Red>=</font> <font color=Green><u>if</u></font> a <font color=Cyan>==</font> a' <font color=Green><u>then</u></font> <font color=Cyan>(</font>a<font color=Cyan>,</font>p<font color=Cyan>+</font>p'<font color=Cyan>)</font><font color=Red><b>:</b></font>xs <font color=Green><u>else</u></font> <font color=Cyan>(</font>a'<font color=Cyan>,</font>p'<font color=Cyan>)</font><font color=Red><b>:</b></font><font color=Cyan>(</font>combine' <font color=Cyan>(</font>a<font color=Cyan>,</font>p<font color=Cyan>)</font> xs<font color=Cyan>)</font>
<a name="line-308"></a>
<a name="line-309"></a><a name="instance%20PMonad%20r%20(Vector%20r)"></a><font color=Blue><i>-- | 'ProbabilityDistribution' forms a 'PMonad' such that probabilistic results are </i></font>
<a name="line-310"></a><a name="instance%20PMonad%20r%20(Vector%20r)"></a><font color=Blue><i>-- \"merged\" by extending the probability distribution by the possible results.</i></font>
<a name="line-311"></a><a name="instance%20PMonad%20r%20(Vector%20r)"></a><font color=Green><u>instance</u></font> <font color=Cyan>(</font>Floating r<font color=Cyan>,</font> Eq r<font color=Cyan>)</font> <font color=Red>=&gt;</font> PMonad r <font color=Cyan>(</font>Vector r<font color=Cyan>)</font> <font color=Green><u>where</u></font>
<a name="line-312"></a>    merge <font color=Magenta>1</font> ift iff <font color=Red>=</font> Vector <font color=Red>[</font><font color=Cyan>(</font>ift<font color=Cyan>,</font><font color=Magenta>1</font><font color=Cyan>)</font><font color=Red>]</font>
<a name="line-313"></a>    merge <font color=Magenta>0</font> ift iff <font color=Red>=</font> Vector <font color=Red>[</font><font color=Cyan>(</font>iff<font color=Cyan>,</font><font color=Magenta>1</font><font color=Cyan>)</font><font color=Red>]</font>
<a name="line-314"></a>    merge p ift iff <font color=Red>=</font> Vector <font color=Red>[</font><font color=Cyan>(</font>ift<font color=Cyan>,</font>p<font color=Cyan>)</font><font color=Cyan>,</font><font color=Cyan>(</font>iff<font color=Cyan>,</font><font color=Magenta>1</font><font color=Blue><i>-</i></font>p<font color=Cyan>)</font><font color=Red>]</font>
<a name="line-315"></a>
<a name="line-316"></a><a name="get_trace"></a><font color=Blue><i>-- | The 'get_trace'' function returns a probability distribution of the state of</i></font>
<a name="line-317"></a><font color=Blue><i>-- a list of qubits within a given amplitude distribution.</i></font>
<a name="line-318"></a><font color=Blue>get_trace</font> <font color=Red>::</font> <font color=Cyan>(</font>Floating r<font color=Cyan>)</font> <font color=Red>=&gt;</font> <font color=Red>[</font>Qubit<font color=Red>]</font> <font color=Red>-&gt;</font> Amplitudes r <font color=Red>-&gt;</font> QuantumTrace r
<a name="line-319"></a><font color=Blue>get_trace</font> qs <font color=Cyan>(</font>Vector amps<font color=Cyan>)</font> <font color=Red>=</font> Vector ps
<a name="line-320"></a> <font color=Green><u>where</u></font>
<a name="line-321"></a>  ps <font color=Red>=</font> map <font color=Cyan>(</font>tracing qs<font color=Cyan>)</font> amps
<a name="line-322"></a>  tracing qs <font color=Cyan>(</font>mqb<font color=Cyan>,</font>cd<font color=Cyan>)</font> <font color=Red>=</font> <font color=Cyan>(</font>map <font color=Cyan>(</font><font color=Red>\</font>q <font color=Red>-&gt;</font> mqb Map<font color=Cyan>.!</font> q<font color=Cyan>)</font> qs<font color=Cyan>,</font><font color=Cyan>(</font>magnitude cd<font color=Cyan>)</font><font color=Cyan>*</font><font color=Cyan>(</font>magnitude cd<font color=Cyan>)</font><font color=Cyan>)</font> 
<a name="line-323"></a>
<a name="line-324"></a><a name="add"></a><font color=Blue><i>-- | Add an amplitude to an amplitude distribution, combining (adding) the amplitudes for equal states in the distribution.</i></font>
<a name="line-325"></a><font color=Blue>add</font> <font color=Red>::</font> <font color=Cyan>(</font>Floating r<font color=Cyan>)</font> <font color=Red>=&gt;</font> <font color=Cyan>(</font><font color=Cyan>(</font>Map Qubit Bool<font color=Cyan>)</font><font color=Cyan>,</font>Cplx r<font color=Cyan>)</font> <font color=Red>-&gt;</font> Amplitudes r <font color=Red>-&gt;</font> Amplitudes r
<a name="line-326"></a><font color=Blue>add</font> <font color=Cyan>(</font>a<font color=Cyan>,</font>x<font color=Cyan>)</font> <font color=Cyan>(</font>Vector axs<font color=Cyan>)</font> <font color=Red>=</font> Vector <font color=Cyan>(</font>add' axs<font color=Cyan>)</font>
<a name="line-327"></a>  <font color=Green><u>where</u></font> add' [] <font color=Red>=</font> <font color=Red>[</font><font color=Cyan>(</font>a<font color=Cyan>,</font>x<font color=Cyan>)</font><font color=Red>]</font>
<a name="line-328"></a>        add' <font color=Cyan>(</font><font color=Cyan>(</font>by <font color=Red>@</font> <font color=Cyan>(</font>b<font color=Cyan>,</font>y<font color=Cyan>)</font><font color=Cyan>)</font><font color=Red><b>:</b></font>bys<font color=Cyan>)</font> <font color=Red>|</font> a <font color=Cyan>==</font> b <font color=Red>=</font> <font color=Cyan>(</font>b<font color=Cyan>,</font>x<font color=Cyan>+</font>y<font color=Cyan>)</font><font color=Red><b>:</b></font>bys
<a name="line-329"></a>                                <font color=Red>|</font> otherwise <font color=Red>=</font> by<font color=Red><b>:</b></font><font color=Cyan>(</font>add' bys<font color=Cyan>)</font>
<a name="line-330"></a>
<a name="line-331"></a><a name="apply"></a><font color=Blue><i>-- | The apply' function is used to apply a function on \"basis states\" to an </i></font>
<a name="line-332"></a><font color=Blue><i>-- entire amplitude distribution. </i></font>
<a name="line-333"></a><font color=Blue>apply</font> <font color=Red>::</font> <font color=Cyan>(</font>Floating r<font color=Cyan>,</font> Eq r<font color=Cyan>)</font> <font color=Red>=&gt;</font> <font color=Cyan>(</font>Map Qubit Bool <font color=Red>-&gt;</font> Amplitudes r<font color=Cyan>)</font> <font color=Red>-&gt;</font> Amplitudes r <font color=Red>-&gt;</font> Amplitudes r
<a name="line-334"></a><font color=Blue>apply</font> f <font color=Cyan>(</font>Vector []<font color=Cyan>)</font> <font color=Red>=</font> Vector []
<a name="line-335"></a><font color=Blue>apply</font> f <font color=Cyan>(</font>Vector <font color=Cyan>(</font><font color=Cyan>(</font>a<font color=Cyan>,</font><font color=Magenta>0</font><font color=Cyan>)</font><font color=Red><b>:</b></font>[]<font color=Cyan>)</font><font color=Cyan>)</font> <font color=Red>=</font> Vector []
<a name="line-336"></a><font color=Blue>apply</font> f <font color=Cyan>(</font>Vector <font color=Cyan>(</font><font color=Cyan>(</font>a<font color=Cyan>,</font>x<font color=Cyan>)</font><font color=Red><b>:</b></font>[]<font color=Cyan>)</font><font color=Cyan>)</font> <font color=Red>=</font> Vector <font color=Cyan>(</font>map <font color=Cyan>(</font><font color=Red>\</font><font color=Cyan>(</font>b<font color=Cyan>,</font>k<font color=Cyan>)</font> <font color=Red>-&gt;</font> <font color=Cyan>(</font>b<font color=Cyan>,</font>x<font color=Cyan>*</font>k<font color=Cyan>)</font><font color=Cyan>)</font> <font color=Cyan>(</font>fa<font color=Cyan>)</font><font color=Cyan>)</font> <font color=Green><u>where</u></font> Vector fa <font color=Red>=</font> f a
<a name="line-337"></a><font color=Blue>apply</font> f <font color=Cyan>(</font>Vector <font color=Cyan>(</font><font color=Cyan>(</font>a<font color=Cyan>,</font><font color=Magenta>0</font><font color=Cyan>)</font><font color=Red><b>:</b></font>vas<font color=Cyan>)</font><font color=Cyan>)</font> <font color=Red>=</font> apply f <font color=Cyan>(</font>Vector vas<font color=Cyan>)</font>
<a name="line-338"></a><font color=Blue>apply</font> f <font color=Cyan>(</font>Vector <font color=Cyan>(</font><font color=Cyan>(</font>a<font color=Cyan>,</font>x<font color=Cyan>)</font><font color=Red><b>:</b></font>vas<font color=Cyan>)</font><font color=Cyan>)</font> <font color=Red>=</font> foldr add <font color=Cyan>(</font>apply f <font color=Cyan>(</font>Vector vas<font color=Cyan>)</font><font color=Cyan>)</font> <font color=Cyan>(</font>map <font color=Cyan>(</font><font color=Red>\</font><font color=Cyan>(</font>b<font color=Cyan>,</font>k<font color=Cyan>)</font> <font color=Red>-&gt;</font> <font color=Cyan>(</font>b<font color=Cyan>,</font>x<font color=Cyan>*</font>k<font color=Cyan>)</font><font color=Cyan>)</font> <font color=Cyan>(</font>fa<font color=Cyan>)</font><font color=Cyan>)</font> <font color=Green><u>where</u></font> Vector fa <font color=Red>=</font> f a
<a name="line-339"></a>
<a name="line-340"></a><a name="vector"></a><font color=Blue><i>-- | Lift a function that returns a single basis state, to a function that</i></font>
<a name="line-341"></a><font color=Blue><i>-- returns an amplitude distribution (containing a singleton).</i></font>
<a name="line-342"></a><font color=Blue>vector</font> <font color=Red>::</font> <font color=Cyan>(</font>Floating r<font color=Cyan>)</font> <font color=Red>=&gt;</font> <font color=Cyan>(</font>Map Qubit Bool <font color=Red>-&gt;</font> Map Qubit Bool<font color=Cyan>)</font> <font color=Red>-&gt;</font> Map Qubit Bool <font color=Red>-&gt;</font> Amplitudes r
<a name="line-343"></a><font color=Blue>vector</font> f a <font color=Red>=</font> Vector <font color=Red>[</font><font color=Cyan>(</font>f a<font color=Cyan>,</font><font color=Magenta>1</font><font color=Cyan>)</font><font color=Red>]</font>
<a name="line-344"></a>
<a name="line-345"></a><a name="if_controls"></a><font color=Blue><i>-- | apply the given function only if the controls fire.</i></font>
<a name="line-346"></a><font color=Blue>if_controls</font> <font color=Red>::</font> <font color=Cyan>(</font>Floating r<font color=Cyan>)</font> <font color=Red>=&gt;</font> Ctrls Qubit Bool <font color=Red>-&gt;</font> <font color=Cyan>(</font>Map Qubit Bool <font color=Red>-&gt;</font> Amplitudes r<font color=Cyan>)</font> <font color=Red>-&gt;</font> Map Qubit Bool <font color=Red>-&gt;</font> Amplitudes r
<a name="line-347"></a><font color=Blue>if_controls</font> c f mqb <font color=Red>=</font> <font color=Green><u>if</u></font> <font color=Cyan>(</font>qc_controls mqb c<font color=Cyan>)</font> <font color=Green><u>then</u></font> f mqb <font color=Green><u>else</u></font> Vector <font color=Red>[</font><font color=Cyan>(</font>mqb<font color=Cyan>,</font><font color=Magenta>1</font><font color=Cyan>)</font><font color=Red>]</font>
<a name="line-348"></a>
<a name="line-349"></a><a name="performGateQ"></a><font color=Blue><i>-- | 'performGateQ' defines how a single qubit gate is applied to a quantum state.</i></font>
<a name="line-350"></a><font color=Blue><i>-- The application of a /GateR/ to a qubit in a single 'basis' state can split</i></font>
<a name="line-351"></a><font color=Blue><i>-- the state into a pair of 'basis' states with corresponding amplitudes.</i></font>
<a name="line-352"></a><font color=Blue>performGateQ</font> <font color=Red>::</font> <font color=Cyan>(</font>Floating r<font color=Cyan>)</font> <font color=Red>=&gt;</font> GateR r <font color=Red>-&gt;</font> Qubit <font color=Red>-&gt;</font> Map Qubit Bool <font color=Red>-&gt;</font> Amplitudes r 
<a name="line-353"></a><font color=Blue>performGateQ</font> <font color=Cyan>(</font>m00<font color=Cyan>,</font>m01<font color=Cyan>,</font>m10<font color=Cyan>,</font>m11<font color=Cyan>)</font> q mqb <font color=Red>=</font> <font color=Green><u>if</u></font> <font color=Cyan>(</font>mqb Map<font color=Cyan>.!</font> q<font color=Cyan>)</font> <font color=Green><u>then</u></font> <font color=Cyan>(</font>Vector <font color=Red>[</font><font color=Cyan>(</font>Map<font color=Cyan>.</font>insert q False mqb<font color=Cyan>,</font>m01<font color=Cyan>)</font><font color=Cyan>,</font><font color=Cyan>(</font>mqb<font color=Cyan>,</font>m11<font color=Cyan>)</font><font color=Red>]</font><font color=Cyan>)</font>
<a name="line-354"></a>                                                    <font color=Green><u>else</u></font> <font color=Cyan>(</font>Vector <font color=Red>[</font><font color=Cyan>(</font>mqb<font color=Cyan>,</font>m00<font color=Cyan>)</font><font color=Cyan>,</font><font color=Cyan>(</font>Map<font color=Cyan>.</font>insert q True mqb<font color=Cyan>,</font>m10<font color=Cyan>)</font><font color=Red>]</font><font color=Cyan>)</font>
<a name="line-355"></a>
<a name="line-356"></a><a name="simulation_transformer"></a><font color=Blue><i>-- | The 'simulation_transformer' is the actual transformer that does the</i></font>
<a name="line-357"></a><font color=Blue><i>-- simulation. The type of the 'simulation_transformer' shows that Qubits are </i></font>
<a name="line-358"></a><font color=Blue><i>-- kept as qubits, but Bits are turned into Boolean values, i.e., the results of </i></font>
<a name="line-359"></a><font color=Blue><i>-- the computation. We use a StateT Monad, acting over the IO Monad, to store a </i></font>
<a name="line-360"></a><font color=Blue><i>-- QuantumState throughout the simulation. This means we carry a state, but also </i></font>
<a name="line-361"></a><font color=Blue><i>-- have access to the IO Monad's random number generator (for probabilistic </i></font>
<a name="line-362"></a><font color=Blue><i>-- measurement).</i></font>
<a name="line-363"></a><font color=Blue>simulation_transformer</font> <font color=Red>::</font> <font color=Cyan>(</font>PMonad r m<font color=Cyan>,</font> Ord r<font color=Cyan>)</font> <font color=Red>=&gt;</font> Transformer <font color=Cyan>(</font>StateT <font color=Cyan>(</font>QuantumState r<font color=Cyan>)</font> m<font color=Cyan>)</font> Qubit Bool
<a name="line-364"></a><font color=Blue><i>-- Translation of classical gates:</i></font>
<a name="line-365"></a><font color=Blue>simulation_transformer</font> <font color=Cyan>(</font>T_CNot ncf f<font color=Cyan>)</font> <font color=Red>=</font> f <font color=Cyan>$</font>
<a name="line-366"></a>  <font color=Red>\</font>val c <font color=Red>-&gt;</font> <font color=Green><u>do</u></font>
<a name="line-367"></a>  <font color=Green><u>let</u></font> ctrl <font color=Red>=</font> classical_controls c
<a name="line-368"></a>  <font color=Green><u>let</u></font> val' <font color=Red>=</font> <font color=Green><u>if</u></font> ctrl <font color=Green><u>then</u></font> not val <font color=Green><u>else</u></font> val
<a name="line-369"></a>  return <font color=Cyan>(</font>val'<font color=Cyan>,</font>c<font color=Cyan>)</font>
<a name="line-370"></a><font color=Blue>simulation_transformer</font> <font color=Cyan>(</font>T_CInit val ncf f<font color=Cyan>)</font> <font color=Red>=</font> f <font color=Cyan>$</font>
<a name="line-371"></a>  return val
<a name="line-372"></a><font color=Blue>simulation_transformer</font> <font color=Cyan>(</font>T_CTerm b ncf f<font color=Cyan>)</font> <font color=Red>=</font> f <font color=Cyan>$</font>
<a name="line-373"></a>  <font color=Red>\</font>val <font color=Red>-&gt;</font> <font color=Green><u>if</u></font> val <font color=Cyan>==</font> b <font color=Green><u>then</u></font> return () <font color=Green><u>else</u></font> error <font color=Magenta>"CTerm: Assertion Incorrect"</font>
<a name="line-374"></a><font color=Blue>simulation_transformer</font> <font color=Cyan>(</font>T_CDiscard f<font color=Cyan>)</font> <font color=Red>=</font> f <font color=Cyan>$</font>
<a name="line-375"></a>  <font color=Red>\</font>val <font color=Red>-&gt;</font> return ()
<a name="line-376"></a><font color=Blue>simulation_transformer</font> <font color=Cyan>(</font>T_DTerm b f<font color=Cyan>)</font> <font color=Red>=</font> f <font color=Cyan>$</font>
<a name="line-377"></a>  <font color=Red>\</font>val <font color=Red>-&gt;</font> return ()
<a name="line-378"></a><font color=Blue>simulation_transformer</font> <font color=Cyan>(</font>T_CGate name ncf f<font color=Cyan>)</font> <font color=Red>=</font> f <font color=Cyan>$</font>
<a name="line-379"></a>  <font color=Red>\</font>list <font color=Red>-&gt;</font> <font color=Green><u>do</u></font>
<a name="line-380"></a>   <font color=Green><u>let</u></font> result <font color=Red>=</font> gateC name list
<a name="line-381"></a>   return <font color=Cyan>(</font>result<font color=Cyan>,</font>list<font color=Cyan>)</font> 
<a name="line-382"></a><font color=Blue>simulation_transformer</font> g<font color=Red>@</font><font color=Cyan>(</font>T_CGateInv name ncf f<font color=Cyan>)</font> <font color=Red>=</font> f <font color=Cyan>$</font>
<a name="line-383"></a>  <font color=Red>\</font>result list <font color=Red>-&gt;</font> <font color=Green><u>do</u></font>
<a name="line-384"></a>   <font color=Green><u>let</u></font> result' <font color=Red>=</font> gateC name list
<a name="line-385"></a>   <font color=Green><u>if</u></font> result <font color=Cyan>==</font> result' <font color=Green><u>then</u></font> return list <font color=Green><u>else</u></font> error <font color=Magenta>"CGateInv: Uncomputation error"</font>
<a name="line-386"></a><font color=Blue><i>-- Translation of quantum gates:</i></font>
<a name="line-387"></a><font color=Blue>simulation_transformer</font> <font color=Cyan>(</font>T_QGate <font color=Magenta>"not"</font> <font color=Magenta>1</font> <font color=Magenta>0</font> <font color=Green><u>_</u></font> ncf f<font color=Cyan>)</font> <font color=Red>=</font> f <font color=Cyan>$</font>
<a name="line-388"></a>  <font color=Red>\</font><font color=Red>[</font>q<font color=Red>]</font> [] cs <font color=Red>-&gt;</font> <font color=Green><u>do</u></font>
<a name="line-389"></a>   <font color=Green><u>let</u></font> gate <font color=Red>=</font> gateQ <font color=Magenta>"x"</font>
<a name="line-390"></a>   state <font color=Red>&lt;-</font> get
<a name="line-391"></a>   <font color=Green><u>let</u></font> amps <font color=Red>=</font> quantum_state state
<a name="line-392"></a>   <font color=Green><u>let</u></font> amps' <font color=Red>=</font> apply <font color=Cyan>(</font>if_controls cs <font color=Cyan>(</font>performGateQ gate q<font color=Cyan>)</font><font color=Cyan>)</font> amps
<a name="line-393"></a>   put <font color=Cyan>(</font>state <font color=Cyan>{</font>quantum_state <font color=Red>=</font> amps'<font color=Cyan>}</font><font color=Cyan>)</font>
<a name="line-394"></a>   return <font color=Cyan>(</font><font color=Red>[</font>q<font color=Red>]</font><font color=Cyan>,</font> []<font color=Cyan>,</font> cs<font color=Cyan>)</font>
<a name="line-395"></a><font color=Blue>simulation_transformer</font> <font color=Cyan>(</font>T_QGate <font color=Magenta>"multinot"</font> <font color=Green><u>_</u></font> <font color=Magenta>0</font> <font color=Green><u>_</u></font> ncf f<font color=Cyan>)</font> <font color=Red>=</font> f <font color=Cyan>$</font>
<a name="line-396"></a>  <font color=Red>\</font>qs [] cs <font color=Red>-&gt;</font> <font color=Green><u>do</u></font>
<a name="line-397"></a>   <font color=Green><u>let</u></font> gate <font color=Red>=</font> gateQ <font color=Magenta>"x"</font>
<a name="line-398"></a>   state <font color=Red>&lt;-</font> get
<a name="line-399"></a>   <font color=Green><u>let</u></font> amps <font color=Red>=</font> quantum_state state
<a name="line-400"></a>   <font color=Green><u>let</u></font> amps' <font color=Red>=</font> foldr <font color=Cyan>(</font><font color=Red>\</font>q a <font color=Red>-&gt;</font> apply <font color=Cyan>(</font>if_controls cs <font color=Cyan>(</font>performGateQ gate q<font color=Cyan>)</font><font color=Cyan>)</font> a<font color=Cyan>)</font> amps qs
<a name="line-401"></a>   put <font color=Cyan>(</font>state <font color=Cyan>{</font>quantum_state <font color=Red>=</font> amps'<font color=Cyan>}</font><font color=Cyan>)</font>
<a name="line-402"></a>   return <font color=Cyan>(</font>qs<font color=Cyan>,</font> []<font color=Cyan>,</font> cs<font color=Cyan>)</font>
<a name="line-403"></a><font color=Blue>simulation_transformer</font> <font color=Cyan>(</font>T_QGate <font color=Magenta>"H"</font> <font color=Magenta>1</font> <font color=Magenta>0</font> <font color=Green><u>_</u></font> ncf f<font color=Cyan>)</font> <font color=Red>=</font> f <font color=Cyan>$</font>
<a name="line-404"></a>  <font color=Red>\</font><font color=Red>[</font>q<font color=Red>]</font> [] cs <font color=Red>-&gt;</font> <font color=Green><u>do</u></font>
<a name="line-405"></a>   <font color=Green><u>let</u></font> gate <font color=Red>=</font> gateQ <font color=Magenta>"hadamard"</font>
<a name="line-406"></a>   state <font color=Red>&lt;-</font> get
<a name="line-407"></a>   <font color=Green><u>let</u></font> amps <font color=Red>=</font> quantum_state state
<a name="line-408"></a>   <font color=Green><u>let</u></font> amps' <font color=Red>=</font> apply <font color=Cyan>(</font>if_controls cs <font color=Cyan>(</font>performGateQ gate q<font color=Cyan>)</font><font color=Cyan>)</font> amps
<a name="line-409"></a>   put <font color=Cyan>(</font>state <font color=Cyan>{</font>quantum_state <font color=Red>=</font> amps'<font color=Cyan>}</font><font color=Cyan>)</font>
<a name="line-410"></a>   return <font color=Cyan>(</font><font color=Red>[</font>q<font color=Red>]</font><font color=Cyan>,</font> []<font color=Cyan>,</font> cs<font color=Cyan>)</font>
<a name="line-411"></a><font color=Blue>simulation_transformer</font> <font color=Cyan>(</font>T_QGate <font color=Magenta>"swap"</font> <font color=Magenta>2</font> <font color=Magenta>0</font> <font color=Green><u>_</u></font> ncf f<font color=Cyan>)</font> <font color=Red>=</font> f <font color=Cyan>$</font>
<a name="line-412"></a>  <font color=Red>\</font><font color=Red>[</font>w<font color=Cyan>,</font> v<font color=Red>]</font> [] cs <font color=Red>-&gt;</font> <font color=Green><u>do</u></font>
<a name="line-413"></a>   <font color=Green><u>let</u></font> gate <font color=Red>=</font> gateQ <font color=Magenta>"x"</font>
<a name="line-414"></a>   state <font color=Red>&lt;-</font> get
<a name="line-415"></a>   <font color=Green><u>let</u></font> amps <font color=Red>=</font> quantum_state state
<a name="line-416"></a>   <font color=Green><u>let</u></font> amps' <font color=Red>=</font> apply <font color=Cyan>(</font>if_controls <font color=Cyan>(</font><font color=Cyan>(</font>Signed <font color=Cyan>(</font>Endpoint_Qubit w<font color=Cyan>)</font> True<font color=Cyan>)</font><font color=Red><b>:</b></font>cs<font color=Cyan>)</font> <font color=Cyan>(</font>performGateQ gate v<font color=Cyan>)</font><font color=Cyan>)</font> amps
<a name="line-417"></a>   <font color=Green><u>let</u></font> amps'' <font color=Red>=</font> apply <font color=Cyan>(</font>if_controls <font color=Cyan>(</font><font color=Cyan>(</font>Signed <font color=Cyan>(</font>Endpoint_Qubit v<font color=Cyan>)</font> True<font color=Cyan>)</font><font color=Red><b>:</b></font>cs<font color=Cyan>)</font> <font color=Cyan>(</font>performGateQ gate w<font color=Cyan>)</font><font color=Cyan>)</font> amps'
<a name="line-418"></a>   <font color=Green><u>let</u></font> amps''' <font color=Red>=</font> apply <font color=Cyan>(</font>if_controls <font color=Cyan>(</font><font color=Cyan>(</font>Signed <font color=Cyan>(</font>Endpoint_Qubit w<font color=Cyan>)</font> True<font color=Cyan>)</font><font color=Red><b>:</b></font>cs<font color=Cyan>)</font> <font color=Cyan>(</font>performGateQ gate v<font color=Cyan>)</font><font color=Cyan>)</font> amps''
<a name="line-419"></a>   put <font color=Cyan>(</font>state <font color=Cyan>{</font>quantum_state <font color=Red>=</font> amps'''<font color=Cyan>}</font><font color=Cyan>)</font>
<a name="line-420"></a>   return <font color=Cyan>(</font><font color=Red>[</font>w<font color=Cyan>,</font> v<font color=Red>]</font><font color=Cyan>,</font> []<font color=Cyan>,</font> cs<font color=Cyan>)</font>
<a name="line-421"></a><font color=Blue>simulation_transformer</font> <font color=Cyan>(</font>T_QGate <font color=Magenta>"W"</font> <font color=Magenta>2</font> <font color=Magenta>0</font> <font color=Green><u>_</u></font> ncf f<font color=Cyan>)</font> <font color=Red>=</font> f <font color=Cyan>$</font>
<a name="line-422"></a>  <font color=Red>\</font><font color=Red>[</font>w<font color=Cyan>,</font> v<font color=Red>]</font> [] cs <font color=Red>-&gt;</font> <font color=Green><u>do</u></font>
<a name="line-423"></a>   <font color=Green><u>let</u></font> gateX <font color=Red>=</font> gateQ <font color=Magenta>"x"</font>
<a name="line-424"></a>   <font color=Green><u>let</u></font> gateH <font color=Red>=</font> gateQ <font color=Magenta>"hadamard"</font>
<a name="line-425"></a>   state <font color=Red>&lt;-</font> get
<a name="line-426"></a>   <font color=Green><u>let</u></font> amps <font color=Red>=</font> quantum_state state
<a name="line-427"></a>   <font color=Green><u>let</u></font> amps' <font color=Red>=</font> apply <font color=Cyan>(</font>if_controls <font color=Cyan>(</font><font color=Cyan>(</font>Signed <font color=Cyan>(</font>Endpoint_Qubit w<font color=Cyan>)</font> True<font color=Cyan>)</font><font color=Red><b>:</b></font>cs<font color=Cyan>)</font> <font color=Cyan>(</font>performGateQ gateX v<font color=Cyan>)</font><font color=Cyan>)</font> amps
<a name="line-428"></a>   <font color=Green><u>let</u></font> amps'' <font color=Red>=</font> apply <font color=Cyan>(</font>if_controls <font color=Cyan>(</font><font color=Cyan>(</font>Signed <font color=Cyan>(</font>Endpoint_Qubit v<font color=Cyan>)</font> True<font color=Cyan>)</font><font color=Red><b>:</b></font>cs<font color=Cyan>)</font> <font color=Cyan>(</font>performGateQ gateH w<font color=Cyan>)</font><font color=Cyan>)</font> amps'
<a name="line-429"></a>   <font color=Green><u>let</u></font> amps''' <font color=Red>=</font> apply <font color=Cyan>(</font>if_controls <font color=Cyan>(</font><font color=Cyan>(</font>Signed <font color=Cyan>(</font>Endpoint_Qubit w<font color=Cyan>)</font> True<font color=Cyan>)</font><font color=Red><b>:</b></font>cs<font color=Cyan>)</font> <font color=Cyan>(</font>performGateQ gateX v<font color=Cyan>)</font><font color=Cyan>)</font> amps''
<a name="line-430"></a>   put <font color=Cyan>(</font>state <font color=Cyan>{</font>quantum_state <font color=Red>=</font> amps'''<font color=Cyan>}</font><font color=Cyan>)</font>
<a name="line-431"></a>   return <font color=Cyan>(</font><font color=Red>[</font>w<font color=Cyan>,</font> v<font color=Red>]</font><font color=Cyan>,</font> []<font color=Cyan>,</font> cs<font color=Cyan>)</font>
<a name="line-432"></a><font color=Blue>simulation_transformer</font> <font color=Cyan>(</font>T_QGate <font color=Magenta>"trace"</font> <font color=Green><u>_</u></font> <font color=Green><u>_</u></font> False ncf f<font color=Cyan>)</font> <font color=Red>=</font> f <font color=Cyan>$</font>
<a name="line-433"></a> <font color=Red>\</font>qs gc c <font color=Red>-&gt;</font> <font color=Green><u>do</u></font>
<a name="line-434"></a>  <font color=Blue><i>-- a \"trace\" gate adds the current probability distribution for the given qubits</i></font>
<a name="line-435"></a>  <font color=Blue><i>-- to the list of previous quantum traces</i></font>
<a name="line-436"></a>  state <font color=Red>&lt;-</font> get
<a name="line-437"></a>  <font color=Green><u>let</u></font> current_traces <font color=Red>=</font> traces state
<a name="line-438"></a>  <font color=Green><u>let</u></font> amps <font color=Red>=</font> quantum_state state
<a name="line-439"></a>  <font color=Green><u>let</u></font> new_trace <font color=Red>=</font> get_trace qs amps
<a name="line-440"></a>  put <font color=Cyan>(</font>state <font color=Cyan>{</font>traces <font color=Red>=</font> new_trace<font color=Red><b>:</b></font>current_traces<font color=Cyan>}</font><font color=Cyan>)</font>
<a name="line-441"></a>  return <font color=Cyan>(</font>qs<font color=Cyan>,</font>gc<font color=Cyan>,</font>c<font color=Cyan>)</font>
<a name="line-442"></a><font color=Blue>simulation_transformer</font> <font color=Cyan>(</font>T_QGate <font color=Magenta>"trace"</font> <font color=Green><u>_</u></font> <font color=Green><u>_</u></font> True ncf f<font color=Cyan>)</font> <font color=Red>=</font> f <font color=Cyan>$</font>
<a name="line-443"></a> <font color=Red>\</font>qs gc c <font color=Red>-&gt;</font> return <font color=Cyan>(</font>qs<font color=Cyan>,</font>gc<font color=Cyan>,</font>c<font color=Cyan>)</font> <font color=Blue><i>-- we don't do anything for the inverse \"trace\" gate</i></font>
<a name="line-444"></a><font color=Blue>simulation_transformer</font> <font color=Cyan>(</font>T_QGate name <font color=Magenta>1</font> <font color=Magenta>0</font> inv ncf f<font color=Cyan>)</font> <font color=Red>=</font> f <font color=Cyan>$</font> 
<a name="line-445"></a>  <font color=Red>\</font><font color=Red>[</font>q<font color=Red>]</font> [] c <font color=Red>-&gt;</font> <font color=Green><u>do</u></font>
<a name="line-446"></a>   <font color=Green><u>let</u></font> gate <font color=Red>=</font> gateQinv name inv
<a name="line-447"></a>   state <font color=Red>&lt;-</font> get
<a name="line-448"></a>   <font color=Green><u>let</u></font> amps <font color=Red>=</font> quantum_state state
<a name="line-449"></a>   <font color=Green><u>let</u></font> amps' <font color=Red>=</font> apply <font color=Cyan>(</font>if_controls c <font color=Cyan>(</font>performGateQ gate q<font color=Cyan>)</font><font color=Cyan>)</font> amps
<a name="line-450"></a>   put <font color=Cyan>(</font>state <font color=Cyan>{</font>quantum_state <font color=Red>=</font> amps'<font color=Cyan>}</font><font color=Cyan>)</font>
<a name="line-451"></a>   return <font color=Cyan>(</font><font color=Red>[</font>q<font color=Red>]</font><font color=Cyan>,</font>[]<font color=Cyan>,</font>c<font color=Cyan>)</font>
<a name="line-452"></a><font color=Blue>simulation_transformer</font> <font color=Cyan>(</font>T_QRot name <font color=Magenta>1</font> <font color=Magenta>0</font> inv theta ncf f<font color=Cyan>)</font> <font color=Red>=</font> f <font color=Cyan>$</font> 
<a name="line-453"></a>  <font color=Red>\</font><font color=Red>[</font>q<font color=Red>]</font> [] c <font color=Red>-&gt;</font> <font color=Green><u>do</u></font>
<a name="line-454"></a>   <font color=Green><u>let</u></font> gate <font color=Red>=</font> rotQinv name inv theta
<a name="line-455"></a>   state <font color=Red>&lt;-</font> get
<a name="line-456"></a>   <font color=Green><u>let</u></font> amps <font color=Red>=</font> quantum_state state
<a name="line-457"></a>   <font color=Green><u>let</u></font> amps' <font color=Red>=</font> apply <font color=Cyan>(</font>if_controls c <font color=Cyan>(</font>performGateQ gate q<font color=Cyan>)</font><font color=Cyan>)</font> amps
<a name="line-458"></a>   put <font color=Cyan>(</font>state <font color=Cyan>{</font>quantum_state <font color=Red>=</font> amps'<font color=Cyan>}</font><font color=Cyan>)</font>
<a name="line-459"></a>   return <font color=Cyan>(</font><font color=Red>[</font>q<font color=Red>]</font><font color=Cyan>,</font>[]<font color=Cyan>,</font>c<font color=Cyan>)</font>
<a name="line-460"></a><font color=Blue>simulation_transformer</font> <font color=Cyan>(</font>T_GPhase t ncf f<font color=Cyan>)</font> <font color=Red>=</font> f <font color=Cyan>$</font>
<a name="line-461"></a>  <font color=Red>\</font>w c <font color=Red>-&gt;</font> <font color=Green><u>do</u></font>
<a name="line-462"></a>  state <font color=Red>&lt;-</font> get
<a name="line-463"></a>  <font color=Green><u>let</u></font> gate <font color=Red>=</font> rotQ <font color=Magenta>"exp(% pi i)"</font> t
<a name="line-464"></a>  <font color=Green><u>let</u></font> wire <font color=Red>=</font> next_wire state
<a name="line-465"></a>  <font color=Green><u>let</u></font> q <font color=Red>=</font> qubit_of_wire wire
<a name="line-466"></a>  <font color=Green><u>let</u></font> amps <font color=Red>=</font> quantum_state state
<a name="line-467"></a>  <font color=Green><u>let</u></font> amps' <font color=Red>=</font> apply <font color=Cyan>(</font>vector <font color=Cyan>(</font>Map<font color=Cyan>.</font>insert q False<font color=Cyan>)</font><font color=Cyan>)</font> amps 
<a name="line-468"></a>  <font color=Green><u>let</u></font> amps'' <font color=Red>=</font> apply <font color=Cyan>(</font>if_controls c <font color=Cyan>(</font>performGateQ gate q<font color=Cyan>)</font><font color=Cyan>)</font> amps'
<a name="line-469"></a>  <font color=Green><u>let</u></font> <font color=Cyan>(</font>p<font color=Cyan>,</font>ift<font color=Cyan>,</font>iff<font color=Cyan>)</font> <font color=Red>=</font> split amps'' q
<a name="line-470"></a>  <font color=Cyan>(</font>val<font color=Cyan>,</font>ampsf<font color=Cyan>)</font> <font color=Red>&lt;-</font> lift <font color=Cyan>$</font> merge_with_result p ift iff 
<a name="line-471"></a>  <font color=Green><u>case</u></font> val <font color=Green><u>of</u></font>
<a name="line-472"></a>    False <font color=Red>-&gt;</font> <font color=Green><u>do</u></font>
<a name="line-473"></a>        <font color=Green><u>let</u></font> ampsf' <font color=Red>=</font> apply <font color=Cyan>(</font>vector <font color=Cyan>(</font>Map<font color=Cyan>.</font>delete q<font color=Cyan>)</font><font color=Cyan>)</font> ampsf 
<a name="line-474"></a>        put <font color=Cyan>(</font>state <font color=Cyan>{</font>quantum_state <font color=Red>=</font> ampsf'<font color=Cyan>}</font><font color=Cyan>)</font>
<a name="line-475"></a>        return c
<a name="line-476"></a>    <font color=Green><u>_</u></font> <font color=Red>-&gt;</font> error <font color=Magenta>"GPhase"</font>
<a name="line-477"></a><font color=Blue>simulation_transformer</font> <font color=Cyan>(</font>T_QInit val ncf f<font color=Cyan>)</font> <font color=Red>=</font> f <font color=Cyan>$</font>
<a name="line-478"></a>  <font color=Green><u>do</u></font>
<a name="line-479"></a>  state <font color=Red>&lt;-</font> get
<a name="line-480"></a>  <font color=Green><u>let</u></font> wire <font color=Red>=</font> next_wire state
<a name="line-481"></a>  <font color=Green><u>let</u></font> q <font color=Red>=</font> qubit_of_wire wire
<a name="line-482"></a>  <font color=Green><u>let</u></font> wire' <font color=Red>=</font> wire <font color=Cyan>+</font> <font color=Magenta>1</font>
<a name="line-483"></a>  <font color=Green><u>let</u></font> amps <font color=Red>=</font> quantum_state state
<a name="line-484"></a>  <font color=Green><u>let</u></font> amps' <font color=Red>=</font> apply <font color=Cyan>(</font>vector <font color=Cyan>(</font>Map<font color=Cyan>.</font>insert q val<font color=Cyan>)</font><font color=Cyan>)</font> amps 
<a name="line-485"></a>  put <font color=Cyan>(</font>state <font color=Cyan>{</font>quantum_state <font color=Red>=</font> amps'<font color=Cyan>,</font> next_wire <font color=Red>=</font> wire'<font color=Cyan>}</font><font color=Cyan>)</font>
<a name="line-486"></a>  return q
<a name="line-487"></a><font color=Blue>simulation_transformer</font> <font color=Cyan>(</font>T_QMeas f<font color=Cyan>)</font> <font color=Red>=</font> f <font color=Cyan>$</font>
<a name="line-488"></a>  <font color=Red>\</font>q <font color=Red>-&gt;</font> <font color=Green><u>do</u></font>
<a name="line-489"></a>  state <font color=Red>&lt;-</font> get
<a name="line-490"></a>  <font color=Green><u>let</u></font> amps <font color=Red>=</font> quantum_state state
<a name="line-491"></a>  <font color=Green><u>let</u></font> <font color=Cyan>(</font>p<font color=Cyan>,</font>ift<font color=Cyan>,</font>iff<font color=Cyan>)</font> <font color=Red>=</font> split amps q
<a name="line-492"></a>  <font color=Cyan>(</font>val<font color=Cyan>,</font>amps'<font color=Cyan>)</font> <font color=Red>&lt;-</font> lift <font color=Cyan>$</font> merge_with_result p ift iff
<a name="line-493"></a>  <font color=Green><u>let</u></font> amps'' <font color=Red>=</font> apply <font color=Cyan>(</font>vector <font color=Cyan>(</font>Map<font color=Cyan>.</font>delete q<font color=Cyan>)</font><font color=Cyan>)</font> amps' 
<a name="line-494"></a>  put <font color=Cyan>(</font>state <font color=Cyan>{</font>quantum_state <font color=Red>=</font> amps''<font color=Cyan>}</font><font color=Cyan>)</font>
<a name="line-495"></a>  return val
<a name="line-496"></a><font color=Blue>simulation_transformer</font> <font color=Cyan>(</font>T_QDiscard f<font color=Cyan>)</font> <font color=Red>=</font> f <font color=Cyan>$</font>
<a name="line-497"></a>  <font color=Red>\</font>q <font color=Red>-&gt;</font> <font color=Green><u>do</u></font>
<a name="line-498"></a>   <font color=Blue><i>-- a discard is essentially a measurement, with the result thrown away, so we</i></font>
<a name="line-499"></a>   <font color=Blue><i>-- do that here, as it will reduce the size of the quantum state we are</i></font>
<a name="line-500"></a>   <font color=Blue><i>-- simulating over.</i></font>
<a name="line-501"></a>  state <font color=Red>&lt;-</font> get
<a name="line-502"></a>  <font color=Green><u>let</u></font> <font color=Cyan>(</font>p<font color=Cyan>,</font>ift<font color=Cyan>,</font>iff<font color=Cyan>)</font> <font color=Red>=</font> split <font color=Cyan>(</font>quantum_state state<font color=Cyan>)</font> q
<a name="line-503"></a>  <font color=Cyan>(</font><font color=Green><u>_</u></font><font color=Cyan>,</font>amps<font color=Cyan>)</font> <font color=Red>&lt;-</font> lift <font color=Cyan>$</font> merge_with_result p ift iff
<a name="line-504"></a>  <font color=Green><u>let</u></font> amps' <font color=Red>=</font> apply <font color=Cyan>(</font>vector <font color=Cyan>(</font>Map<font color=Cyan>.</font>delete q<font color=Cyan>)</font><font color=Cyan>)</font> amps 
<a name="line-505"></a>  put <font color=Cyan>(</font>state <font color=Cyan>{</font>quantum_state <font color=Red>=</font> amps'<font color=Cyan>}</font><font color=Cyan>)</font>
<a name="line-506"></a>  return ()
<a name="line-507"></a><font color=Blue>simulation_transformer</font> <font color=Cyan>(</font>T_QTerm b ncf f<font color=Cyan>)</font> <font color=Red>=</font> f <font color=Cyan>$</font>
<a name="line-508"></a>  <font color=Red>\</font>q <font color=Red>-&gt;</font> <font color=Green><u>do</u></font>
<a name="line-509"></a>   <font color=Blue><i>-- with a real quantum computer, when we terminate a qubit with an</i></font>
<a name="line-510"></a>   <font color=Blue><i>-- assertion we have no way of actually checking the assertion. The</i></font>
<a name="line-511"></a>   <font color=Blue><i>-- best we can do is measure the qubit and then throw an error if</i></font>
<a name="line-512"></a>   <font color=Blue><i>-- the assertion is incorrect, which may only occur with a small</i></font>
<a name="line-513"></a>   <font color=Blue><i>-- probability. Here, we could split the quantum state and see if</i></font>
<a name="line-514"></a>   <font color=Blue><i>-- the qubit exists in the incorrect state with any non-zero</i></font>
<a name="line-515"></a>   <font color=Blue><i>-- probability, and throw an error. However, we don't do this</i></font>
<a name="line-516"></a>   <font color=Blue><i>-- because an error would sometimes be thrown due to rounding.</i></font>
<a name="line-517"></a>  state <font color=Red>&lt;-</font> get
<a name="line-518"></a>  <font color=Green><u>let</u></font> amps <font color=Red>=</font> quantum_state state
<a name="line-519"></a>  <font color=Green><u>let</u></font> <font color=Cyan>(</font>p<font color=Cyan>,</font>ift<font color=Cyan>,</font>iff<font color=Cyan>)</font> <font color=Red>=</font> split amps q
<a name="line-520"></a>  <font color=Cyan>(</font>val<font color=Cyan>,</font>amps'<font color=Cyan>)</font> <font color=Red>&lt;-</font> lift <font color=Cyan>$</font> merge_with_result p ift iff
<a name="line-521"></a>  <font color=Green><u>if</u></font> val <font color=Cyan>==</font> b <font color=Green><u>then</u></font> put <font color=Cyan>(</font>state <font color=Cyan>{</font>quantum_state <font color=Red>=</font> amps'<font color=Cyan>}</font><font color=Cyan>)</font> <font color=Green><u>else</u></font> error <font color=Magenta>"QTerm: Assertion doesn't hold"</font>
<a name="line-522"></a><font color=Blue>simulation_transformer</font> <font color=Cyan>(</font>T_Comment <font color=Magenta>""</font> inv f<font color=Cyan>)</font> <font color=Red>=</font> f <font color=Cyan>$</font>
<a name="line-523"></a>  <font color=Red>\</font><font color=Green><u>_</u></font> <font color=Red>-&gt;</font> return ()
<a name="line-524"></a>   <font color=Blue><i>-- e.g. a comment can be (the) empty (string) if it only contains labels</i></font>
<a name="line-525"></a><font color=Blue>simulation_transformer</font> <font color=Cyan>(</font>T_Comment name inv f<font color=Cyan>)</font> <font color=Red>=</font> f <font color=Cyan>$</font>
<a name="line-526"></a>  <font color=Red>\</font><font color=Green><u>_</u></font> <font color=Red>-&gt;</font> <font color=Green><u>do</u></font>
<a name="line-527"></a>   state <font color=Red>&lt;-</font> get
<a name="line-528"></a>   <font color=Blue><i>-- we don't need to do anything with a comment, but they can be useful</i></font>
<a name="line-529"></a>   <font color=Blue><i>-- to know where we are in the circuit, so we shall output a trace of</i></font>
<a name="line-530"></a>   <font color=Blue><i>-- the (non-empty) comments during a simulation. </i></font>
<a name="line-531"></a>   trace <font color=Cyan>(</font>trace_flag state<font color=Cyan>)</font> name <font color=Cyan>$</font> return ()
<a name="line-532"></a><font color=Blue><i>-- The remaining gates are not yet implemented:</i></font>
<a name="line-533"></a><font color=Blue>simulation_transformer</font> g<font color=Red>@</font><font color=Cyan>(</font>T_QGate <font color=Green><u>_</u></font> <font color=Green><u>_</u></font> <font color=Green><u>_</u></font> <font color=Green><u>_</u></font> <font color=Green><u>_</u></font> <font color=Green><u>_</u></font><font color=Cyan>)</font> <font color=Red>=</font>
<a name="line-534"></a>  error <font color=Cyan>(</font><font color=Magenta>"simulation_transformer: unimplemented gate: "</font> <font color=Cyan>++</font> show g<font color=Cyan>)</font>
<a name="line-535"></a><font color=Blue>simulation_transformer</font> g<font color=Red>@</font><font color=Cyan>(</font>T_QRot <font color=Green><u>_</u></font> <font color=Green><u>_</u></font> <font color=Green><u>_</u></font> <font color=Green><u>_</u></font> <font color=Green><u>_</u></font> <font color=Green><u>_</u></font> <font color=Green><u>_</u></font><font color=Cyan>)</font> <font color=Red>=</font>
<a name="line-536"></a>  error <font color=Cyan>(</font><font color=Magenta>"simulation_transformer: unimplemented gate: "</font> <font color=Cyan>++</font> show g<font color=Cyan>)</font>
<a name="line-537"></a><font color=Blue>simulation_transformer</font> g<font color=Red>@</font><font color=Cyan>(</font>T_CSwap <font color=Green><u>_</u></font> <font color=Green><u>_</u></font><font color=Cyan>)</font> <font color=Red>=</font>
<a name="line-538"></a>  error <font color=Cyan>(</font><font color=Magenta>"simulation_transformer: unimplemented gate: "</font> <font color=Cyan>++</font> show g<font color=Cyan>)</font>
<a name="line-539"></a><font color=Blue>simulation_transformer</font> g<font color=Red>@</font><font color=Cyan>(</font>T_QPrep ncf f<font color=Cyan>)</font> <font color=Red>=</font> f <font color=Cyan>$</font>
<a name="line-540"></a>  <font color=Red>\</font>val <font color=Red>-&gt;</font> <font color=Green><u>do</u></font>
<a name="line-541"></a>    state <font color=Red>&lt;-</font> get
<a name="line-542"></a>    <font color=Green><u>let</u></font> wire <font color=Red>=</font> next_wire state
<a name="line-543"></a>    <font color=Green><u>let</u></font> q <font color=Red>=</font> qubit_of_wire wire
<a name="line-544"></a>    <font color=Green><u>let</u></font> wire' <font color=Red>=</font> wire <font color=Cyan>+</font> <font color=Magenta>1</font>
<a name="line-545"></a>    <font color=Green><u>let</u></font> amps <font color=Red>=</font> quantum_state state
<a name="line-546"></a>    <font color=Green><u>let</u></font> amps' <font color=Red>=</font> apply <font color=Cyan>(</font>vector <font color=Cyan>(</font>Map<font color=Cyan>.</font>insert q val<font color=Cyan>)</font><font color=Cyan>)</font> amps 
<a name="line-547"></a>    put <font color=Cyan>(</font>state <font color=Cyan>{</font>quantum_state <font color=Red>=</font> amps'<font color=Cyan>,</font> next_wire <font color=Red>=</font> wire'<font color=Cyan>}</font><font color=Cyan>)</font>
<a name="line-548"></a>    return q
<a name="line-549"></a><font color=Blue>simulation_transformer</font> g<font color=Red>@</font><font color=Cyan>(</font>T_QUnprep ncf f<font color=Cyan>)</font> <font color=Red>=</font> f <font color=Cyan>$</font>
<a name="line-550"></a>  <font color=Red>\</font>q <font color=Red>-&gt;</font> <font color=Green><u>do</u></font>
<a name="line-551"></a>    state <font color=Red>&lt;-</font> get
<a name="line-552"></a>    <font color=Green><u>let</u></font> amps <font color=Red>=</font> quantum_state state
<a name="line-553"></a>    <font color=Green><u>let</u></font> <font color=Cyan>(</font>p<font color=Cyan>,</font>ift<font color=Cyan>,</font>iff<font color=Cyan>)</font> <font color=Red>=</font> split amps q
<a name="line-554"></a>    <font color=Cyan>(</font>val<font color=Cyan>,</font>amps'<font color=Cyan>)</font> <font color=Red>&lt;-</font> lift <font color=Cyan>$</font> merge_with_result p ift iff
<a name="line-555"></a>    put <font color=Cyan>(</font>state <font color=Cyan>{</font>quantum_state <font color=Red>=</font> amps'<font color=Cyan>}</font><font color=Cyan>)</font>
<a name="line-556"></a>    return val
<a name="line-557"></a><font color=Blue>simulation_transformer</font> g<font color=Red>@</font><font color=Cyan>(</font>T_Subroutine sub inv ncf scf ws_pat a1_pat vs_pat a2_pat rep f<font color=Cyan>)</font> <font color=Red>=</font> f <font color=Cyan>$</font>
<a name="line-558"></a> <font color=Red>\</font>ns in_values c <font color=Red>-&gt;</font> <font color=Green><u>do</u></font>
<a name="line-559"></a>    <font color=Green><u>case</u></font> Map<font color=Cyan>.</font>lookup sub ns <font color=Green><u>of</u></font>
<a name="line-560"></a>     Just <font color=Cyan>(</font>TypedSubroutine sub_ocirc <font color=Green><u>_</u></font> <font color=Green><u>_</u></font> <font color=Green><u>_</u></font><font color=Cyan>)</font> <font color=Red>-&gt;</font> <font color=Green><u>do</u></font>
<a name="line-561"></a>      <font color=Green><u>let</u></font> OCircuit <font color=Cyan>(</font>in_wires<font color=Cyan>,</font> sub_circ<font color=Cyan>,</font> out_wires<font color=Cyan>)</font> <font color=Red>=</font> <font color=Green><u>if</u></font> inv <font color=Green><u>then</u></font> reverse_ocircuit sub_ocirc <font color=Green><u>else</u></font> sub_ocirc
<a name="line-562"></a>      <font color=Green><u>let</u></font> in_bindings <font color=Red>=</font> bind_list in_wires in_values bindings_empty
<a name="line-563"></a>      <font color=Green><u>let</u></font> sub_bcirc <font color=Red>=</font> <font color=Cyan>(</font>sub_circ<font color=Cyan>,</font>ns<font color=Cyan>)</font>
<a name="line-564"></a>      out_bind <font color=Red>&lt;-</font> transform_bcircuit_rec simulation_transformer sub_bcirc in_bindings
<a name="line-565"></a>      return <font color=Cyan>(</font>unbind_list out_bind out_wires<font color=Cyan>,</font> c<font color=Cyan>)</font> 
<a name="line-566"></a>     Nothing <font color=Red>-&gt;</font> error <font color=Cyan>$</font> <font color=Magenta>"simulation_transformer: subroutine "</font> <font color=Cyan>++</font> show sub <font color=Cyan>++</font> <font color=Magenta>" not found (in "</font> <font color=Cyan>++</font> showNames ns <font color=Cyan>++</font> <font color=Magenta>")"</font>
<a name="line-567"></a>
<a name="line-568"></a><a name="simulation_dynamic_transformer"></a><font color=Blue><i>-- | The simulation_transformer is also Dynamic, as the simulated wire states</i></font>
<a name="line-569"></a><font color=Blue><i>-- can simply be used to perform dynamic liftings.</i></font>
<a name="line-570"></a><font color=Blue>simulation_dynamic_transformer</font> <font color=Red>::</font> <font color=Cyan>(</font>PMonad r m<font color=Cyan>,</font> Ord r<font color=Cyan>)</font> <font color=Red>=&gt;</font> DynamicTransformer <font color=Cyan>(</font>StateT <font color=Cyan>(</font>QuantumState r<font color=Cyan>)</font> m<font color=Cyan>)</font> Qubit Bool
<a name="line-571"></a><font color=Blue>simulation_dynamic_transformer</font> <font color=Red>=</font> DT <font color=Cyan>{</font>
<a name="line-572"></a>  transformer <font color=Red>=</font> simulation_transformer<font color=Cyan>,</font>
<a name="line-573"></a>  define_subroutine <font color=Red>=</font> <font color=Red>\</font>name subroutine <font color=Red>-&gt;</font> return ()<font color=Cyan>,</font>
<a name="line-574"></a>  lifting_function <font color=Red>=</font> return
<a name="line-575"></a>  <font color=Cyan>}</font> 
<a name="line-576"></a>
<a name="line-577"></a><a name="simulate_transform_unary"></a><font color=Blue><i>-- | Apply the 'dynamic_simulation_transformer' to a (unary) circuit generating </i></font>
<a name="line-578"></a><font color=Blue><i>-- function. </i></font>
<a name="line-579"></a><font color=Blue>simulate_transform_unary</font> <font color=Red>::</font> <font color=Cyan>(</font>PMonad r m<font color=Cyan>,</font> Ord r<font color=Cyan>)</font> <font color=Red>=&gt;</font> <font color=Cyan>(</font>QCData qa<font color=Cyan>,</font> QCData qb<font color=Cyan>,</font> QCData <font color=Cyan>(</font>QCType Bit Bit qb<font color=Cyan>)</font><font color=Cyan>,</font> QCType Bool Bool qb <font color=Red>~</font> QCType Bool Bool <font color=Cyan>(</font>QCType Bit Bit qb<font color=Cyan>)</font><font color=Cyan>)</font> <font color=Red>=&gt;</font> <font color=Cyan>(</font>qa <font color=Red>-&gt;</font> Circ qb<font color=Cyan>)</font>
<a name="line-580"></a>     <font color=Red>-&gt;</font> BType qa
<a name="line-581"></a>     <font color=Red>-&gt;</font> StateT <font color=Cyan>(</font>QuantumState r<font color=Cyan>)</font> m <font color=Cyan>(</font>QCType Qubit Bool <font color=Cyan>(</font>QCType Bit Bit qb<font color=Cyan>)</font><font color=Cyan>)</font>
<a name="line-582"></a><font color=Blue>simulate_transform_unary</font> <font color=Cyan>(</font>f <font color=Red>::</font> qa <font color=Red>-&gt;</font> Circ qb<font color=Cyan>)</font> input <font color=Red>=</font> <font color=Green><u>do</u></font>
<a name="line-583"></a>  <font color=Green><u>let</u></font> <font color=Cyan>(</font>()<font color=Cyan>,</font> circuit<font color=Cyan>)</font> <font color=Red>=</font> encapsulate_dynamic <font color=Cyan>(</font><font color=Red>\</font>() <font color=Red>-&gt;</font> qc_init input <font color=Cyan>&gt;&gt;=</font> <font color=Red>\</font>qi <font color=Red>-&gt;</font> f qi <font color=Cyan>&gt;&gt;=</font> <font color=Red>\</font>qi' <font color=Red>-&gt;</font> qc_measure qi'<font color=Cyan>)</font> ()
<a name="line-584"></a>  <font color=Cyan>(</font>cb<font color=Cyan>,</font>out_bind<font color=Cyan>)</font> <font color=Red>&lt;-</font> transform_dbcircuit simulation_dynamic_transformer circuit bindings_empty
<a name="line-585"></a>  <font color=Green><u>let</u></font> output <font color=Red>=</font> qc_unbind out_bind cb
<a name="line-586"></a>  return output
<a name="line-587"></a>
<a name="line-588"></a><a name="qdata_concrete_shape"></a><font color=Blue><i>-- | In order to simulate a circuit using an input basis vector, we need to supply</i></font>
<a name="line-589"></a><font color=Blue><i>-- each quantum leaf, with a concrete (i.e., not a dummy) qubit.</i></font>
<a name="line-590"></a><font color=Blue>qdata_concrete_shape</font> <font color=Red>::</font> <font color=Cyan>(</font>QData qa<font color=Cyan>)</font> <font color=Red>=&gt;</font> BType qa <font color=Red>-&gt;</font> qa
<a name="line-591"></a><font color=Blue>qdata_concrete_shape</font> ba <font color=Red>=</font> evalState mqa <font color=Magenta>0</font>
<a name="line-592"></a> <font color=Green><u>where</u></font>
<a name="line-593"></a>   shape <font color=Red>=</font> shapetype_b ba
<a name="line-594"></a>   mqa <font color=Red>=</font> qdata_mapM shape f ba
<a name="line-595"></a>   f <font color=Red>::</font> Bool <font color=Red>-&gt;</font> State Wire Qubit
<a name="line-596"></a>   f <font color=Green><u>_</u></font> <font color=Red>=</font>  <font color=Green><u>do</u></font>
<a name="line-597"></a>    w <font color=Red>&lt;-</font> get
<a name="line-598"></a>    put <font color=Cyan>(</font>w<font color=Cyan>+</font><font color=Magenta>1</font><font color=Cyan>)</font>
<a name="line-599"></a>    return <font color=Cyan>(</font>qubit_of_wire w<font color=Cyan>)</font>
<a name="line-600"></a>
<a name="line-601"></a><a name="qdata_concrete_bindings"></a><font color=Blue><i>-- | In order to simulate a circuit using an input basis vector, we need to supply</i></font>
<a name="line-602"></a><font color=Blue><i>-- the transformer with a concrete set of qubit bindings.</i></font>
<a name="line-603"></a><font color=Blue>qdata_concrete_bindings</font> <font color=Red>::</font> <font color=Cyan>(</font>QData qa<font color=Cyan>)</font> <font color=Red>=&gt;</font> BType qa <font color=Red>-&gt;</font> Bindings Qubit Bool
<a name="line-604"></a><font color=Blue>qdata_concrete_bindings</font> ba <font color=Red>=</font> snd <font color=Cyan>$</font> execState mqa <font color=Cyan>(</font><font color=Magenta>0</font><font color=Cyan>,</font>bindings_empty<font color=Cyan>)</font>
<a name="line-605"></a> <font color=Green><u>where</u></font>
<a name="line-606"></a>   shape <font color=Red>=</font> shapetype_b ba
<a name="line-607"></a>   mqa <font color=Red>=</font> qdata_mapM shape f ba
<a name="line-608"></a>   f <font color=Red>::</font> Bool <font color=Red>-&gt;</font> State <font color=Cyan>(</font>Wire<font color=Cyan>,</font>Bindings Qubit Bool<font color=Cyan>)</font> ()
<a name="line-609"></a>   f b <font color=Red>=</font>  <font color=Green><u>do</u></font>
<a name="line-610"></a>    <font color=Cyan>(</font>w<font color=Cyan>,</font>bindings<font color=Cyan>)</font> <font color=Red>&lt;-</font> get
<a name="line-611"></a>    put <font color=Cyan>(</font>w<font color=Cyan>+</font><font color=Magenta>1</font><font color=Cyan>,</font>bind_qubit_wire w <font color=Cyan>(</font>qubit_of_wire w<font color=Cyan>)</font> bindings<font color=Cyan>)</font>
<a name="line-612"></a>    return () 
<a name="line-613"></a>
<a name="line-614"></a><a name="qdata_to_basis"></a><font color=Blue><i>-- | As a helper function, in order to simulate a circuit using an input basis vector, </i></font>
<a name="line-615"></a><font color=Blue><i>-- we need to be able to convert each basis into a map from concrete qubits to their</i></font>
<a name="line-616"></a><font color=Blue><i>-- value in the given basis.</i></font>
<a name="line-617"></a><font color=Blue>qdata_to_basis</font> <font color=Red>::</font> <font color=Cyan>(</font>QData qa<font color=Cyan>)</font> <font color=Red>=&gt;</font> BType qa <font color=Red>-&gt;</font> Map Qubit Bool
<a name="line-618"></a><font color=Blue>qdata_to_basis</font> ba <font color=Red>=</font> snd <font color=Cyan>$</font> execState mqa <font color=Cyan>(</font><font color=Magenta>0</font><font color=Cyan>,</font>Map<font color=Cyan>.</font>empty<font color=Cyan>)</font>
<a name="line-619"></a> <font color=Green><u>where</u></font>
<a name="line-620"></a>   shape <font color=Red>=</font> shapetype_b ba
<a name="line-621"></a>   mqa <font color=Red>=</font> qdata_mapM shape f ba
<a name="line-622"></a>   f <font color=Red>::</font> Bool <font color=Red>-&gt;</font> State <font color=Cyan>(</font>Wire<font color=Cyan>,</font>Map Qubit Bool<font color=Cyan>)</font> ()
<a name="line-623"></a>   f b <font color=Red>=</font>  <font color=Green><u>do</u></font>
<a name="line-624"></a>    <font color=Cyan>(</font>w<font color=Cyan>,</font>m<font color=Cyan>)</font> <font color=Red>&lt;-</font> get
<a name="line-625"></a>    put <font color=Cyan>(</font>w<font color=Cyan>+</font><font color=Magenta>1</font><font color=Cyan>,</font>Map<font color=Cyan>.</font>insert <font color=Cyan>(</font>qubit_of_wire w<font color=Cyan>)</font> b m<font color=Cyan>)</font>
<a name="line-626"></a>    return ()
<a name="line-627"></a>
<a name="line-628"></a><a name="qdata_vector_to_amplitudes"></a><font color=Blue><i>-- | In order to simulate a circuit using an input basis vector, we need to be able</i></font>
<a name="line-629"></a><font color=Blue><i>-- to convert the basis vector into a quantum state suitable for use by the simulator</i></font>
<a name="line-630"></a><font color=Blue><i>-- i.e. of type Amplitudes.</i></font>
<a name="line-631"></a><font color=Blue>qdata_vector_to_amplitudes</font> <font color=Red>::</font> <font color=Cyan>(</font>QData qa<font color=Cyan>,</font> Floating r<font color=Cyan>)</font> <font color=Red>=&gt;</font> Vector <font color=Cyan>(</font>Cplx r<font color=Cyan>)</font> <font color=Cyan>(</font>BType qa<font color=Cyan>)</font> <font color=Red>-&gt;</font> Amplitudes r
<a name="line-632"></a><font color=Blue>qdata_vector_to_amplitudes</font> <font color=Cyan>(</font>Vector das<font color=Cyan>)</font> <font color=Red>=</font> <font color=Cyan>(</font>Vector <font color=Cyan>(</font>map <font color=Cyan>(</font><font color=Red>\</font><font color=Cyan>(</font>a<font color=Cyan>,</font>d<font color=Cyan>)</font> <font color=Red>-&gt;</font> <font color=Cyan>(</font>qdata_to_basis a<font color=Cyan>,</font>d<font color=Cyan>)</font><font color=Cyan>)</font> das<font color=Cyan>)</font><font color=Cyan>)</font>
<a name="line-633"></a>
<a name="line-634"></a><a name="basis_to_qdata"></a><font color=Blue><i>-- | As a helper function, in order to simulate a circuit using an input basis vector, </i></font>
<a name="line-635"></a><font color=Blue><i>-- we need to be able to convert a map from concrete qubits to their value into a basis</i></font>
<a name="line-636"></a><font color=Blue><i>-- of the given concrete shape.</i></font>
<a name="line-637"></a><font color=Blue>basis_to_qdata</font> <font color=Red>::</font> <font color=Cyan>(</font>QData qa<font color=Cyan>)</font> <font color=Red>=&gt;</font> qa <font color=Red>-&gt;</font> Map Qubit Bool <font color=Red>-&gt;</font> BType qa
<a name="line-638"></a><font color=Blue>basis_to_qdata</font> qa m <font color=Red>=</font> getId <font color=Cyan>$</font> qdata_mapM qa f qa
<a name="line-639"></a> <font color=Green><u>where</u></font>
<a name="line-640"></a>  f <font color=Red>::</font> Qubit <font color=Red>-&gt;</font> Id Bool
<a name="line-641"></a>  f q <font color=Red>=</font> <font color=Green><u>case</u></font> Map<font color=Cyan>.</font>lookup q m <font color=Green><u>of</u></font>
<a name="line-642"></a>         Just res <font color=Red>-&gt;</font> return res
<a name="line-643"></a>         <font color=Green><u>_</u></font> <font color=Red>-&gt;</font> error <font color=Magenta>"basis_to_qdata: qubit not in scope"</font>
<a name="line-644"></a>
<a name="line-645"></a><a name="amplitudes_to_qdata_vector"></a><font color=Blue><i>-- | In order to simulate a circuit using an input basis vector, we need to be able</i></font>
<a name="line-646"></a><font color=Blue><i>-- to convert the quantum state (i.e. of type Amplitudes) into a basis vector.</i></font>
<a name="line-647"></a><font color=Blue>amplitudes_to_qdata_vector</font> <font color=Red>::</font> <font color=Cyan>(</font>QData qa<font color=Cyan>,</font> Floating r<font color=Cyan>)</font> <font color=Red>=&gt;</font> qa <font color=Red>-&gt;</font> Amplitudes r <font color=Red>-&gt;</font> Vector <font color=Cyan>(</font>Cplx r<font color=Cyan>)</font> <font color=Cyan>(</font>BType qa<font color=Cyan>)</font>
<a name="line-648"></a><font color=Blue>amplitudes_to_qdata_vector</font> qa <font color=Cyan>(</font>Vector das<font color=Cyan>)</font> <font color=Red>=</font> Vector <font color=Cyan>(</font>map <font color=Cyan>(</font><font color=Red>\</font><font color=Cyan>(</font>a<font color=Cyan>,</font>d<font color=Cyan>)</font> <font color=Red>-&gt;</font> <font color=Cyan>(</font>basis_to_qdata qa a<font color=Cyan>,</font>d<font color=Cyan>)</font><font color=Cyan>)</font> das<font color=Cyan>)</font>
<a name="line-649"></a>
<a name="line-650"></a><a name="simulate_amplitudes_unary"></a><font color=Blue><i>-- | Apply the 'dynamic_simulation_transformer' to a (unary) circuit generating</i></font>
<a name="line-651"></a><font color=Blue><i>-- function, starting with the quantum state set to the given vector of base states </i></font>
<a name="line-652"></a><font color=Blue><i>-- and returning the resulting vector of base states.</i></font>
<a name="line-653"></a><font color=Blue>simulate_amplitudes_unary</font> <font color=Red>::</font> <font color=Cyan>(</font>PMonad r m<font color=Cyan>,</font> Eq r<font color=Cyan>,</font> Ord r<font color=Cyan>,</font> QData qa<font color=Cyan>,</font> QData qb<font color=Cyan>,</font> qb <font color=Red>~</font> QCType Qubit Bool qb<font color=Cyan>)</font> <font color=Red>=&gt;</font> <font color=Cyan>(</font>qa <font color=Red>-&gt;</font> Circ qb<font color=Cyan>)</font> <font color=Red>-&gt;</font> Vector <font color=Cyan>(</font>Cplx r<font color=Cyan>)</font> <font color=Cyan>(</font>BType qa<font color=Cyan>)</font> <font color=Red>-&gt;</font> m <font color=Cyan>(</font>Vector <font color=Cyan>(</font>Cplx r<font color=Cyan>)</font> <font color=Cyan>(</font>BType qb<font color=Cyan>)</font><font color=Cyan>)</font>
<a name="line-654"></a><font color=Blue>simulate_amplitudes_unary</font> f input<font color=Red>@</font><font color=Cyan>(</font>Vector is<font color=Cyan>)</font> <font color=Red>=</font> <font color=Green><u>do</u></font>
<a name="line-655"></a>  <font color=Cyan>(</font>out_shape<font color=Cyan>,</font>state<font color=Cyan>)</font> <font color=Red>&lt;-</font> runStateT circ input_state
<a name="line-656"></a>  <font color=Green><u>let</u></font> out_amps <font color=Red>=</font> quantum_state state 
<a name="line-657"></a>  return <font color=Cyan>(</font>amplitudes_to_qdata_vector out_shape <font color=Cyan>(</font>apply <font color=Cyan>(</font>vector id<font color=Cyan>)</font> out_amps<font color=Cyan>)</font><font color=Cyan>)</font>
<a name="line-658"></a> <font color=Green><u>where</u></font>
<a name="line-659"></a>  amps <font color=Red>=</font> qdata_vector_to_amplitudes input
<a name="line-660"></a>  specimen <font color=Red>=</font> <font color=Green><u>case</u></font> is <font color=Green><u>of</u></font>
<a name="line-661"></a>              [] <font color=Red>-&gt;</font> error <font color=Magenta>"simulate_amplitudes_unary: can't use empty vector"</font>
<a name="line-662"></a>              <font color=Cyan>(</font><font color=Cyan>(</font>b<font color=Cyan>,</font><font color=Green><u>_</u></font><font color=Cyan>)</font><font color=Red><b>:</b></font><font color=Green><u>_</u></font><font color=Cyan>)</font> <font color=Red>-&gt;</font> b
<a name="line-663"></a>  shape <font color=Red>=</font> qdata_concrete_shape specimen
<a name="line-664"></a>  bindings <font color=Red>=</font> qdata_concrete_bindings specimen
<a name="line-665"></a>  max_wire <font color=Red>=</font> <font color=Green><u>case</u></font> wires_of_bindings bindings <font color=Green><u>of</u></font>
<a name="line-666"></a>              [] <font color=Red>-&gt;</font> <font color=Magenta>0</font>
<a name="line-667"></a>              ws <font color=Red>-&gt;</font> maximum ws 
<a name="line-668"></a>  input_state <font color=Red>=</font> <font color=Cyan>(</font>empty_quantum_state False undefined<font color=Cyan>)</font> <font color=Cyan>{</font>quantum_state <font color=Red>=</font> amps<font color=Cyan>,</font> next_wire <font color=Red>=</font> max_wire <font color=Cyan>+</font> <font color=Magenta>1</font><font color=Cyan>}</font>
<a name="line-669"></a>  <font color=Cyan>(</font><font color=Green><u>_</u></font><font color=Cyan>,</font>circuit<font color=Cyan>)</font> <font color=Red>=</font> encapsulate_dynamic f shape
<a name="line-670"></a>  circ <font color=Red>=</font> <font color=Green><u>do</u></font>
<a name="line-671"></a>   <font color=Cyan>(</font>cb<font color=Cyan>,</font>out_bind<font color=Cyan>)</font> <font color=Red>&lt;-</font> transform_dbcircuit simulation_dynamic_transformer circuit bindings
<a name="line-672"></a>   <font color=Green><u>let</u></font> output <font color=Red>=</font> qc_unbind out_bind cb
<a name="line-673"></a>   return output
<a name="line-674"></a>
<a name="line-675"></a><a name="sim_amps"></a><font color=Blue><i>-- | Input a source of randomness, a quantum circuit, and an initial</i></font>
<a name="line-676"></a><font color=Blue><i>-- state (represented as a map from basis vectors to amplitudes).</i></font>
<a name="line-677"></a><font color=Blue><i>-- Simulate the circuit and return the final state. If the circuit</i></font>
<a name="line-678"></a><font color=Blue><i>-- includes measurements, the simulation will be probabilistic.</i></font>
<a name="line-679"></a><font color=Blue><i>-- </i></font>
<a name="line-680"></a><font color=Blue><i>-- The type of this heavily overloaded function is difficult to</i></font>
<a name="line-681"></a><font color=Blue><i>-- read. It has, for example, the following types:</i></font>
<a name="line-682"></a><font color=Blue><i>-- </i></font>
<a name="line-683"></a><font color=Blue><i>-- &gt; sim_amps :: StdGen -&gt; (Qubit -&gt; Circ Qubit) -&gt; Map Bool (Cplx Double) -&gt; Map Bool (Cplx Double)</i></font>
<a name="line-684"></a><font color=Blue><i>-- &gt; sim_amps :: StdGen -&gt; ((Qubit,Qubit) -&gt; Circ Qubit) -&gt; Map (Bool,Bool) (Cplx Double) -&gt; Map Bool (Cplx Double)</i></font>
<a name="line-685"></a><font color=Blue><i>-- </i></font>
<a name="line-686"></a><font color=Blue><i>-- and so forth. Note that instead of 'Double', another real number</i></font>
<a name="line-687"></a><font color=Blue><i>-- type, such as 'FixedPrec' /e/, can be used.</i></font>
<a name="line-688"></a><font color=Blue>sim_amps</font> <font color=Red>::</font> <font color=Cyan>(</font>RandomGen g<font color=Cyan>,</font> Floating r<font color=Cyan>,</font> Random r<font color=Cyan>,</font> Ord r<font color=Cyan>,</font> QData qa<font color=Cyan>,</font> QData qb<font color=Cyan>,</font> qb <font color=Red>~</font> QCType Qubit Bool qb<font color=Cyan>,</font> Ord <font color=Cyan>(</font>BType qb<font color=Cyan>)</font><font color=Cyan>)</font> <font color=Red>=&gt;</font> g <font color=Red>-&gt;</font> <font color=Cyan>(</font>qa <font color=Red>-&gt;</font> Circ qb<font color=Cyan>)</font> <font color=Red>-&gt;</font> Map <font color=Cyan>(</font>BType qa<font color=Cyan>)</font> <font color=Cyan>(</font>Cplx r<font color=Cyan>)</font> <font color=Red>-&gt;</font> Map <font color=Cyan>(</font>BType qb<font color=Cyan>)</font> <font color=Cyan>(</font>Cplx r<font color=Cyan>)</font>
<a name="line-689"></a><font color=Blue>sim_amps</font> gen f input_map <font color=Red>=</font> output_map
<a name="line-690"></a> <font color=Green><u>where</u></font>
<a name="line-691"></a>  input_vec <font color=Red>=</font> Vector <font color=Cyan>(</font>Map<font color=Cyan>.</font>toList input_map<font color=Cyan>)</font>
<a name="line-692"></a>  circ <font color=Red>=</font> simulate_amplitudes_unary f input_vec
<a name="line-693"></a>  Vector output <font color=Red>=</font> evalState circ gen
<a name="line-694"></a>  output_map <font color=Red>=</font> Map<font color=Cyan>.</font>fromList output
<a name="line-695"></a>
<a name="line-696"></a><a name="run_unary"></a><font color=Blue><i>-- | Input a source of randomness, a real number, a circuit, and a</i></font>
<a name="line-697"></a><font color=Blue><i>-- basis state. Then simulate the circuit probabilistically. Measure</i></font>
<a name="line-698"></a><font color=Blue><i>-- the final state and return the resulting basis vector.</i></font>
<a name="line-699"></a><font color=Blue><i>-- </i></font>
<a name="line-700"></a><font color=Blue><i>-- The real number argument is a dummy and is never evaluated; its</i></font>
<a name="line-701"></a><font color=Blue><i>-- only purpose is to specify the /type/ of real numbers that will be</i></font>
<a name="line-702"></a><font color=Blue><i>-- used during the simulation.</i></font>
<a name="line-703"></a><font color=Blue>run_unary</font> <font color=Red>::</font> <font color=Cyan>(</font>Floating r<font color=Cyan>,</font> Random r<font color=Cyan>,</font> Ord r<font color=Cyan>,</font> RandomGen g<font color=Cyan>,</font> QCData qa<font color=Cyan>,</font> QCData qb<font color=Cyan>,</font> QCData <font color=Cyan>(</font>QCType Bit Bit qb<font color=Cyan>)</font><font color=Cyan>,</font> QCType Bool Bool qb <font color=Red>~</font> QCType Bool Bool <font color=Cyan>(</font>QCType Bit Bit qb<font color=Cyan>)</font><font color=Cyan>)</font> <font color=Red>=&gt;</font> g <font color=Red>-&gt;</font> r <font color=Red>-&gt;</font>
<a name="line-704"></a>     <font color=Cyan>(</font>qa <font color=Red>-&gt;</font> Circ qb<font color=Cyan>)</font>
<a name="line-705"></a>     <font color=Red>-&gt;</font> BType qa
<a name="line-706"></a>     <font color=Red>-&gt;</font> QCType Qubit Bool <font color=Cyan>(</font>QCType Bit Bit qb<font color=Cyan>)</font>
<a name="line-707"></a><font color=Blue>run_unary</font> g r f input <font color=Red>=</font> evalState comp g <font color=Green><u>where</u></font>
<a name="line-708"></a>  comp <font color=Red>=</font> evalStateT f' <font color=Cyan>(</font>empty_quantum_state False r<font color=Cyan>)</font>
<a name="line-709"></a>  f' <font color=Red>=</font> simulate_transform_unary f input
<a name="line-710"></a>
<a name="line-711"></a><a name="run_unary_trace"></a><font color=Blue><i>-- | Like 'run_unary', but return the list of 'QuantumTrace' elements</i></font>
<a name="line-712"></a><font color=Blue><i>-- that were generated during the computation. This is useful for</i></font>
<a name="line-713"></a><font color=Blue><i>-- checking the intermediary state of qubits within a computation.</i></font>
<a name="line-714"></a><font color=Blue>run_unary_trace</font> <font color=Red>::</font> <font color=Cyan>(</font>Floating r<font color=Cyan>,</font> Random r<font color=Cyan>,</font> Ord r<font color=Cyan>,</font> RandomGen g<font color=Cyan>,</font> QCData qa<font color=Cyan>,</font> QCData qb<font color=Cyan>,</font> QCData <font color=Cyan>(</font>QCType Bit Bit qb<font color=Cyan>)</font><font color=Cyan>,</font> QCType Bool Bool qb <font color=Red>~</font> QCType Bool Bool <font color=Cyan>(</font>QCType Bit Bit qb<font color=Cyan>)</font><font color=Cyan>)</font> <font color=Red>=&gt;</font> g <font color=Red>-&gt;</font> r <font color=Red>-&gt;</font>
<a name="line-715"></a>     <font color=Cyan>(</font>qa <font color=Red>-&gt;</font> Circ qb<font color=Cyan>)</font>
<a name="line-716"></a>     <font color=Red>-&gt;</font> BType qa
<a name="line-717"></a>     <font color=Red>-&gt;</font> <font color=Red>[</font>QuantumTrace r<font color=Red>]</font>
<a name="line-718"></a><font color=Blue>run_unary_trace</font> g r f input <font color=Red>=</font> evalState comp g <font color=Green><u>where</u></font>
<a name="line-719"></a>  comp <font color=Red>=</font> <font color=Green><u>do</u></font>
<a name="line-720"></a>    state <font color=Red>&lt;-</font> execStateT f' <font color=Cyan>(</font>empty_quantum_state True r<font color=Cyan>)</font>
<a name="line-721"></a>    <font color=Green><u>let</u></font> qts <font color=Red>=</font> traces state
<a name="line-722"></a>    return <font color=Cyan>(</font>reverse qts<font color=Cyan>)</font>
<a name="line-723"></a>  f' <font color=Red>=</font> simulate_transform_unary f input
<a name="line-724"></a>
<a name="line-725"></a><a name="run_unary_io"></a><font color=Blue><i>-- | Like 'run_unary', but run in the 'IO' monad instead of passing an</i></font>
<a name="line-726"></a><font color=Blue><i>-- explicit source of randomness.</i></font>
<a name="line-727"></a><font color=Blue>run_unary_io</font> <font color=Red>::</font> <font color=Cyan>(</font>Floating r<font color=Cyan>,</font> Random r<font color=Cyan>,</font> Ord r<font color=Cyan>,</font> QCData qa<font color=Cyan>,</font> QCData qb<font color=Cyan>,</font> QCData <font color=Cyan>(</font>QCType Bit Bit qb<font color=Cyan>)</font><font color=Cyan>,</font> QCType Bool Bool qb <font color=Red>~</font> QCType Bool Bool <font color=Cyan>(</font>QCType Bit Bit qb<font color=Cyan>)</font><font color=Cyan>)</font> <font color=Red>=&gt;</font> r <font color=Red>-&gt;</font>
<a name="line-728"></a>     <font color=Cyan>(</font>qa <font color=Red>-&gt;</font> Circ qb<font color=Cyan>)</font>
<a name="line-729"></a>     <font color=Red>-&gt;</font> BType qa
<a name="line-730"></a>     <font color=Red>-&gt;</font> IO <font color=Cyan>(</font>QCType Qubit Bool <font color=Cyan>(</font>QCType Bit Bit qb<font color=Cyan>)</font><font color=Cyan>)</font>
<a name="line-731"></a><font color=Blue>run_unary_io</font> r f input <font color=Red>=</font> <font color=Green><u>do</u></font>
<a name="line-732"></a>  g <font color=Red>&lt;-</font> newStdGen
<a name="line-733"></a>  return <font color=Cyan>(</font>run_unary g r f input<font color=Cyan>)</font>
<a name="line-734"></a>
<a name="line-735"></a><a name="run_unary_trace_io"></a><font color=Blue><i>-- | Like 'run_unary_trace', but run in the 'IO' monad instead of</i></font>
<a name="line-736"></a><font color=Blue><i>-- passing an explicit source of randomness.</i></font>
<a name="line-737"></a><font color=Blue>run_unary_trace_io</font> <font color=Red>::</font> <font color=Cyan>(</font>Floating r<font color=Cyan>,</font> Random r<font color=Cyan>,</font> Ord r<font color=Cyan>,</font> QCData qa<font color=Cyan>,</font> QCData qb<font color=Cyan>,</font> QCData <font color=Cyan>(</font>QCType Bit Bit qb<font color=Cyan>)</font><font color=Cyan>,</font> QCType Bool Bool qb <font color=Red>~</font> QCType Bool Bool <font color=Cyan>(</font>QCType Bit Bit qb<font color=Cyan>)</font><font color=Cyan>)</font> <font color=Red>=&gt;</font> r <font color=Red>-&gt;</font>
<a name="line-738"></a>     <font color=Cyan>(</font>qa <font color=Red>-&gt;</font> Circ qb<font color=Cyan>)</font>
<a name="line-739"></a>     <font color=Red>-&gt;</font> BType qa
<a name="line-740"></a>     <font color=Red>-&gt;</font> IO <font color=Red>[</font>QuantumTrace r<font color=Red>]</font>
<a name="line-741"></a><font color=Blue>run_unary_trace_io</font> r f input <font color=Red>=</font> <font color=Green><u>do</u></font>
<a name="line-742"></a>  g <font color=Red>&lt;-</font> newStdGen
<a name="line-743"></a>  return <font color=Cyan>(</font>run_unary_trace g r f input<font color=Cyan>)</font>
<a name="line-744"></a>
<a name="line-745"></a><a name="sim_unary"></a><font color=Blue><i>-- | Apply the 'simulation_transformer' to a (unary) circuit, and then evaluate</i></font>
<a name="line-746"></a><font color=Blue><i>-- the resulting stateful computation to get a probability distribution of possible</i></font>
<a name="line-747"></a><font color=Blue><i>-- results</i></font>
<a name="line-748"></a><font color=Blue>sim_unary</font> <font color=Red>::</font> <font color=Cyan>(</font>Floating r<font color=Cyan>,</font> Ord r<font color=Cyan>,</font> QCData qa<font color=Cyan>,</font> QCData qb<font color=Cyan>,</font> QCData <font color=Cyan>(</font>QCType Bit Bit qb<font color=Cyan>)</font><font color=Cyan>,</font> QCType Bool Bool qb <font color=Red>~</font> QCType Bool Bool <font color=Cyan>(</font>QCType Bit Bit qb<font color=Cyan>)</font><font color=Cyan>)</font> <font color=Red>=&gt;</font> r <font color=Red>-&gt;</font>
<a name="line-749"></a>     <font color=Cyan>(</font>qa <font color=Red>-&gt;</font> Circ qb<font color=Cyan>)</font>
<a name="line-750"></a>     <font color=Red>-&gt;</font> BType qa
<a name="line-751"></a>     <font color=Red>-&gt;</font> ProbabilityDistribution r <font color=Cyan>(</font>QCType Qubit Bool <font color=Cyan>(</font>QCType Bit Bit qb<font color=Cyan>)</font><font color=Cyan>)</font>
<a name="line-752"></a><font color=Blue>sim_unary</font> r f input <font color=Red>=</font> evalStateT f' <font color=Cyan>(</font>empty_quantum_state False r<font color=Cyan>)</font>
<a name="line-753"></a>  <font color=Green><u>where</u></font> f' <font color=Red>=</font> simulate_transform_unary f input
<a name="line-754"></a>
<a name="line-755"></a><font color=Blue><i>-- ======================================================================</i></font>
<a name="line-756"></a><font color=Blue><i>-- * Generic functions</i></font>
<a name="line-757"></a>
<a name="line-758"></a><font color=Blue><i>-- ** Generic run function</i></font>
<a name="line-759"></a>
<a name="line-760"></a><font color=Blue><i>-- $ Generic functions to run Quipper circuits, via a conversion to a</i></font>
<a name="line-761"></a><font color=Blue><i>-- 'SimCircuit' using "Random" to simulate quantum states.</i></font>
<a name="line-762"></a>
<a name="line-763"></a><a name="run_generic"></a><font color=Blue><i>-- | Quantum simulation of a circuit, for testing and debugging</i></font>
<a name="line-764"></a><font color=Blue><i>-- purposes. Input a source of randomness, a real number, and a</i></font>
<a name="line-765"></a><font color=Blue><i>-- quantum circuit. Output a corresponding probabilistic boolean</i></font>
<a name="line-766"></a><font color=Blue><i>-- function.</i></font>
<a name="line-767"></a><font color=Blue><i>-- </i></font>
<a name="line-768"></a><font color=Blue><i>-- The inputs to the quantum circuit are initialized according to the</i></font>
<a name="line-769"></a><font color=Blue><i>-- given boolean arguments. The outputs of the quantum circuit are</i></font>
<a name="line-770"></a><font color=Blue><i>-- measured, and the boolean measurement outcomes are</i></font>
<a name="line-771"></a><font color=Blue><i>-- returned. </i></font>
<a name="line-772"></a><font color=Blue><i>-- </i></font>
<a name="line-773"></a><font color=Blue><i>-- The real number argument is a dummy and is never evaluated; its</i></font>
<a name="line-774"></a><font color=Blue><i>-- only purpose is to specify the /type/ of real numbers that will be</i></font>
<a name="line-775"></a><font color=Blue><i>-- used during the simulation.</i></font>
<a name="line-776"></a><font color=Blue><i>-- </i></font>
<a name="line-777"></a><font color=Blue><i>-- The type of this heavily overloaded function is difficult to</i></font>
<a name="line-778"></a><font color=Blue><i>-- read. In more readable form, it has all of the following types (for</i></font>
<a name="line-779"></a><font color=Blue><i>-- example):</i></font>
<a name="line-780"></a><font color=Blue><i>-- </i></font>
<a name="line-781"></a><font color=Blue><i>-- &gt; run_generic :: (Floating r, Random r, Ord r, RandomGen g, QCData qa) =&gt; g -&gt; r -&gt; Circ qa -&gt; BType qa</i></font>
<a name="line-782"></a><font color=Blue><i>-- &gt; run_generic :: (Floating r, Random r, Ord r, RandomGen g, QCData qa, QCData qb) =&gt; g -&gt; r -&gt; (qa -&gt; Circ qb) -&gt; BType qa -&gt; BType qb</i></font>
<a name="line-783"></a><font color=Blue><i>-- &gt; run_generic :: (Floating r, Random r, Ord r, RandomGen g, QCData qa, QCData qb, QCData qc) =&gt; g -&gt; r -&gt; (qa -&gt; qb -&gt; Circ qc) -&gt; BType qa -&gt; BType qb -&gt; BType qc</i></font>
<a name="line-784"></a><font color=Blue><i>-- </i></font>
<a name="line-785"></a><font color=Blue><i>-- and so forth.</i></font>
<a name="line-786"></a><font color=Blue>run_generic</font> <font color=Red>::</font> <font color=Cyan>(</font>Floating r<font color=Cyan>,</font> Random r<font color=Cyan>,</font> Ord r<font color=Cyan>,</font> RandomGen g<font color=Cyan>,</font> QCData qa<font color=Cyan>,</font> QCDataPlus qb<font color=Cyan>,</font> QCurry qfun qa qb<font color=Cyan>,</font> 
<a name="line-787"></a> Curry qfun' <font color=Cyan>(</font>QCType Bool Bool qa<font color=Cyan>)</font> <font color=Cyan>(</font>QCType Qubit Bool <font color=Cyan>(</font>QCType Bit Bit qb<font color=Cyan>)</font><font color=Cyan>)</font><font color=Cyan>)</font> <font color=Red>=&gt;</font> g <font color=Red>-&gt;</font> r <font color=Red>-&gt;</font> qfun <font color=Red>-&gt;</font> qfun'
<a name="line-788"></a><font color=Blue>run_generic</font> gen r f <font color=Red>=</font> g
<a name="line-789"></a> <font color=Green><u>where</u></font>
<a name="line-790"></a>  f1 <font color=Red>=</font> quncurry f
<a name="line-791"></a>  g1 <font color=Red>=</font> run_unary gen r f1
<a name="line-792"></a>  g <font color=Red>=</font> mcurry g1
<a name="line-793"></a>
<a name="line-794"></a><a name="run_generic_trace"></a><font color=Blue><i>-- | Like 'run_generic', but also output a trace of the states of the</i></font>
<a name="line-795"></a><font color=Blue><i>-- given list of qubits at each step during the evaluation.</i></font>
<a name="line-796"></a><font color=Blue>run_generic_trace</font> <font color=Red>::</font> <font color=Cyan>(</font>Floating r<font color=Cyan>,</font> Random r<font color=Cyan>,</font> Ord r<font color=Cyan>,</font> RandomGen g<font color=Cyan>,</font> QCData qa<font color=Cyan>,</font> QCDataPlus qb<font color=Cyan>,</font> QCurry qfun qa qb<font color=Cyan>,</font>
<a name="line-797"></a> Curry qfun' <font color=Cyan>(</font>QCType Bool Bool qa<font color=Cyan>)</font> <font color=Red>[</font>QuantumTrace r<font color=Red>]</font><font color=Cyan>)</font> <font color=Red>=&gt;</font> g <font color=Red>-&gt;</font> r <font color=Red>-&gt;</font> qfun <font color=Red>-&gt;</font> qfun'
<a name="line-798"></a><font color=Blue>run_generic_trace</font> gen r f <font color=Red>=</font> g 
<a name="line-799"></a> <font color=Green><u>where</u></font>
<a name="line-800"></a>  f1 <font color=Red>=</font> quncurry f
<a name="line-801"></a>  g1 <font color=Red>=</font> run_unary_trace gen r f1
<a name="line-802"></a>  g <font color=Red>=</font> mcurry g1
<a name="line-803"></a>
<a name="line-804"></a><a name="run_generic_io"></a><font color=Blue><i>-- | Like 'run_generic', but run in the 'IO' monad instead of passing</i></font>
<a name="line-805"></a><font color=Blue><i>-- an explicit source of randomness.</i></font>
<a name="line-806"></a><font color=Blue>run_generic_io</font> <font color=Red>::</font> <font color=Cyan>(</font>Floating r<font color=Cyan>,</font> Random r<font color=Cyan>,</font> Ord r<font color=Cyan>,</font> QCData qa<font color=Cyan>,</font> QCDataPlus qb<font color=Cyan>,</font> QCurry qfun qa qb<font color=Cyan>,</font> 
<a name="line-807"></a> Curry qfun' <font color=Cyan>(</font>QCType Bool Bool qa<font color=Cyan>)</font> <font color=Cyan>(</font>IO <font color=Cyan>(</font>QCType Qubit Bool <font color=Cyan>(</font>QCType Bit Bit qb<font color=Cyan>)</font><font color=Cyan>)</font><font color=Cyan>)</font><font color=Cyan>)</font> <font color=Red>=&gt;</font> r <font color=Red>-&gt;</font> qfun <font color=Red>-&gt;</font> qfun'
<a name="line-808"></a><font color=Blue>run_generic_io</font> r f <font color=Red>=</font> g 
<a name="line-809"></a> <font color=Green><u>where</u></font>
<a name="line-810"></a>  f1 <font color=Red>=</font> quncurry f
<a name="line-811"></a>  g1 <font color=Red>=</font> run_unary_io r f1
<a name="line-812"></a>  g <font color=Red>=</font> mcurry g1
<a name="line-813"></a>
<a name="line-814"></a><a name="run_generic_trace_io"></a><font color=Blue><i>-- | Like 'run_generic_trace', but run in the 'IO' monad instead of</i></font>
<a name="line-815"></a><font color=Blue><i>-- passing an explicit source of randomness.</i></font>
<a name="line-816"></a><font color=Blue>run_generic_trace_io</font> <font color=Red>::</font> <font color=Cyan>(</font>Floating r<font color=Cyan>,</font> Random r<font color=Cyan>,</font> Ord r<font color=Cyan>,</font> QCData qa<font color=Cyan>,</font> QCDataPlus qb<font color=Cyan>,</font> QCurry qfun qa qb<font color=Cyan>,</font>
<a name="line-817"></a> Curry qfun' <font color=Cyan>(</font>QCType Bool Bool qa<font color=Cyan>)</font> <font color=Cyan>(</font>IO <font color=Red>[</font>QuantumTrace r<font color=Red>]</font><font color=Cyan>)</font><font color=Cyan>)</font> <font color=Red>=&gt;</font> r <font color=Red>-&gt;</font> qfun <font color=Red>-&gt;</font> qfun'
<a name="line-818"></a><font color=Blue>run_generic_trace_io</font> r f <font color=Red>=</font> g 
<a name="line-819"></a> <font color=Green><u>where</u></font>
<a name="line-820"></a>  f1 <font color=Red>=</font> quncurry f
<a name="line-821"></a>  g1 <font color=Red>=</font> run_unary_trace_io r f1
<a name="line-822"></a>  g <font color=Red>=</font> mcurry g1
<a name="line-823"></a>
<a name="line-824"></a><font color=Blue><i>-- ----------------------------------------------------------------------</i></font>
<a name="line-825"></a><font color=Blue><i>-- ** Generic sim function</i></font>
<a name="line-826"></a>
<a name="line-827"></a><font color=Blue><i>-- $ A generic function to simulate Quipper circuits, via a conversion</i></font>
<a name="line-828"></a><font color=Blue><i>-- to a 'SimCircuit' returning a probability distribution of the</i></font>
<a name="line-829"></a><font color=Blue><i>-- possible results.</i></font>
<a name="line-830"></a>
<a name="line-831"></a><a name="sim_generic"></a><font color=Blue><i>-- | A generic function to simulate Quipper circuits, via a conversion</i></font>
<a name="line-832"></a><font color=Blue><i>-- to a 'SimCircuit' returning a probability distribution of the</i></font>
<a name="line-833"></a><font color=Blue><i>-- possible results.</i></font>
<a name="line-834"></a><font color=Blue><i>-- </i></font>
<a name="line-835"></a><font color=Blue><i>-- The type of this heavily overloaded function is difficult to</i></font>
<a name="line-836"></a><font color=Blue><i>-- read. In more readable form, it has all of the following types (for</i></font>
<a name="line-837"></a><font color=Blue><i>-- example):</i></font>
<a name="line-838"></a><font color=Blue><i>-- </i></font>
<a name="line-839"></a><font color=Blue><i>-- &gt; sim_generic :: (Floating r, Ord r, QCData qa) =&gt; r -&gt; Circ qa -&gt; ProbabilityDistribution r (BType qa)</i></font>
<a name="line-840"></a><font color=Blue><i>-- &gt; sim_generic :: (Floating r, Ord r, QCData qa, QCData qb) =&gt; r -&gt; (qa -&gt; Circ qb) -&gt; BType qa -&gt; ProbabilityDistribution r (BType qb)</i></font>
<a name="line-841"></a><font color=Blue><i>-- &gt; sim_generic :: (Floating r, Ord r, QCData qa, QCData qb, QCData qc) =&gt; r -&gt; (qa -&gt; qb -&gt; Circ qc) -&gt; BType qa -&gt; BType qb -&gt; ProbabilityDistribution r (BType qc)</i></font>
<a name="line-842"></a><font color=Blue><i>-- </i></font>
<a name="line-843"></a><font color=Blue><i>-- and so forth.</i></font>
<a name="line-844"></a><font color=Blue>sim_generic</font> <font color=Red>::</font> <font color=Cyan>(</font>Floating r<font color=Cyan>,</font> Ord r<font color=Cyan>,</font> QCData qa<font color=Cyan>,</font> QCDataPlus qb<font color=Cyan>,</font> QCurry qfun qa qb<font color=Cyan>,</font>
<a name="line-845"></a> Curry qfun' <font color=Cyan>(</font>QCType Bool Bool qa<font color=Cyan>)</font> <font color=Cyan>(</font>ProbabilityDistribution r <font color=Cyan>(</font>QCType Qubit Bool <font color=Cyan>(</font>QCType Bit Bit qb<font color=Cyan>)</font><font color=Cyan>)</font><font color=Cyan>)</font><font color=Cyan>)</font> <font color=Red>=&gt;</font> r <font color=Red>-&gt;</font> qfun <font color=Red>-&gt;</font> qfun'
<a name="line-846"></a><font color=Blue>sim_generic</font> r f <font color=Red>=</font> g <font color=Green><u>where</u></font>
<a name="line-847"></a>  f1 <font color=Red>=</font> quncurry f
<a name="line-848"></a>  g1 <font color=Red>=</font> sim_unary r f1
<a name="line-849"></a>  g <font color=Red>=</font> mcurry g1         
<a name="line-850"></a>
</pre>
</body>
</html>