<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<!-- Generated by HsColour, http://code.haskell.org/~malcolm/hscolour/ -->
<title>Haskell code</title>
</head>
<body>
<pre><a name="line-1"></a><font color=Blue><i>-- | This module provides the Jordan-Wigner transformation and</i></font>
<a name="line-2"></a><font color=Blue><i>-- symbolic derivation of circuit templates for second quantized</i></font>
<a name="line-3"></a><font color=Blue><i>-- interaction terms. It is essentially a fully automated version of</i></font>
<a name="line-4"></a><font color=Blue><i>-- the calculations from</i></font>
<a name="line-5"></a><font color=Blue><i>-- </i></font>
<a name="line-6"></a><font color=Blue><i>-- * James D. Whitfield, Jacob Biamonte, and Al&#225;n</i></font>
<a name="line-7"></a><font color=Blue><i>-- Aspuru-Guzik. \"Simulation of electronic structure Hamiltonians</i></font>
<a name="line-8"></a><font color=Blue><i>-- using quantum computers.\" </i></font>
<a name="line-9"></a><font color=Blue><i>-- /Molecular Physics/ 109(5):735&#8211;750, 2011.</i></font>
<a name="line-10"></a><font color=Blue><i>-- See also &lt;<a href="http://arxiv.org/abs/1001.3855v3">http://arxiv.org/abs/1001.3855v3</a>&gt;.</i></font>
<a name="line-11"></a>
<a name="line-12"></a>
<a name="line-13"></a><font color=Green><u>module</u></font> Algorithms<font color=Cyan>.</font>GSE<font color=Cyan>.</font>JordanWigner <font color=Green><u>where</u></font>
<a name="line-14"></a>
<a name="line-15"></a><font color=Green><u>import</u></font> Quipper
<a name="line-16"></a>
<a name="line-17"></a><font color=Green><u>import</u></font> QuipperLib<font color=Cyan>.</font>Decompose
<a name="line-18"></a>
<a name="line-19"></a><font color=Green><u>import</u></font> Data<font color=Cyan>.</font>Complex
<a name="line-20"></a><font color=Green><u>import</u></font> <font color=Green><u>qualified</u></font> Data<font color=Cyan>.</font>Map <font color=Green><u>as</u></font> Map
<a name="line-21"></a><font color=Green><u>import</u></font> Data<font color=Cyan>.</font>Map <font color=Cyan>(</font>Map<font color=Cyan>)</font>
<a name="line-22"></a>
<a name="line-23"></a><font color=Green><u>import</u></font> Libraries<font color=Cyan>.</font>Auxiliary <font color=Cyan>(</font>sequence_right_<font color=Cyan>)</font>
<a name="line-24"></a>
<a name="line-25"></a><font color=Green><u>import</u></font> Text<font color=Cyan>.</font>Printf
<a name="line-26"></a>
<a name="line-27"></a><font color=Blue><i>-- ----------------------------------------------------------------------</i></font>
<a name="line-28"></a><font color=Blue><i>-- * Overview</i></font>
<a name="line-29"></a>
<a name="line-30"></a><font color=Blue><i>-- $ For a given tuple of orbital indices, (/p/,/q/) in case of</i></font>
<a name="line-31"></a><font color=Blue><i>-- one-electron interactions, or (/p/,/q/,/r/,/s/) in case of two-electron</i></font>
<a name="line-32"></a><font color=Blue><i>-- interactions, we first calculate the Jordan-Wigner transformation</i></font>
<a name="line-33"></a><font color=Blue><i>-- of the second quantized hermitian interaction terms</i></font>
<a name="line-34"></a><font color=Blue><i>-- </i></font>
<a name="line-35"></a><font color=Blue><i>-- /a/[sub /p/][sup &#8224;]/a/[sub /p/], </i></font>
<a name="line-36"></a><font color=Blue><i>-- </i></font>
<a name="line-37"></a><font color=Blue><i>-- /a/[sub /p/][sup &#8224;]/a/[sub /q/] + /a/[sub /q/][sup &#8224;]/a/[sub /p/],</i></font>
<a name="line-38"></a><font color=Blue><i>-- </i></font>
<a name="line-39"></a><font color=Blue><i>-- /a/[sub /p/][sup &#8224;]/a/[sub /q/][sup &#8224;]/a/[sub /q/]/a/[sub /p/],</i></font>
<a name="line-40"></a><font color=Blue><i>-- </i></font>
<a name="line-41"></a><font color=Blue><i>-- /a/[sub /p/][sup &#8224;]/a/[sub /q/][sup &#8224;]/a/[sub /r/]/a/[sub /s/] + </i></font>
<a name="line-42"></a><font color=Blue><i>-- /a/[sub /s/][sup &#8224;]/a/[sub /r/][sup &#8224;]/a/[sub /q/]/a/[sub /p/].</i></font>
<a name="line-43"></a><font color=Blue><i>-- </i></font>
<a name="line-44"></a><font color=Blue><i>-- Next, we decompose each operator into a linear combination /H/ =</i></font>
<a name="line-45"></a><font color=Blue><i>-- &#955;[sub 1]/M/[sub 1] + ... + &#955;[sub /n/]/M/[sub /n/] of mutually</i></font>
<a name="line-46"></a><font color=Blue><i>-- commuting hermitian tensors. At this point, each summand /M/[sub /j/]</i></font>
<a name="line-47"></a><font color=Blue><i>-- in the linear combination will be a tensor product of the following</i></font>
<a name="line-48"></a><font color=Blue><i>-- operators (not necessarily in this order):</i></font>
<a name="line-49"></a><font color=Blue><i>-- </i></font>
<a name="line-50"></a><font color=Blue><i>-- * an even number (possibly zero) of Pauli /X/ operators;</i></font>
<a name="line-51"></a><font color=Blue><i>-- </i></font>
<a name="line-52"></a><font color=Blue><i>-- * an even number (possibly zero) of Pauli /Y/ operators;</i></font>
<a name="line-53"></a><font color=Blue><i>-- </i></font>
<a name="line-54"></a><font color=Blue><i>-- * zero or more Pauli /Z/ operators, and</i></font>
<a name="line-55"></a><font color=Blue><i>-- </i></font>
<a name="line-56"></a><font color=Blue><i>-- * zero or more /D/ operators, where /D/ = &#963;[sup &#8722;]&#963;[sup +] = (/I/&#8722;/Z/)\/2.</i></font>
<a name="line-57"></a><font color=Blue><i>-- </i></font>
<a name="line-58"></a><font color=Blue><i>-- Note that there may be zero terms in the summation; this happens,</i></font>
<a name="line-59"></a><font color=Blue><i>-- for example, for </i></font>
<a name="line-60"></a><font color=Blue><i>-- /a/[sub /p/][sup &#8224;]/a/[sub /p/][sup &#8224;]/a/[sub /r/]/a/[sub /s/],</i></font>
<a name="line-61"></a><font color=Blue><i>-- because two electrons cannot occupy the same spin orbital due to</i></font>
<a name="line-62"></a><font color=Blue><i>-- their fermionic nature. In this case, /H/ = 0 and [exp -/i/&#952;/H/] = /I/.</i></font>
<a name="line-63"></a><font color=Blue><i>-- </i></font>
<a name="line-64"></a><font color=Blue><i>-- Next, we calculate [exp -/i/&#952;/H/]. Because the summands /M/[sub /j/]</i></font>
<a name="line-65"></a><font color=Blue><i>-- commute, we can exponentiate each summand separately, using the formula</i></font>
<a name="line-66"></a><font color=Blue><i>-- [exp -/i/&#952;/H/] = [exp -/i/&#952;&#955;[sub 1]/M/[sub 1]]&#8943;[exp -/i/&#952;&#955;[sub /n/]/M/[sub /n/]].</i></font>
<a name="line-67"></a><font color=Blue><i>-- </i></font>
<a name="line-68"></a><font color=Blue><i>-- We then generate the circuit for [exp -/i/&#952;&#955;[sub /j/]/M/[sub /j/]]</i></font>
<a name="line-69"></a><font color=Blue><i>-- by applying a sequence of basis changes until the problem is</i></font>
<a name="line-70"></a><font color=Blue><i>-- reduced to a controlled rotation. The basis changes are, in this</i></font>
<a name="line-71"></a><font color=Blue><i>-- order:</i></font>
<a name="line-72"></a><font color=Blue><i>-- </i></font>
<a name="line-73"></a><font color=Blue><i>-- 1. Change each Pauli /X/ operator in /M/[sub /j/] to a Pauli /Z/</i></font>
<a name="line-74"></a><font color=Blue><i>-- operator, and apply a Hadamard basis change to the corresponding</i></font>
<a name="line-75"></a><font color=Blue><i>-- qubit. This uses the relation /HXH/ = /Z/.</i></font>
<a name="line-76"></a><font color=Blue><i>-- </i></font>
<a name="line-77"></a><font color=Blue><i>-- 2. Change each Pauli /Y/ operator in /M/[sub /j/] to a Pauli /Z/</i></font>
<a name="line-78"></a><font color=Blue><i>-- operator, and apply a [bold Y] basis change to the corresponding</i></font>
<a name="line-79"></a><font color=Blue><i>-- qubit. Note: the [bold Y] basis change operator is defined in</i></font>
<a name="line-80"></a><font color=Blue><i>-- [Whitfield et al.] as /R/[sub /x/](-&#960;\/2) = (/I/+/iX/)\/&#8730;2, or</i></font>
<a name="line-81"></a><font color=Blue><i>-- equivalently [bold Y] = /SHS/, and satisfies [bold Y][super &#8224;]/Y/[bold Y] =</i></font>
<a name="line-82"></a><font color=Blue><i>-- /Z/. It should not be confused with the Pauli /Y/ operator.</i></font>
<a name="line-83"></a><font color=Blue><i>-- </i></font>
<a name="line-84"></a><font color=Blue><i>-- 3. If the operator /M/[sub /j/] contains one or more Pauli /Z/ operators</i></font>
<a name="line-85"></a><font color=Blue><i>-- (including those obtained in steps 1 and 2), then do a basis change</i></font>
<a name="line-86"></a><font color=Blue><i>-- by a cascade of controlled-not gates to reduce this to a single /Z/</i></font>
<a name="line-87"></a><font color=Blue><i>-- operator. This uses the relation /CNot/ (/Z/&#8855;/Z/) /CNot/ = /I/&#8855;/Z/.</i></font>
<a name="line-88"></a><font color=Blue><i>-- </i></font>
<a name="line-89"></a><font color=Blue><i>-- After these basis changes, the operator /M/[sub /j/] consists of</i></font>
<a name="line-90"></a><font color=Blue><i>-- exactly zero or one Pauli /Z/ operator, together with zero or more</i></font>
<a name="line-91"></a><font color=Blue><i>-- /D/ operators.  To see how to translate this into a controlled</i></font>
<a name="line-92"></a><font color=Blue><i>-- rotation, note that for any operator /A/, we have</i></font>
<a name="line-93"></a><font color=Blue><i>-- </i></font>
<a name="line-94"></a><font color=Blue><i>-- \[image expDA.png]</i></font>
<a name="line-95"></a><font color=Blue><i>-- </i></font>
<a name="line-96"></a><font color=Blue><i>-- Therefore, each /D/ operator in /M/[sub /j/] turns into a control</i></font>
<a name="line-97"></a><font color=Blue><i>-- after exponentiation. The final rotation is then computed by</i></font>
<a name="line-98"></a><font color=Blue><i>-- distinguishing two cases:</i></font>
<a name="line-99"></a><font color=Blue><i>-- </i></font>
<a name="line-100"></a><font color=Blue><i>-- * If /M/[sub /j/] contains a Pauli /Z/ operator, then use the</i></font>
<a name="line-101"></a><font color=Blue><i>-- relation [exp -/i/&#952;/Z/] = /R/[sub /z/](2&#952;). In this case, the circuit</i></font>
<a name="line-102"></a><font color=Blue><i>-- for [exp -/i/&#952;/M/[sub /j/]] is a controlled /R/[sub /z/](2&#952;) gate in</i></font>
<a name="line-103"></a><font color=Blue><i>-- the position of the /Z/ operator, with zero or more controls in the</i></font>
<a name="line-104"></a><font color=Blue><i>-- positions of any /D/ operators.</i></font>
<a name="line-105"></a><font color=Blue><i>-- </i></font>
<a name="line-106"></a><font color=Blue><i>-- * If /M/[sub /j/] does not contain a Pauli /Z/ operator, then the</i></font>
<a name="line-107"></a><font color=Blue><i>-- operation to be performed is a phase change [exp -/i/&#952;], controlled</i></font>
<a name="line-108"></a><font color=Blue><i>-- by the qubits in the positions of the /D/ operators. Note that</i></font>
<a name="line-109"></a><font color=Blue><i>-- there must be at least one /D/ operator in this case. Also note</i></font>
<a name="line-110"></a><font color=Blue><i>-- that a controlled [exp -/i/&#952;] gate is identical to a /T/(&#952;) gate.</i></font>
<a name="line-111"></a>
<a name="line-112"></a><font color=Blue><i>-- ----------------------------------------------------------------------</i></font>
<a name="line-113"></a><font color=Blue><i>-- * Correctness of the templates</i></font>
<a name="line-114"></a>
<a name="line-115"></a><font color=Blue><i>-- $ As outlined above, the functions in this module generate each</i></font>
<a name="line-116"></a><font color=Blue><i>-- circuit from first principles, based on the Jordan-Wigner</i></font>
<a name="line-117"></a><font color=Blue><i>-- representation of operators and on algebraic transformations. They</i></font>
<a name="line-118"></a><font color=Blue><i>-- do not rely on pre-fabricated circuit templates.</i></font>
<a name="line-119"></a><font color=Blue><i>-- </i></font>
<a name="line-120"></a><font color=Blue><i>-- Based on the automated calculations provided by this module, we</i></font>
<a name="line-121"></a><font color=Blue><i>-- have found small typos in the 5 templates provided by [Whitfield</i></font>
<a name="line-122"></a><font color=Blue><i>-- et al.] (Table 3, or Table A1 in the arXiv version). </i></font>
<a name="line-123"></a><font color=Blue><i>-- </i></font>
<a name="line-124"></a><font color=Blue><i>-- * The template for the number-excitation operator is missing a</i></font>
<a name="line-125"></a><font color=Blue><i>-- control on its rotation gate. </i></font>
<a name="line-126"></a><font color=Blue><i>-- </i></font>
<a name="line-127"></a><font color=Blue><i>-- * In the template for the Coulomb operator, the angles are wrong. </i></font>
<a name="line-128"></a><font color=Blue><i>-- Moreover, this program finds a simpler template.</i></font>
<a name="line-129"></a><font color=Blue><i>-- </i></font>
<a name="line-130"></a><font color=Blue><i>-- * In the template for the double excitation operator, the angles</i></font>
<a name="line-131"></a><font color=Blue><i>-- are wrong; they should be &#177;&#952;\/4 instead of &#952;.</i></font>
<a name="line-132"></a><font color=Blue><i>-- </i></font>
<a name="line-133"></a><font color=Blue><i>-- The corrected templates generated by our code are as follows:</i></font>
<a name="line-134"></a><font color=Blue><i>-- </i></font>
<a name="line-135"></a><font color=Blue><i>-- * Number operator /h/[sub /pp/] /a/[sub /p/][sup &#8224;]/a/[sub /p/].</i></font>
<a name="line-136"></a><font color=Blue><i>-- </i></font>
<a name="line-137"></a><font color=Blue><i>-- &gt; [image b0-template.png]</i></font>
<a name="line-138"></a><font color=Blue><i>-- </i></font>
<a name="line-139"></a><font color=Blue><i>-- * Excitation operator /h/[sub /pq/] /a/[sub /p/][sup &#8224;]/a/[sub /q/].</i></font>
<a name="line-140"></a><font color=Blue><i>-- </i></font>
<a name="line-141"></a><font color=Blue><i>-- &gt; [image b1-template.png]</i></font>
<a name="line-142"></a><font color=Blue><i>-- </i></font>
<a name="line-143"></a><font color=Blue><i>-- * Coulomb and exchange operators /h/[sub /pqqp/]</i></font>
<a name="line-144"></a><font color=Blue><i>-- /a/[sub /p/][sup &#8224;]/a/[sub /q/][sup &#8224;]/a/[sub /q/]/a/[sub /p/].</i></font>
<a name="line-145"></a><font color=Blue><i>-- </i></font>
<a name="line-146"></a><font color=Blue><i>-- &gt; [image b2-template.png]</i></font>
<a name="line-147"></a><font color=Blue><i>-- </i></font>
<a name="line-148"></a><font color=Blue><i>-- * Number-excitation operator /h/[sub /pqqr/]</i></font>
<a name="line-149"></a><font color=Blue><i>-- (/a/[sub /p/][sup &#8224;]/a/[sub /q/][sup &#8224;]/a/[sub /q/]/a/[sub /r/] +</i></font>
<a name="line-150"></a><font color=Blue><i>-- /a/[sub /r/][sup &#8224;]/a/[sub /q/][sup &#8224;]/a/[sub /q/]/a/[sub /p/]).</i></font>
<a name="line-151"></a><font color=Blue><i>-- The sign of &#177;&#952; depends on the relative ordering of the indices /p,q,r/.</i></font>
<a name="line-152"></a><font color=Blue><i>-- </i></font>
<a name="line-153"></a><font color=Blue><i>-- &gt; [image b3-template.png]</i></font>
<a name="line-154"></a><font color=Blue><i>-- </i></font>
<a name="line-155"></a><font color=Blue><i>-- * Double excitation operator </i></font>
<a name="line-156"></a><font color=Blue><i>-- /h/[sub /pqrs/]</i></font>
<a name="line-157"></a><font color=Blue><i>-- (/a/[sub /p/][sup &#8224;]/a/[sub /q/][sup &#8224;]/a/[sub /r/]/a/[sub /s/] +</i></font>
<a name="line-158"></a><font color=Blue><i>-- /a/[sub /s/][sup &#8224;]/a/[sub /r/][sup &#8224;]/a/[sub /q/]/a/[sub /p/]).</i></font>
<a name="line-159"></a><font color=Blue><i>-- The sign of &#177;&#952;\/4 in each of the eight terms depends on the relative ordering of the indices /p,q,r,s/.</i></font>
<a name="line-160"></a><font color=Blue><i>-- </i></font>
<a name="line-161"></a><font color=Blue><i>-- &gt; [image b4-template.png] </i></font>
<a name="line-162"></a>
<a name="line-163"></a><font color=Blue><i>-- ----------------------------------------------------------------------</i></font>
<a name="line-164"></a><font color=Blue><i>-- * Alternate Coulomb templates</i></font>
<a name="line-165"></a>
<a name="line-166"></a><font color=Blue><i>-- $ As noted above, our algorithm found the following template for the</i></font>
<a name="line-167"></a><font color=Blue><i>-- Coulomb operator </i></font>
<a name="line-168"></a><font color=Blue><i>-- /a/[sub /p/][sup &#8224;]/a/[sub /q/][sup &#8224;]/a/[sub /q/]/a/[sub /p/]:</i></font>
<a name="line-169"></a><font color=Blue><i>-- </i></font>
<a name="line-170"></a><font color=Blue><i>-- &gt; [image b2-template.png]</i></font>
<a name="line-171"></a><font color=Blue><i>-- </i></font>
<a name="line-172"></a><font color=Blue><i>-- This is simpler than the template given in [Whitfield et al.], even</i></font>
<a name="line-173"></a><font color=Blue><i>-- after one accounts for the cost of decomposing the additional</i></font>
<a name="line-174"></a><font color=Blue><i>-- controlled /T/(&#952;) gate into elementary gates. However, an</i></font>
<a name="line-175"></a><font color=Blue><i>-- equivalent circuit can also be given that is more similar to the</i></font>
<a name="line-176"></a><font color=Blue><i>-- one in [Whitfield et al.] (but with corrected rotation angles):</i></font>
<a name="line-177"></a><font color=Blue><i>-- </i></font>
<a name="line-178"></a><font color=Blue><i>-- &gt; [image b2-orthodox.png]</i></font>
<a name="line-179"></a><font color=Blue><i>-- </i></font>
<a name="line-180"></a><font color=Blue><i>-- We call this the \"orthodox\" template, because it is closer to the</i></font>
<a name="line-181"></a><font color=Blue><i>-- one specified by Whitfield et al. The program will use the orthodox</i></font>
<a name="line-182"></a><font color=Blue><i>-- template if the command line option @--orthodox@ is given, and it</i></font>
<a name="line-183"></a><font color=Blue><i>-- will use the simplified template otherwise.</i></font>
<a name="line-184"></a>
<a name="line-185"></a><font color=Blue><i>-- ----------------------------------------------------------------------</i></font>
<a name="line-186"></a><font color=Blue><i>-- * General-purpose auxiliary functions</i></font>
<a name="line-187"></a>
<a name="line-188"></a><a name="power"></a><font color=Blue><i>-- | Construct a list consisting of /n/ repetitions of some element.</i></font>
<a name="line-189"></a><font color=Blue>power</font> <font color=Red>::</font> Int <font color=Red>-&gt;</font> a <font color=Red>-&gt;</font> <font color=Red>[</font>a<font color=Red>]</font>
<a name="line-190"></a><font color=Blue>power</font> n x <font color=Red>=</font> take n <font color=Cyan>$</font> repeat x
<a name="line-191"></a>
<a name="line-192"></a><a name="consecutive_pairs"></a><font color=Blue><i>-- | Extract a list of /n/-1 consecutive pairs from an /n/-element list:</i></font>
<a name="line-193"></a><font color=Blue><i>-- </i></font>
<a name="line-194"></a><font color=Blue><i>-- &gt; consecutive_pairs [] = []</i></font>
<a name="line-195"></a><font color=Blue><i>-- &gt; consecutive_pairs [1] = []</i></font>
<a name="line-196"></a><font color=Blue><i>-- &gt; consecutive_pairs [1,2] = [(1,2)]</i></font>
<a name="line-197"></a><font color=Blue><i>-- &gt; consecutive_pairs [1,2,3] = [(1,2),(2,3)]</i></font>
<a name="line-198"></a><font color=Blue><i>-- &gt; consecutive_pairs [1,2,3,4] = [(1,2),(2,3),(3,4)]</i></font>
<a name="line-199"></a><font color=Blue>consecutive_pairs</font> <font color=Red>::</font> <font color=Red>[</font>a<font color=Red>]</font> <font color=Red>-&gt;</font> <font color=Red>[</font><font color=Cyan>(</font>a<font color=Cyan>,</font>a<font color=Cyan>)</font><font color=Red>]</font>
<a name="line-200"></a><font color=Blue>consecutive_pairs</font> [] <font color=Red>=</font> []
<a name="line-201"></a><font color=Blue>consecutive_pairs</font> <font color=Red>[</font>h<font color=Red>]</font> <font color=Red>=</font> []
<a name="line-202"></a><font color=Blue>consecutive_pairs</font> <font color=Cyan>(</font>h1<font color=Red><b>:</b></font>h2<font color=Red><b>:</b></font>t<font color=Cyan>)</font> <font color=Red>=</font> <font color=Cyan>(</font>h1<font color=Cyan>,</font>h2<font color=Cyan>)</font> <font color=Red><b>:</b></font> consecutive_pairs <font color=Cyan>(</font>h2<font color=Red><b>:</b></font>t<font color=Cyan>)</font>
<a name="line-203"></a>
<a name="line-204"></a><font color=Blue><i>-- ----------------------------------------------------------------------</i></font>
<a name="line-205"></a><font color=Blue><i>-- * Scalars          </i></font>
<a name="line-206"></a>          
<a name="line-207"></a><a name="Scalar"></a><font color=Blue><i>-- | The type of complex numbers. Here, we use a floating point</i></font>
<a name="line-208"></a><a name="Scalar"></a><font color=Blue><i>-- representation, although a symbolic representation would also be</i></font>
<a name="line-209"></a><a name="Scalar"></a><font color=Blue><i>-- possible. Since for the purpose of this algorithm, all denominators</i></font>
<a name="line-210"></a><a name="Scalar"></a><font color=Blue><i>-- are powers of 2, the floating point representation is in fact exact.</i></font>
<a name="line-211"></a><a name="Scalar"></a><font color=Green><u>type</u></font> Scalar <font color=Red>=</font> Complex Double
<a name="line-212"></a>
<a name="line-213"></a><a name="i"></a><font color=Blue><i>-- | The complex number /i/.</i></font>
<a name="line-214"></a><font color=Blue>i</font> <font color=Red>::</font> Scalar
<a name="line-215"></a><font color=Blue>i</font> <font color=Red>=</font> <font color=Magenta>0</font> <font color=Red><b>:+</b></font> <font color=Magenta>1</font>
<a name="line-216"></a>
<a name="line-217"></a><font color=Blue><i>-- ----------------------------------------------------------------------</i></font>
<a name="line-218"></a><font color=Blue><i>-- * Basic Gates</i></font>
<a name="line-219"></a>
<a name="line-220"></a><a name="rotZ_at"></a><font color=Blue><i>-- | Apply a /R/[sub z](&#952;)=[exp -/i/&#952;/Z/\/2] gate. The parameter &#952; is a</i></font>
<a name="line-221"></a><font color=Blue><i>-- Bloch sphere angle.</i></font>
<a name="line-222"></a><font color=Blue><i>-- </i></font>
<a name="line-223"></a><font color=Blue><i>-- \[image Rz.png]</i></font>
<a name="line-224"></a><font color=Blue>rotZ_at</font> <font color=Red>::</font> Double <font color=Red>-&gt;</font> Qubit <font color=Red>-&gt;</font> Circ ()
<a name="line-225"></a><font color=Blue>rotZ_at</font> theta q <font color=Red>=</font> named_rotation_at <font color=Magenta>"Rz(%)"</font> theta q
<a name="line-226"></a>
<a name="line-227"></a><a name="gse_G_at"></a><font color=Blue><i>-- | Apply a /G/(&#952;) gate. This is a global phase change of [exp -/i/&#952;],</i></font>
<a name="line-228"></a><font color=Blue><i>-- so this gate only \"does\" something when it is controlled.</i></font>
<a name="line-229"></a><font color=Blue><i>-- Although it is logically a 0-ary gate, we give it a qubit argument</i></font>
<a name="line-230"></a><font color=Blue><i>-- to specify where the gate can be drawn in circuit diagrams.</i></font>
<a name="line-231"></a><font color=Blue><i>-- </i></font>
<a name="line-232"></a><font color=Blue><i>-- \[image G.png]</i></font>
<a name="line-233"></a><font color=Blue>gse_G_at</font> <font color=Red>::</font> Double <font color=Red>-&gt;</font> Qubit <font color=Red>-&gt;</font> Circ ()
<a name="line-234"></a><font color=Blue>gse_G_at</font> theta q <font color=Red>=</font> named_rotation_at <font color=Magenta>"G(%)"</font> theta q
<a name="line-235"></a>
<a name="line-236"></a><a name="gse_T_at"></a><font color=Blue><i>-- | Apply a /T/(&#952;) gate. This is a /Z/-rotation, but differs</i></font>
<a name="line-237"></a><font color=Blue><i>-- from /R/[sub z](-&#952;) by a global phase.</i></font>
<a name="line-238"></a><font color=Blue><i>-- </i></font>
<a name="line-239"></a><font color=Blue><i>-- \[image T.png]</i></font>
<a name="line-240"></a><font color=Blue>gse_T_at</font> <font color=Red>::</font> Double <font color=Red>-&gt;</font> Qubit <font color=Red>-&gt;</font> Circ ()
<a name="line-241"></a><font color=Blue>gse_T_at</font> theta q <font color=Red>=</font> named_rotation_at <font color=Magenta>"T(%)"</font> theta q
<a name="line-242"></a>
<a name="line-243"></a><a name="gse_Y_at"></a><font color=Blue><i>-- | Apply a [bold Y] basis change gate. This is defined as [bold Y] = /SHS/, </i></font>
<a name="line-244"></a><font color=Blue><i>-- or equivalently,</i></font>
<a name="line-245"></a><font color=Blue><i>-- </i></font>
<a name="line-246"></a><font color=Blue><i>-- \[image Y.png]</i></font>
<a name="line-247"></a><font color=Blue><i>-- </i></font>
<a name="line-248"></a><font color=Blue><i>-- This should not be confused with the Pauli /Y/ gate.</i></font>
<a name="line-249"></a><font color=Blue>gse_Y_at</font> <font color=Red>::</font> Qubit <font color=Red>-&gt;</font> Circ ()
<a name="line-250"></a><font color=Blue>gse_Y_at</font> q <font color=Red>=</font> named_gate_at <font color=Magenta>"YY"</font> q
<a name="line-251"></a>
<a name="line-252"></a><font color=Blue><i>-- ----------------------------------------------------------------------</i></font>
<a name="line-253"></a><font color=Blue><i>-- * Basic operators</i></font>
<a name="line-254"></a>
<a name="line-255"></a><a name="Op"></a><font color=Blue><i>-- | This type provides a symbolic representation of certain</i></font>
<a name="line-256"></a><a name="Op"></a><font color=Blue><i>-- operators, generated by the Pauli operators, /P/ = &#963;[sup +], and</i></font>
<a name="line-257"></a><a name="Op"></a><font color=Blue><i>-- /M/ = &#963;[sup &#8722;]. For lack of a better term, we call these the</i></font>
<a name="line-258"></a><a name="Op"></a><font color=Blue><i>-- \"basic\" operators. Note that apart from /P/ and /M/, all of these</i></font>
<a name="line-259"></a><a name="Op"></a><font color=Blue><i>-- are hermitian.</i></font>
<a name="line-260"></a><a name="Op"></a><font color=Green><u>data</u></font> Op <font color=Red>=</font> 
<a name="line-261"></a>  I <font color=Blue><i>-- ^ Identity operator.</i></font>
<a name="line-262"></a>  <font color=Red>|</font> X  <font color=Blue><i>-- ^ Pauli /X/ operator.  </i></font>
<a name="line-263"></a>  <font color=Red>|</font> Y  <font color=Blue><i>-- ^ Pauli /Y/ operator.</i></font>
<a name="line-264"></a>  <font color=Red>|</font> Z  <font color=Blue><i>-- ^ Pauli /Z/ operator.</i></font>
<a name="line-265"></a>  <font color=Red>|</font> P  <font color=Blue><i>-- ^ &#963;[sup +] operator = (0,1;0,0).</i></font>
<a name="line-266"></a>  <font color=Red>|</font> M  <font color=Blue><i>-- ^ &#963;[sup &#8722;] operator = (0,0;1,0).</i></font>
<a name="line-267"></a>  <font color=Red>|</font> A  <font color=Blue><i>-- ^ &#963;[sup +]&#963;[sup &#8722;] operator = (1,0;0,0).</i></font>
<a name="line-268"></a>  <font color=Red>|</font> D  <font color=Blue><i>-- ^ &#963;[sup &#8722;]&#963;[sup +] operator = (0,0;0,1).</i></font>
<a name="line-269"></a>  <font color=Green><u>deriving</u></font> <font color=Cyan>(</font>Show<font color=Cyan>,</font> Eq<font color=Cyan>,</font> Ord<font color=Cyan>)</font>
<a name="line-270"></a>
<a name="line-271"></a><a name="Scaled"></a><font color=Blue><i>-- | A type to represent scalar multiples. An element of ('Scaled'</i></font>
<a name="line-272"></a><a name="Scaled"></a><font color=Blue><i>-- /a/) is a pair (&#955;, /x/) of a complex scalar &#955; and an element /x/ &#8712;</i></font>
<a name="line-273"></a><a name="Scaled"></a><font color=Blue><i>-- /a/. </i></font>
<a name="line-274"></a><a name="Scaled"></a><font color=Green><u>data</u></font> Scaled a <font color=Red>=</font> Scaled Scalar a
<a name="line-275"></a>
<a name="line-276"></a><font color=Blue><i>-- | Multiplication of basic operators. Note that the product of two</i></font>
<a name="line-277"></a><font color=Blue><i>-- basic operators is not usually itself a basic operator, but a</i></font>
<a name="line-278"></a><font color=Blue><i>-- scalar multiple thereof. This multiplication encodes the algebraic</i></font>
<a name="line-279"></a><font color=Blue><i>-- laws of basic operators in symbolic form.</i></font>
<a name="line-280"></a>          
<a name="line-281"></a><a name="mult"></a><font color=Blue><i>-- Implementation note: the multiplication laws are currently</i></font>
<a name="line-282"></a><font color=Blue><i>-- implemented as a long case distinction. Perhaps it could be done</i></font>
<a name="line-283"></a><font color=Blue><i>-- more cleverly.</i></font>
<a name="line-284"></a><font color=Blue>mult</font> <font color=Red>::</font> Op <font color=Red>-&gt;</font> Op <font color=Red>-&gt;</font> Scaled Op
<a name="line-285"></a>
<a name="line-286"></a><font color=Blue><i>-- The Pauli group</i></font>
<a name="line-287"></a><font color=Blue>mult</font> I x <font color=Red>=</font> Scaled <font color=Magenta>1</font> x
<a name="line-288"></a><font color=Blue>mult</font> x I <font color=Red>=</font> Scaled <font color=Magenta>1</font> x
<a name="line-289"></a>
<a name="line-290"></a><font color=Blue>mult</font> X X <font color=Red>=</font> Scaled <font color=Magenta>1</font> I
<a name="line-291"></a><font color=Blue>mult</font> X Y <font color=Red>=</font> Scaled i Z
<a name="line-292"></a><font color=Blue>mult</font> X Z <font color=Red>=</font> Scaled <font color=Cyan>(</font><font color=Blue><i>-</i></font>i<font color=Cyan>)</font> Y
<a name="line-293"></a>
<a name="line-294"></a><font color=Blue>mult</font> Y X <font color=Red>=</font> Scaled <font color=Cyan>(</font><font color=Blue><i>-</i></font>i<font color=Cyan>)</font> Z
<a name="line-295"></a><font color=Blue>mult</font> Y Y <font color=Red>=</font> Scaled <font color=Magenta>1</font> I
<a name="line-296"></a><font color=Blue>mult</font> Y Z <font color=Red>=</font> Scaled i X
<a name="line-297"></a>
<a name="line-298"></a><font color=Blue>mult</font> Z X <font color=Red>=</font> Scaled i Y
<a name="line-299"></a><font color=Blue>mult</font> Z Y <font color=Red>=</font> Scaled <font color=Cyan>(</font><font color=Blue><i>-</i></font>i<font color=Cyan>)</font> X
<a name="line-300"></a><font color=Blue>mult</font> Z Z <font color=Red>=</font> Scaled <font color=Magenta>1</font> I
<a name="line-301"></a>
<a name="line-302"></a><font color=Blue><i>-- P, M, D, and A</i></font>
<a name="line-303"></a><font color=Blue>mult</font> X P <font color=Red>=</font> Scaled <font color=Magenta>1</font> D
<a name="line-304"></a><font color=Blue>mult</font> X M <font color=Red>=</font> Scaled <font color=Magenta>1</font> A
<a name="line-305"></a><font color=Blue>mult</font> X A <font color=Red>=</font> Scaled <font color=Magenta>1</font> M
<a name="line-306"></a><font color=Blue>mult</font> X D <font color=Red>=</font> Scaled <font color=Magenta>1</font> P
<a name="line-307"></a>
<a name="line-308"></a><font color=Blue>mult</font> Y P <font color=Red>=</font> Scaled i D
<a name="line-309"></a><font color=Blue>mult</font> Y M <font color=Red>=</font> Scaled <font color=Cyan>(</font><font color=Blue><i>-</i></font>i<font color=Cyan>)</font> A
<a name="line-310"></a><font color=Blue>mult</font> Y A <font color=Red>=</font> Scaled i M
<a name="line-311"></a><font color=Blue>mult</font> Y D <font color=Red>=</font> Scaled <font color=Cyan>(</font><font color=Blue><i>-</i></font>i<font color=Cyan>)</font> P
<a name="line-312"></a>
<a name="line-313"></a><font color=Blue>mult</font> Z P <font color=Red>=</font> Scaled <font color=Magenta>1</font> P
<a name="line-314"></a><font color=Blue>mult</font> Z M <font color=Red>=</font> Scaled <font color=Cyan>(</font><font color=Blue><i>-</i></font><font color=Magenta>1</font><font color=Cyan>)</font> M
<a name="line-315"></a><font color=Blue>mult</font> Z A <font color=Red>=</font> Scaled <font color=Magenta>1</font> A
<a name="line-316"></a><font color=Blue>mult</font> Z D <font color=Red>=</font> Scaled <font color=Cyan>(</font><font color=Blue><i>-</i></font><font color=Magenta>1</font><font color=Cyan>)</font> D
<a name="line-317"></a>
<a name="line-318"></a><font color=Blue>mult</font> P X <font color=Red>=</font> Scaled <font color=Magenta>1</font> A
<a name="line-319"></a><font color=Blue>mult</font> M X <font color=Red>=</font> Scaled <font color=Magenta>1</font> D
<a name="line-320"></a><font color=Blue>mult</font> A X <font color=Red>=</font> Scaled <font color=Magenta>1</font> P
<a name="line-321"></a><font color=Blue>mult</font> D X <font color=Red>=</font> Scaled <font color=Magenta>1</font> A
<a name="line-322"></a>
<a name="line-323"></a><font color=Blue>mult</font> P Y <font color=Red>=</font> Scaled i A
<a name="line-324"></a><font color=Blue>mult</font> M Y <font color=Red>=</font> Scaled <font color=Cyan>(</font><font color=Blue><i>-</i></font>i<font color=Cyan>)</font> D
<a name="line-325"></a><font color=Blue>mult</font> A Y <font color=Red>=</font> Scaled <font color=Cyan>(</font><font color=Blue><i>-</i></font>i<font color=Cyan>)</font> P
<a name="line-326"></a><font color=Blue>mult</font> D Y <font color=Red>=</font> Scaled i M
<a name="line-327"></a>
<a name="line-328"></a><font color=Blue>mult</font> P Z <font color=Red>=</font> Scaled <font color=Cyan>(</font><font color=Blue><i>-</i></font><font color=Magenta>1</font><font color=Cyan>)</font> P
<a name="line-329"></a><font color=Blue>mult</font> M Z <font color=Red>=</font> Scaled <font color=Magenta>1</font> M
<a name="line-330"></a><font color=Blue>mult</font> A Z <font color=Red>=</font> Scaled <font color=Magenta>1</font> A
<a name="line-331"></a><font color=Blue>mult</font> D Z <font color=Red>=</font> Scaled <font color=Cyan>(</font><font color=Blue><i>-</i></font><font color=Magenta>1</font><font color=Cyan>)</font> D
<a name="line-332"></a>
<a name="line-333"></a><font color=Blue>mult</font> P P <font color=Red>=</font> Scaled <font color=Magenta>0</font> I
<a name="line-334"></a><font color=Blue>mult</font> P M <font color=Red>=</font> Scaled <font color=Magenta>1</font> A
<a name="line-335"></a><font color=Blue>mult</font> P A <font color=Red>=</font> Scaled <font color=Magenta>0</font> I
<a name="line-336"></a><font color=Blue>mult</font> P D <font color=Red>=</font> Scaled <font color=Magenta>1</font> P
<a name="line-337"></a>  
<a name="line-338"></a><font color=Blue>mult</font> M P <font color=Red>=</font> Scaled <font color=Magenta>1</font> D
<a name="line-339"></a><font color=Blue>mult</font> M M <font color=Red>=</font> Scaled <font color=Magenta>0</font> I
<a name="line-340"></a><font color=Blue>mult</font> M A <font color=Red>=</font> Scaled <font color=Magenta>1</font> M
<a name="line-341"></a><font color=Blue>mult</font> M D <font color=Red>=</font> Scaled <font color=Magenta>0</font> I
<a name="line-342"></a>  
<a name="line-343"></a><font color=Blue>mult</font> A P <font color=Red>=</font> Scaled <font color=Magenta>1</font> P
<a name="line-344"></a><font color=Blue>mult</font> A M <font color=Red>=</font> Scaled <font color=Magenta>0</font> I
<a name="line-345"></a><font color=Blue>mult</font> A A <font color=Red>=</font> Scaled <font color=Magenta>1</font> A
<a name="line-346"></a><font color=Blue>mult</font> A D <font color=Red>=</font> Scaled <font color=Magenta>0</font> I
<a name="line-347"></a>  
<a name="line-348"></a><font color=Blue>mult</font> D P <font color=Red>=</font> Scaled <font color=Magenta>0</font> I
<a name="line-349"></a><font color=Blue>mult</font> D M <font color=Red>=</font> Scaled <font color=Magenta>1</font> M
<a name="line-350"></a><font color=Blue>mult</font> D A <font color=Red>=</font> Scaled <font color=Magenta>0</font> I
<a name="line-351"></a><font color=Blue>mult</font> D D <font color=Red>=</font> Scaled <font color=Magenta>1</font> D
<a name="line-352"></a>  
<a name="line-353"></a><font color=Blue><i>-- ----------------------------------------------------------------------</i></font>
<a name="line-354"></a><font color=Blue><i>-- * Tensors of basic operators</i></font>
<a name="line-355"></a>
<a name="line-356"></a><a name="Tensor"></a><font color=Blue><i>-- | We use a list of basic operators to represent a tensor</i></font>
<a name="line-357"></a><a name="Tensor"></a><font color=Blue><i>-- product. The convention is that infinitely many identity operators</i></font>
<a name="line-358"></a><a name="Tensor"></a><font color=Blue><i>-- are implicitly appended at the end of the list.</i></font>
<a name="line-359"></a><a name="Tensor"></a><font color=Green><u>type</u></font> Tensor <font color=Red>=</font> <font color=Red>[</font>Op<font color=Red>]</font>
<a name="line-360"></a>
<a name="line-361"></a><a name="normalize_tensor"></a><font color=Blue><i>-- | Normalize a tensor, by stripping away trailing identities.</i></font>
<a name="line-362"></a><font color=Blue>normalize_tensor</font> <font color=Red>::</font> Tensor <font color=Red>-&gt;</font> Tensor
<a name="line-363"></a><font color=Blue>normalize_tensor</font> [] <font color=Red>=</font> []
<a name="line-364"></a><font color=Blue>normalize_tensor</font> <font color=Cyan>(</font>h<font color=Red><b>:</b></font>t<font color=Cyan>)</font> <font color=Red>=</font>
<a name="line-365"></a>  <font color=Green><u>if</u></font> h <font color=Cyan>==</font> I <font color=Cyan>&amp;&amp;</font> null n 
<a name="line-366"></a>  <font color=Green><u>then</u></font> [] 
<a name="line-367"></a>  <font color=Green><u>else</u></font> <font color=Cyan>(</font>h<font color=Red><b>:</b></font>n<font color=Cyan>)</font>
<a name="line-368"></a>    <font color=Green><u>where</u></font> n <font color=Red>=</font> normalize_tensor t
<a name="line-369"></a>
<a name="line-370"></a><a name="tensor_id"></a><font color=Blue><i>-- | The identity tensor.</i></font>
<a name="line-371"></a><font color=Blue>tensor_id</font> <font color=Red>::</font> Tensor
<a name="line-372"></a><font color=Blue>tensor_id</font> <font color=Red>=</font> []
<a name="line-373"></a>
<a name="line-374"></a><a name="mult_tensor"></a><font color=Blue><i>-- | Multiply two tensors. This returns a scaled tensor.</i></font>
<a name="line-375"></a><font color=Blue>mult_tensor</font> <font color=Red>::</font> Tensor <font color=Red>-&gt;</font> Tensor <font color=Red>-&gt;</font> Scaled Tensor
<a name="line-376"></a><font color=Blue>mult_tensor</font> [] bs <font color=Red>=</font> Scaled <font color=Magenta>1</font> bs
<a name="line-377"></a><font color=Blue>mult_tensor</font> <font color=Green><u>as</u></font> [] <font color=Red>=</font> Scaled <font color=Magenta>1</font> <font color=Green><u>as</u></font>
<a name="line-378"></a><font color=Blue>mult_tensor</font> <font color=Cyan>(</font>a<font color=Red><b>:</b></font><font color=Green><u>as</u></font><font color=Cyan>)</font> <font color=Cyan>(</font>b<font color=Red><b>:</b></font>bs<font color=Cyan>)</font> <font color=Red>=</font> Scaled <font color=Cyan>(</font>x<font color=Cyan>*</font>y<font color=Cyan>)</font> <font color=Cyan>(</font>c<font color=Red><b>:</b></font>cs<font color=Cyan>)</font> <font color=Green><u>where</u></font>
<a name="line-379"></a>  Scaled x c <font color=Red>=</font> mult a b
<a name="line-380"></a>  Scaled y cs <font color=Red>=</font> mult_tensor <font color=Green><u>as</u></font> bs
<a name="line-381"></a>
<a name="line-382"></a><a name="mult_scaled_tensor"></a><font color=Blue><i>-- | Multiply two scaled tensors.</i></font>
<a name="line-383"></a><font color=Blue>mult_scaled_tensor</font> <font color=Red>::</font> Scaled Tensor <font color=Red>-&gt;</font> Scaled Tensor <font color=Red>-&gt;</font> Scaled Tensor
<a name="line-384"></a><font color=Blue>mult_scaled_tensor</font> <font color=Cyan>(</font>Scaled x a<font color=Cyan>)</font> <font color=Cyan>(</font>Scaled y b<font color=Cyan>)</font> <font color=Red>=</font> Scaled <font color=Cyan>(</font>x<font color=Cyan>*</font>y<font color=Cyan>*</font>z<font color=Cyan>)</font> c <font color=Green><u>where</u></font>
<a name="line-385"></a>  Scaled z c <font color=Red>=</font> a <font color=Cyan>`mult_tensor`</font> b
<a name="line-386"></a>
<a name="line-387"></a><font color=Blue><i>-- ----------------------------------------------------------------------</i></font>
<a name="line-388"></a><font color=Blue><i>-- * Linear combinations of tensors</i></font>
<a name="line-389"></a>
<a name="line-390"></a><a name="TensorLC"></a><font color=Blue><i>-- | A type to represent complex linear combinations of tensors. </i></font>
<a name="line-391"></a><a name="TensorLC"></a><font color=Green><u>type</u></font> TensorLC <font color=Red>=</font> Map Tensor Scalar
<a name="line-392"></a>
<a name="line-393"></a><a name="lc_zero"></a><font color=Blue><i>-- | The origin.</i></font>
<a name="line-394"></a><font color=Blue>lc_zero</font> <font color=Red>::</font> TensorLC
<a name="line-395"></a><font color=Blue>lc_zero</font> <font color=Red>=</font> Map<font color=Cyan>.</font>empty
<a name="line-396"></a>
<a name="line-397"></a><a name="lc_insert"></a><font color=Blue><i>-- | Add a tensor to a linear combination.</i></font>
<a name="line-398"></a><font color=Blue>lc_insert</font> <font color=Red>::</font> TensorLC <font color=Red>-&gt;</font> Scaled Tensor <font color=Red>-&gt;</font> TensorLC
<a name="line-399"></a><font color=Blue>lc_insert</font> lc <font color=Cyan>(</font>Scaled lambda t<font color=Cyan>)</font> <font color=Red>=</font>
<a name="line-400"></a>  <font color=Green><u>if</u></font> newvalue <font color=Cyan>==</font> <font color=Magenta>0</font>
<a name="line-401"></a>  <font color=Green><u>then</u></font>
<a name="line-402"></a>    Map<font color=Cyan>.</font>delete m lc
<a name="line-403"></a>  <font color=Green><u>else</u></font>
<a name="line-404"></a>    Map<font color=Cyan>.</font>insert m newvalue lc
<a name="line-405"></a>      <font color=Green><u>where</u></font>
<a name="line-406"></a>        m <font color=Red>=</font> normalize_tensor t
<a name="line-407"></a>        newvalue <font color=Red>=</font> <font color=Green><u>case</u></font> Map<font color=Cyan>.</font>lookup m lc <font color=Green><u>of</u></font>
<a name="line-408"></a>          Nothing <font color=Red>-&gt;</font> lambda
<a name="line-409"></a>          Just x <font color=Red>-&gt;</font> lambda <font color=Cyan>+</font> x
<a name="line-410"></a>    
<a name="line-411"></a><a name="lc_from_list"></a><font color=Blue><i>-- | Turn a list of scaled tensors into a 'TensorLC'.</i></font>
<a name="line-412"></a><font color=Blue>lc_from_list</font> <font color=Red>::</font> <font color=Red>[</font>Scaled Tensor<font color=Red>]</font> <font color=Red>-&gt;</font> TensorLC    
<a name="line-413"></a><font color=Blue>lc_from_list</font> <font color=Red>=</font> foldl lc_insert lc_zero
<a name="line-414"></a>
<a name="line-415"></a><a name="lc_to_list"></a><font color=Blue><i>-- | Turn a 'TensorLC' into a list of scaled tensors.</i></font>
<a name="line-416"></a><font color=Blue>lc_to_list</font> <font color=Red>::</font> TensorLC <font color=Red>-&gt;</font> <font color=Red>[</font>Scaled Tensor<font color=Red>]</font>
<a name="line-417"></a><font color=Blue>lc_to_list</font> lc <font color=Red>=</font> <font color=Red>[</font>Scaled x y <font color=Red>|</font> <font color=Cyan>(</font>y<font color=Cyan>,</font>x<font color=Cyan>)</font> <font color=Red>&lt;-</font> Map<font color=Cyan>.</font>toList lc<font color=Red>]</font>
<a name="line-418"></a>
<a name="line-419"></a><font color=Blue><i>-- ----------------------------------------------------------------------</i></font>
<a name="line-420"></a><font color=Blue><i>-- * Jordan-Wigner representation</i></font>
<a name="line-421"></a>
<a name="line-422"></a><font color=Blue><i>-- $ The next two functions provide the Jordan-Wigner representation of</i></font>
<a name="line-423"></a><font color=Blue><i>-- (Fock-space) annihilation and creation operators.</i></font>
<a name="line-424"></a>
<a name="line-425"></a><a name="jw"></a><font color=Blue><i>-- | Construct the Jordan-Wigner annihilation operator /a/[sub /p/] =</i></font>
<a name="line-426"></a><font color=Blue><i>-- /IIIIPZZZZZ.../ for spin-orbital index /p/. The first parameter is</i></font>
<a name="line-427"></a><font color=Blue><i>-- /p/, and the second one is /M/ (the number of spin-orbitals).</i></font>
<a name="line-428"></a><font color=Blue><i>-- Precondition: 0 &#8804; /p/ &lt; /M/.</i></font>
<a name="line-429"></a><font color=Blue>jw</font> <font color=Red>::</font> Int <font color=Red>-&gt;</font> Int <font color=Red>-&gt;</font> Scaled Tensor
<a name="line-430"></a><font color=Blue>jw</font> p m <font color=Red>=</font> Scaled <font color=Magenta>1</font> <font color=Cyan>(</font>power p I <font color=Cyan>++</font> <font color=Red>[</font>P<font color=Red>]</font> <font color=Cyan>++</font> power <font color=Cyan>(</font>m<font color=Blue><i>-</i></font>p<font color=Blue><i>-</i></font><font color=Magenta>1</font><font color=Cyan>)</font> Z<font color=Cyan>)</font>
<a name="line-431"></a>
<a name="line-432"></a><a name="jw_dagger"></a><font color=Blue><i>-- | Construct the Jordan-Wigner creation operator /a/[sub /p/][sup &#8224;]</i></font>
<a name="line-433"></a><font color=Blue><i>-- = /IIIIMZZZZ.../ for spin-orbital index /p/.  The first parameter</i></font>
<a name="line-434"></a><font color=Blue><i>-- is /p/, and the second one is /M/ (the number of spin-orbitals).</i></font>
<a name="line-435"></a><font color=Blue><i>-- Precondition: 0 &#8804; /p/ &lt; /M/.</i></font>
<a name="line-436"></a><font color=Blue>jw_dagger</font> <font color=Red>::</font> Int <font color=Red>-&gt;</font> Int <font color=Red>-&gt;</font> Scaled Tensor
<a name="line-437"></a><font color=Blue>jw_dagger</font> p m <font color=Red>=</font> Scaled <font color=Magenta>1</font> <font color=Cyan>(</font>power p I <font color=Cyan>++</font> <font color=Red>[</font>M<font color=Red>]</font> <font color=Cyan>++</font> power <font color=Cyan>(</font>m<font color=Blue><i>-</i></font>p<font color=Blue><i>-</i></font><font color=Magenta>1</font><font color=Cyan>)</font> Z<font color=Cyan>)</font>
<a name="line-438"></a>
<a name="line-439"></a><font color=Blue><i>-- ----------------------------------------------------------------------</i></font>
<a name="line-440"></a><font color=Blue><i>-- * Second quantized interaction terms</i></font>
<a name="line-441"></a>
<a name="line-442"></a><font color=Blue><i>-- ** Simple interaction terms</i></font>
<a name="line-443"></a>
<a name="line-444"></a><a name="one_electron_operator_simple"></a><font color=Blue><i>-- | Construct the one-electron second quantized non-hermitianized</i></font>
<a name="line-445"></a><font color=Blue><i>-- interaction term /a/[sub /p/][sup &#8224;]/a/[sub /q/].  The parameters</i></font>
<a name="line-446"></a><font color=Blue><i>-- are /p,q/.</i></font>
<a name="line-447"></a><font color=Blue>one_electron_operator_simple</font> <font color=Red>::</font> Int <font color=Red>-&gt;</font> Int <font color=Red>-&gt;</font> Scaled Tensor
<a name="line-448"></a><font color=Blue>one_electron_operator_simple</font> p q <font color=Red>=</font> ap <font color=Cyan>*</font> aq
<a name="line-449"></a>  <font color=Green><u>where</u></font>
<a name="line-450"></a>    ap <font color=Red>=</font> jw_dagger p m    
<a name="line-451"></a>    aq <font color=Red>=</font> jw q m
<a name="line-452"></a>    m <font color=Red>=</font> maximum <font color=Red>[</font>p<font color=Cyan>,</font>q<font color=Red>]</font> <font color=Cyan>+</font> <font color=Magenta>1</font>
<a name="line-453"></a>    <font color=Cyan>(</font><font color=Cyan>*</font><font color=Cyan>)</font> <font color=Red>=</font> mult_scaled_tensor
<a name="line-454"></a>
<a name="line-455"></a><a name="two_electron_operator_simple"></a><font color=Blue><i>-- | Construct the two-electron second quantized non-hermitianized</i></font>
<a name="line-456"></a><font color=Blue><i>-- interaction term</i></font>
<a name="line-457"></a><font color=Blue><i>-- /a/[sub /p/][sup &#8224;]/a/[sub /q/][sup &#8224;]/a/[sub /r/]/a/[sub /s/].</i></font>
<a name="line-458"></a><font color=Blue><i>-- The parameters are /p,q,r,s/.</i></font>
<a name="line-459"></a><font color=Blue>two_electron_operator_simple</font> <font color=Red>::</font> Int <font color=Red>-&gt;</font> Int <font color=Red>-&gt;</font> Int <font color=Red>-&gt;</font> Int <font color=Red>-&gt;</font> Scaled Tensor
<a name="line-460"></a><font color=Blue>two_electron_operator_simple</font> p q r s <font color=Red>=</font> ap <font color=Cyan>*</font> aq <font color=Cyan>*</font> ar <font color=Cyan>*</font> <font color=Green><u>as</u></font>
<a name="line-461"></a>  <font color=Green><u>where</u></font>
<a name="line-462"></a>    ap <font color=Red>=</font> jw_dagger p m 
<a name="line-463"></a>    aq <font color=Red>=</font> jw_dagger q m 
<a name="line-464"></a>    ar <font color=Red>=</font> jw r m 
<a name="line-465"></a>    <font color=Green><u>as</u></font> <font color=Red>=</font> jw s m
<a name="line-466"></a>    m <font color=Red>=</font> maximum <font color=Red>[</font>p<font color=Cyan>,</font>q<font color=Cyan>,</font>r<font color=Cyan>,</font>s<font color=Red>]</font> <font color=Cyan>+</font> <font color=Magenta>1</font>
<a name="line-467"></a>    <font color=Cyan>(</font><font color=Cyan>*</font><font color=Cyan>)</font> <font color=Red>=</font> mult_scaled_tensor
<a name="line-468"></a>
<a name="line-469"></a><font color=Blue><i>-- ** Hermitian interaction terms</i></font>
<a name="line-470"></a>
<a name="line-471"></a><a name="one_electron_operator"></a><font color=Blue><i>-- | Construct</i></font>
<a name="line-472"></a><font color=Blue><i>-- /a/[sub /p/][sup &#8224;]/a/[sub /q/] </i></font>
<a name="line-473"></a><font color=Blue><i>-- if /p/ = /q/, and </i></font>
<a name="line-474"></a><font color=Blue><i>-- /a/[sub /p/][sup &#8224;]/a/[sub /q/] + /a/[sub /q/][sup &#8224;]/a/[sub /p/] </i></font>
<a name="line-475"></a><font color=Blue><i>-- otherwise.</i></font>
<a name="line-476"></a><font color=Blue>one_electron_operator</font> <font color=Red>::</font> Int <font color=Red>-&gt;</font> Int <font color=Red>-&gt;</font> TensorLC    
<a name="line-477"></a><font color=Blue>one_electron_operator</font> p q <font color=Red>=</font>
<a name="line-478"></a>  <font color=Green><u>if</u></font> p <font color=Cyan>==</font> q
<a name="line-479"></a>  <font color=Green><u>then</u></font> lc_from_list <font color=Red>[</font>a_pq<font color=Red>]</font>
<a name="line-480"></a>  <font color=Green><u>else</u></font> lc_from_list <font color=Red>[</font>a_pq<font color=Cyan>,</font> a_qp<font color=Red>]</font>
<a name="line-481"></a>    <font color=Green><u>where</u></font>  
<a name="line-482"></a>      a_pq <font color=Red>=</font> one_electron_operator_simple p q 
<a name="line-483"></a>      a_qp <font color=Red>=</font> one_electron_operator_simple q p
<a name="line-484"></a>       
<a name="line-485"></a><a name="two_electron_operator"></a><font color=Blue><i>-- | Construct</i></font>
<a name="line-486"></a><font color=Blue><i>-- /a/[sub /p/][sup &#8224;]/a/[sub /q/][sup &#8224;]/a/[sub /r/]/a/[sub /s/]</i></font>
<a name="line-487"></a><font color=Blue><i>-- if (/p/,/q/) = (/s/,/r/), and </i></font>
<a name="line-488"></a><font color=Blue><i>-- /a/[sub /p/][sup &#8224;]/a/[sub /q/][sup &#8224;]/a/[sub /r/]/a/[sub /s/] +</i></font>
<a name="line-489"></a><font color=Blue><i>-- /a/[sub /s/][sup &#8224;]/a/[sub /r/][sup &#8224;]/a/[sub /q/]/a/[sub /p/]</i></font>
<a name="line-490"></a><font color=Blue><i>-- otherwise.</i></font>
<a name="line-491"></a><font color=Blue>two_electron_operator</font> <font color=Red>::</font> Int <font color=Red>-&gt;</font> Int <font color=Red>-&gt;</font> Int <font color=Red>-&gt;</font> Int <font color=Red>-&gt;</font> TensorLC
<a name="line-492"></a><font color=Blue>two_electron_operator</font> p q r s <font color=Red>=</font>
<a name="line-493"></a>  <font color=Green><u>if</u></font> <font color=Cyan>(</font>p<font color=Cyan>,</font>q<font color=Cyan>)</font> <font color=Cyan>==</font> <font color=Cyan>(</font>s<font color=Cyan>,</font>r<font color=Cyan>)</font>
<a name="line-494"></a>  <font color=Green><u>then</u></font> lc_from_list <font color=Red>[</font>a_pqrs<font color=Red>]</font>
<a name="line-495"></a>  <font color=Green><u>else</u></font> lc_from_list <font color=Red>[</font>a_pqrs<font color=Cyan>,</font> a_srqp<font color=Red>]</font>
<a name="line-496"></a>    <font color=Green><u>where</u></font>
<a name="line-497"></a>    a_pqrs <font color=Red>=</font> two_electron_operator_simple p q r s 
<a name="line-498"></a>    a_srqp <font color=Red>=</font> two_electron_operator_simple s r q p
<a name="line-499"></a>
<a name="line-500"></a><font color=Blue><i>-- ----------------------------------------------------------------------</i></font>
<a name="line-501"></a><font color=Blue><i>-- * /XYZD/ decomposition</i></font>
<a name="line-502"></a>
<a name="line-503"></a><a name="decompose_basis"></a><font color=Blue><i>-- | Decompose a basic operator into linear combinations of hermitian basic operators.</i></font>
<a name="line-504"></a><font color=Blue><i>-- This uses the relations /P/ = 1\/2 /X/ + /i/\/2 /Y/ and </i></font>
<a name="line-505"></a><font color=Blue><i>-- /M/ = 1\/2 /X/ - /i/\/2 /Y/.</i></font>
<a name="line-506"></a><font color=Blue>decompose_basis</font> <font color=Red>::</font> Op <font color=Red>-&gt;</font> <font color=Red>[</font>Scaled Op<font color=Red>]</font>
<a name="line-507"></a><font color=Blue>decompose_basis</font> P <font color=Red>=</font> <font color=Red>[</font>Scaled <font color=Cyan>(</font><font color=Magenta>1</font><font color=Cyan>/</font><font color=Magenta>2</font><font color=Cyan>)</font> X<font color=Cyan>,</font> Scaled <font color=Cyan>(</font>i<font color=Cyan>/</font><font color=Magenta>2</font><font color=Cyan>)</font> Y<font color=Red>]</font>
<a name="line-508"></a><font color=Blue>decompose_basis</font> M <font color=Red>=</font> <font color=Red>[</font>Scaled <font color=Cyan>(</font><font color=Magenta>1</font><font color=Cyan>/</font><font color=Magenta>2</font><font color=Cyan>)</font> X<font color=Cyan>,</font> Scaled <font color=Cyan>(</font><font color=Blue><i>-</i></font>i<font color=Cyan>/</font><font color=Magenta>2</font><font color=Cyan>)</font> Y<font color=Red>]</font>
<a name="line-509"></a><font color=Blue>decompose_basis</font> x <font color=Red>=</font> <font color=Red>[</font>Scaled <font color=Magenta>1</font> x<font color=Red>]</font>  <font color=Blue><i>-- default case: the remaining operators are already hermitian</i></font>
<a name="line-510"></a>
<a name="line-511"></a><a name="decompose_tensor"></a><font color=Blue><i>-- | Decompose a tensor into a linear combination of hermitian</i></font>
<a name="line-512"></a><font color=Blue><i>-- tensors. Due to sign alternation, the individual tensors all come</i></font>
<a name="line-513"></a><font color=Blue><i>-- out to commute with each other.</i></font>
<a name="line-514"></a><font color=Blue>decompose_tensor</font> <font color=Red>::</font> Tensor <font color=Red>-&gt;</font> TensorLC
<a name="line-515"></a><font color=Blue>decompose_tensor</font> [] <font color=Red>=</font> lc_from_list <font color=Red>[</font>Scaled <font color=Magenta>1</font> tensor_id<font color=Red>]</font>
<a name="line-516"></a><font color=Blue>decompose_tensor</font> <font color=Cyan>(</font>h<font color=Red><b>:</b></font>t<font color=Cyan>)</font> <font color=Red>=</font>
<a name="line-517"></a>  lc_from_list <font color=Red>[</font>Scaled <font color=Cyan>(</font>x<font color=Cyan>*</font>y<font color=Cyan>)</font> <font color=Cyan>(</font>g<font color=Red><b>:</b></font>gs<font color=Cyan>)</font> <font color=Red>|</font> 
<a name="line-518"></a>                Scaled x g <font color=Red>&lt;-</font> decompose_basis h<font color=Cyan>,</font> 
<a name="line-519"></a>                Scaled y gs <font color=Red>&lt;-</font> lc_to_list <font color=Cyan>(</font>decompose_tensor t<font color=Cyan>)</font><font color=Red>]</font>
<a name="line-520"></a>
<a name="line-521"></a><a name="decompose_tensor_lc"></a><font color=Blue><i>-- | Decompose a linear combination of tensors into a linear</i></font>
<a name="line-522"></a><font color=Blue><i>-- combination of hermitian tensors.</i></font>
<a name="line-523"></a><font color=Blue>decompose_tensor_lc</font> <font color=Red>::</font> TensorLC <font color=Red>-&gt;</font> TensorLC
<a name="line-524"></a><font color=Blue>decompose_tensor_lc</font> lc <font color=Red>=</font>                 
<a name="line-525"></a>  lc_from_list <font color=Red>[</font> Scaled <font color=Cyan>(</font>x<font color=Cyan>*</font>y<font color=Cyan>)</font> g <font color=Red>|</font> 
<a name="line-526"></a>                 Scaled x gs <font color=Red>&lt;-</font> lc_to_list lc<font color=Cyan>,</font>
<a name="line-527"></a>                 Scaled y g <font color=Red>&lt;-</font> lc_to_list <font color=Cyan>(</font>decompose_tensor gs<font color=Cyan>)</font><font color=Red>]</font>
<a name="line-528"></a>
<a name="line-529"></a><font color=Blue><i>-- ----------------------------------------------------------------------</i></font>
<a name="line-530"></a><font color=Blue><i>-- * Exponentiation and circuit generation</i></font>
<a name="line-531"></a>
<a name="line-532"></a><font color=Blue><i>-- | Given a simple hermitian tensor /H/ and an angle &#952;, generate a</i></font>
<a name="line-533"></a><font color=Blue><i>-- circuit for [exp -/i/&#952;/H/].  The given list of input qubits is in</i></font>
<a name="line-534"></a><font color=Blue><i>-- the same order as the operators in /H/. Precondition: /H/ is made</i></font>
<a name="line-535"></a><font color=Blue><i>-- up of zero or more identity operators and one or more of the</i></font>
<a name="line-536"></a><font color=Blue><i>-- operators /X/, /Y/, /Z/, and /D/. The last parameter is a list of</i></font>
<a name="line-537"></a><font color=Blue><i>-- additional controls.</i></font>
<a name="line-538"></a>
<a name="line-539"></a><a name="exponentiate_simple"></a><font color=Blue>exponentiate_simple</font> <font color=Red>::</font> Scaled Tensor <font color=Red>-&gt;</font> Double <font color=Red>-&gt;</font> <font color=Red>[</font>Qubit<font color=Red>]</font> <font color=Red>-&gt;</font> <font color=Red>[</font>Qubit<font color=Red>]</font> <font color=Red>-&gt;</font> Circ ()
<a name="line-540"></a><font color=Blue>exponentiate_simple</font> <font color=Cyan>(</font>Scaled s ms<font color=Cyan>)</font> theta qs ctl <font color=Red>=</font> <font color=Green><u>do</u></font>
<a name="line-541"></a>  <font color=Blue><i>-- First analyze the tensor:</i></font>
<a name="line-542"></a>  <font color=Green><u>let</u></font>
<a name="line-543"></a>    <font color=Blue><i>-- Find all X positions</i></font>
<a name="line-544"></a>    xs <font color=Red>=</font> <font color=Red>[</font> i <font color=Red>|</font> <font color=Cyan>(</font>m<font color=Cyan>,</font> i<font color=Cyan>)</font> <font color=Red>&lt;-</font> zip ms <font color=Red>[</font><font color=Magenta>0</font><font color=Cyan>,</font><font color=Magenta>1</font><font color=Red>..</font><font color=Red>]</font><font color=Cyan>,</font> m <font color=Cyan>==</font> X <font color=Red>]</font>
<a name="line-545"></a>    <font color=Blue><i>-- Find all Y positions</i></font>
<a name="line-546"></a>    ys <font color=Red>=</font> <font color=Red>[</font> i <font color=Red>|</font> <font color=Cyan>(</font>m<font color=Cyan>,</font> i<font color=Cyan>)</font> <font color=Red>&lt;-</font> zip ms <font color=Red>[</font><font color=Magenta>0</font><font color=Cyan>,</font><font color=Magenta>1</font><font color=Red>..</font><font color=Red>]</font><font color=Cyan>,</font> m <font color=Cyan>==</font> Y <font color=Red>]</font>
<a name="line-547"></a>    <font color=Blue><i>-- Find all X, Y, Z positions</i></font>
<a name="line-548"></a>    zs <font color=Red>=</font> <font color=Red>[</font> i <font color=Red>|</font> <font color=Cyan>(</font>m<font color=Cyan>,</font> i<font color=Cyan>)</font> <font color=Red>&lt;-</font> zip ms <font color=Red>[</font><font color=Magenta>0</font><font color=Cyan>,</font><font color=Magenta>1</font><font color=Red>..</font><font color=Red>]</font><font color=Cyan>,</font> m <font color=Cyan>`elem`</font> <font color=Red>[</font>X<font color=Cyan>,</font> Y<font color=Cyan>,</font> Z<font color=Red>]</font> <font color=Red>]</font>
<a name="line-549"></a>    <font color=Blue><i>-- Find all D positions</i></font>
<a name="line-550"></a>    ds <font color=Red>=</font> <font color=Red>[</font> i <font color=Red>|</font> <font color=Cyan>(</font>m<font color=Cyan>,</font> i<font color=Cyan>)</font> <font color=Red>&lt;-</font> zip ms <font color=Red>[</font><font color=Magenta>0</font><font color=Cyan>,</font><font color=Magenta>1</font><font color=Red>..</font><font color=Red>]</font><font color=Cyan>,</font> m <font color=Cyan>==</font> D <font color=Red>]</font>
<a name="line-551"></a>  basischange xs ys zs qs
<a name="line-552"></a>  rotation alpha ds zs <font color=Cyan>`controlled`</font> ctl
<a name="line-553"></a>  reverse_generic_imp <font color=Cyan>(</font>basischange xs ys zs<font color=Cyan>)</font> qs
<a name="line-554"></a>  <font color=Green><u>where</u></font>
<a name="line-555"></a>    alpha <font color=Red>=</font> theta <font color=Cyan>*</font> realPart s
<a name="line-556"></a>    basischange <font color=Red>::</font> <font color=Red>[</font>Int<font color=Red>]</font> <font color=Red>-&gt;</font> <font color=Red>[</font>Int<font color=Red>]</font> <font color=Red>-&gt;</font> <font color=Red>[</font>Int<font color=Red>]</font> <font color=Red>-&gt;</font> <font color=Red>[</font>Qubit<font color=Red>]</font> <font color=Red>-&gt;</font> Circ ()
<a name="line-557"></a>    basischange xs ys zs qs <font color=Red>=</font> <font color=Green><u>do</u></font>
<a name="line-558"></a>      <font color=Blue><i>-- for every X or Y in the operator, apply the appropriate basis</i></font>
<a name="line-559"></a>      <font color=Blue><i>-- change to change it to Z.</i></font>
<a name="line-560"></a>      sequence_ <font color=Red>[</font> hadamard_at <font color=Cyan>(</font>qs <font color=Cyan>!!</font> i<font color=Cyan>)</font> <font color=Red>|</font> i <font color=Red>&lt;-</font> xs <font color=Red>]</font>
<a name="line-561"></a>      sequence_ <font color=Red>[</font> gse_Y_at <font color=Cyan>(</font>qs <font color=Cyan>!!</font> i<font color=Cyan>)</font> <font color=Red>|</font> i <font color=Red>&lt;-</font> ys <font color=Red>]</font>      
<a name="line-562"></a>      <font color=Blue><i>-- apply a cascade of c-not operators to all X, Y, or Z in the</i></font>
<a name="line-563"></a>      <font color=Blue><i>-- operator</i></font>
<a name="line-564"></a>      sequence_right_ <font color=Red>[</font> qnot_at <font color=Cyan>(</font>qs <font color=Cyan>!!</font> i0<font color=Cyan>)</font> <font color=Cyan>`controlled`</font> <font color=Cyan>(</font>qs <font color=Cyan>!!</font> i1<font color=Cyan>)</font> <font color=Red>|</font> <font color=Cyan>(</font>i0<font color=Cyan>,</font>i1<font color=Cyan>)</font> <font color=Red>&lt;-</font> consecutive_pairs zs<font color=Red>]</font>
<a name="line-565"></a>    rotation <font color=Red>::</font> Timestep <font color=Red>-&gt;</font> <font color=Red>[</font>Int<font color=Red>]</font> <font color=Red>-&gt;</font> <font color=Red>[</font>Int<font color=Red>]</font> <font color=Red>-&gt;</font> Circ ()
<a name="line-566"></a>    rotation alpha ds zs <font color=Red>=</font> <font color=Green><u>do</u></font>
<a name="line-567"></a>      <font color=Green><u>case</u></font> zs <font color=Green><u>of</u></font>
<a name="line-568"></a>        [] <font color=Red>-&gt;</font> <font color=Blue><i>-- if there are no Z operators, produce a controlled</i></font>
<a name="line-569"></a>              <font color=Blue><i>-- e^{-i&#945;} gate.</i></font>
<a name="line-570"></a>          <font color=Green><u>case</u></font> ds <font color=Green><u>of</u></font>
<a name="line-571"></a>            [] <font color=Red>-&gt;</font> error <font color=Magenta>"exponentiate_simple: precondition violated"</font>
<a name="line-572"></a>            d<font color=Red><b>:</b></font>ds' <font color=Red>-&gt;</font> gse_T_at alpha <font color=Cyan>(</font>qs <font color=Cyan>!!</font> d<font color=Cyan>)</font> <font color=Cyan>`controlled`</font> <font color=Red>[</font>qs <font color=Cyan>!!</font> d' <font color=Red>|</font> d' <font color=Red>&lt;-</font> ds'<font color=Red>]</font>
<a name="line-573"></a>        z<font color=Red><b>:</b></font>zs' <font color=Red>-&gt;</font> <font color=Blue><i>-- if there are Z operators, produce a controlled</i></font>
<a name="line-574"></a>                 <font color=Blue><i>-- e^{-i&#945;Z} gate.</i></font>
<a name="line-575"></a>          rotZ_at <font color=Cyan>(</font><font color=Magenta>2</font><font color=Cyan>*</font>alpha<font color=Cyan>)</font> <font color=Cyan>(</font>qs <font color=Cyan>!!</font> z<font color=Cyan>)</font> <font color=Cyan>`controlled`</font> <font color=Red>[</font>qs <font color=Cyan>!!</font> d <font color=Red>|</font> d <font color=Red>&lt;-</font> ds<font color=Red>]</font>
<a name="line-576"></a>
<a name="line-577"></a><a name="exponentiate"></a><font color=Blue><i>-- | Given a tensor /H/ (already decomposed into commuting simple</i></font>
<a name="line-578"></a><font color=Blue><i>-- tensors) and an angle &#952;, generate a circuit for [exp -/i/&#952;/H/].</i></font>
<a name="line-579"></a><font color=Blue><i>-- The given list of input qubits is in the same order as the</i></font>
<a name="line-580"></a><font color=Blue><i>-- operators in /H/.</i></font>
<a name="line-581"></a><font color=Blue>exponentiate</font> <font color=Red>::</font> TensorLC <font color=Red>-&gt;</font> Double <font color=Red>-&gt;</font> <font color=Red>[</font>Qubit<font color=Red>]</font> <font color=Red>-&gt;</font> <font color=Red>[</font>Qubit<font color=Red>]</font> <font color=Red>-&gt;</font> Circ ()
<a name="line-582"></a><font color=Blue>exponentiate</font> lc theta qs ctl <font color=Red>=</font>
<a name="line-583"></a>  sequence_ <font color=Red>[</font> exponentiate_simple a theta qs ctl <font color=Red>|</font> a <font color=Red>&lt;-</font> lc_to_list lc <font color=Red>]</font>
<a name="line-584"></a>
<a name="line-585"></a><font color=Blue><i>-- ----------------------------------------------------------------------</i></font>
<a name="line-586"></a><font color=Blue><i>-- * Generate top-level templates</i></font>
<a name="line-587"></a>
<a name="line-588"></a><a name="one_electron_circuit"></a><font color=Blue><i>-- | @'one_electron_circuit' theta p q@: Generate the circuit for the</i></font>
<a name="line-589"></a><font color=Blue><i>-- hermitianized one-electron interaction with spin-orbital indices</i></font>
<a name="line-590"></a><font color=Blue><i>-- /p/, /q/. More precisely, generate [exp -/i/&#952;/H/], where</i></font>
<a name="line-591"></a><font color=Blue><i>-- /H/ = /a/[sub /p/][sup &#8224;]/a/[sub /q/] if /p/ = /q/ and </i></font>
<a name="line-592"></a><font color=Blue><i>-- /H/ = /a/[sub /p/][sup &#8224;]/a/[sub /q/] </i></font>
<a name="line-593"></a><font color=Blue><i>-- + /a/[sub /q/][sup &#8224;]/a/[sub /p/] otherwise.</i></font>
<a name="line-594"></a><font color=Blue><i>-- </i></font>
<a name="line-595"></a><font color=Blue><i>-- This function recognizes an important special case: if &#952;=0.0, don't</i></font>
<a name="line-596"></a><font color=Blue><i>-- generate any gates at all. The case &#952;=0.0 frequently arises because</i></font>
<a name="line-597"></a><font color=Blue><i>-- of the conversion from spatial orbitals to spin orbitals.</i></font>
<a name="line-598"></a><font color=Blue>one_electron_circuit</font> <font color=Red>::</font> Double <font color=Red>-&gt;</font> Int <font color=Red>-&gt;</font> Int <font color=Red>-&gt;</font> <font color=Red>[</font>Qubit<font color=Red>]</font> <font color=Red>-&gt;</font> <font color=Red>[</font>Qubit<font color=Red>]</font> <font color=Red>-&gt;</font> Circ ()
<a name="line-599"></a><font color=Blue>one_electron_circuit</font> <font color=Magenta>0.0</font> p q qs ctl <font color=Red>=</font> return ()
<a name="line-600"></a><font color=Blue>one_electron_circuit</font> theta p q qs ctl <font color=Red>=</font> <font color=Green><u>do</u></font>
<a name="line-601"></a>  comment_with_label <font color=Cyan>(</font>printf <font color=Magenta>"ENTER: one_electron_circuit (theta=%.3e, p=%d, q=%d)"</font> theta p q<font color=Cyan>)</font> <font color=Cyan>(</font>qs<font color=Cyan>,</font>ctl<font color=Cyan>)</font> <font color=Cyan>(</font><font color=Magenta>"qs"</font><font color=Cyan>,</font><font color=Magenta>"ctl"</font><font color=Cyan>)</font>
<a name="line-602"></a>  exponentiate op theta qs ctl
<a name="line-603"></a>  comment_with_label <font color=Magenta>"EXIT: one_electron_circuit"</font> <font color=Cyan>(</font>qs<font color=Cyan>,</font>ctl<font color=Cyan>)</font> <font color=Cyan>(</font><font color=Magenta>"qs"</font><font color=Cyan>,</font><font color=Magenta>"ctl"</font><font color=Cyan>)</font>
<a name="line-604"></a>  <font color=Green><u>where</u></font>
<a name="line-605"></a>    op <font color=Red>=</font> decompose_tensor_lc <font color=Cyan>(</font>one_electron_operator p q<font color=Cyan>)</font>
<a name="line-606"></a>      
<a name="line-607"></a><a name="two_electron_circuit"></a><font color=Blue><i>-- | @'two_electron_circuit' theta p q r s@:</i></font>
<a name="line-608"></a><font color=Blue><i>-- Generate the circuit for the hermitianized two-electron interaction</i></font>
<a name="line-609"></a><font color=Blue><i>-- with spin-orbital indices /p/, /q/, /r/, /s/. More precisely, generate </i></font>
<a name="line-610"></a><font color=Blue><i>-- [exp -/i/&#952;/H/], where </i></font>
<a name="line-611"></a><font color=Blue><i>-- /H/ = /a/[sub /p/][sup &#8224;]/a/[sub /q/][sup &#8224;]/a/[sub /r/]/a/[sub /s/] if </i></font>
<a name="line-612"></a><font color=Blue><i>-- (/p/,/q/) = (/s/,/r/) and /H/ =</i></font>
<a name="line-613"></a><font color=Blue><i>-- /a/[sub /p/][sup &#8224;]/a/[sub /q/][sup &#8224;]/a/[sub /r/]/a/[sub /s/] +</i></font>
<a name="line-614"></a><font color=Blue><i>-- /a/[sub /s/][sup &#8224;]/a/[sub /r/][sup &#8224;]/a/[sub /q/]/a/[sub /p/]</i></font>
<a name="line-615"></a><font color=Blue><i>-- otherwise.</i></font>
<a name="line-616"></a><font color=Blue><i>-- </i></font>
<a name="line-617"></a><font color=Blue><i>-- This function recognizes an important special case: if &#952;=0.0, don't</i></font>
<a name="line-618"></a><font color=Blue><i>-- generate any gates at all. The case &#952;=0.0 frequently arises because</i></font>
<a name="line-619"></a><font color=Blue><i>-- of the conversion from spatial orbitals to spin orbitals.</i></font>
<a name="line-620"></a><font color=Blue>two_electron_circuit</font> <font color=Red>::</font> Double <font color=Red>-&gt;</font> Int <font color=Red>-&gt;</font> Int <font color=Red>-&gt;</font> Int <font color=Red>-&gt;</font> Int <font color=Red>-&gt;</font> <font color=Red>[</font>Qubit<font color=Red>]</font> <font color=Red>-&gt;</font> <font color=Red>[</font>Qubit<font color=Red>]</font> <font color=Red>-&gt;</font> Circ ()
<a name="line-621"></a><font color=Blue>two_electron_circuit</font> <font color=Magenta>0.0</font> p q r s qs ctl <font color=Red>=</font> return ()
<a name="line-622"></a><font color=Blue>two_electron_circuit</font> theta p q r s qs ctl <font color=Red>=</font> <font color=Green><u>do</u></font>
<a name="line-623"></a>  comment_with_label <font color=Cyan>(</font>printf <font color=Magenta>"ENTER: two_electron_circuit (theta=%.3e, p=%d, q=%d, r=%d, s=%d)"</font> theta p q r s<font color=Cyan>)</font> <font color=Cyan>(</font>qs<font color=Cyan>,</font>ctl<font color=Cyan>)</font> <font color=Cyan>(</font><font color=Magenta>"qs"</font><font color=Cyan>,</font><font color=Magenta>"ctl"</font><font color=Cyan>)</font>
<a name="line-624"></a>  exponentiate op theta qs ctl
<a name="line-625"></a>  comment_with_label <font color=Magenta>"EXIT: two_electron_circuit"</font> <font color=Cyan>(</font>qs<font color=Cyan>,</font>ctl<font color=Cyan>)</font> <font color=Cyan>(</font><font color=Magenta>"qs"</font><font color=Cyan>,</font><font color=Magenta>"ctl"</font><font color=Cyan>)</font>
<a name="line-626"></a>  <font color=Green><u>where</u></font>
<a name="line-627"></a>    op <font color=Red>=</font> decompose_tensor_lc <font color=Cyan>(</font>two_electron_operator p q r s<font color=Cyan>)</font>
<a name="line-628"></a>      
<a name="line-629"></a><font color=Blue><i>-- | Like 'two_electron_circuit', but use the \"orthodox\" circuit</i></font>
<a name="line-630"></a><font color=Blue><i>-- template for the Coulomb operator /a/[sub /p/][sup &#8224;]/a/[sub</i></font>
<a name="line-631"></a><font color=Blue><i>-- /q/][sup &#8224;]/a/[sub /q/]/a/[sub /p/]. This generates a circuit using</i></font>
<a name="line-632"></a><font color=Blue><i>-- three rotations, similar to [Whitfield et al.], but with corrected</i></font>
<a name="line-633"></a><font color=Blue><i>-- angles,</i></font>
<a name="line-634"></a><font color=Blue><i>--     </i></font>
<a name="line-635"></a><font color=Blue><i>-- &gt; [image b2-orthodox.png]</i></font>
<a name="line-636"></a><font color=Blue><i>-- </i></font>
<a name="line-637"></a><font color=Blue><i>-- instead of the simpler circuit that 'two_electron_circuit' would</i></font>
<a name="line-638"></a><font color=Blue><i>-- normally generate:</i></font>
<a name="line-639"></a><font color=Blue><i>-- </i></font>
<a name="line-640"></a><font color=Blue><i>-- &gt; [image b2-template.png]</i></font>
<a name="line-641"></a>
<a name="line-642"></a><a name="two_electron_circuit_orthodox"></a><font color=Blue>two_electron_circuit_orthodox</font> <font color=Red>::</font> Double <font color=Red>-&gt;</font> Int <font color=Red>-&gt;</font> Int <font color=Red>-&gt;</font> Int <font color=Red>-&gt;</font> Int <font color=Red>-&gt;</font> <font color=Red>[</font>Qubit<font color=Red>]</font> <font color=Red>-&gt;</font> <font color=Red>[</font>Qubit<font color=Red>]</font> <font color=Red>-&gt;</font> Circ ()
<a name="line-643"></a><font color=Blue>two_electron_circuit_orthodox</font> <font color=Magenta>0.0</font> p q r s qs ctl <font color=Red>=</font> return ()
<a name="line-644"></a><font color=Blue>two_electron_circuit_orthodox</font> theta p q r s qs ctl <font color=Red>|</font> q<font color=Cyan>==</font>r <font color=Cyan>&amp;&amp;</font> p<font color=Cyan>==</font>s <font color=Cyan>&amp;&amp;</font> p<font color=Cyan>/=</font>q <font color=Red>=</font> <font color=Green><u>do</u></font>
<a name="line-645"></a>  comment_with_label <font color=Cyan>(</font>printf <font color=Magenta>"ENTER: two_electron_circuit_orthodox(theta=%.3e, p=%d, q=%d, r=%d, s=%d)"</font> theta p q r s<font color=Cyan>)</font> <font color=Cyan>(</font>qs<font color=Cyan>,</font>ctl<font color=Cyan>)</font> <font color=Cyan>(</font><font color=Magenta>"qs"</font><font color=Cyan>,</font><font color=Magenta>"ctl"</font><font color=Cyan>)</font>
<a name="line-646"></a>  <font color=Green><u>let</u></font> pp <font color=Red>=</font> qs <font color=Cyan>!!</font> p
<a name="line-647"></a>      qq <font color=Red>=</font> qs <font color=Cyan>!!</font> q
<a name="line-648"></a>  gse_G_at <font color=Cyan>(</font>theta<font color=Cyan>/</font><font color=Magenta>4</font><font color=Cyan>)</font> pp <font color=Cyan>`controlled`</font> ctl
<a name="line-649"></a>  rotZ_at <font color=Cyan>(</font><font color=Blue><i>-</i></font>theta<font color=Cyan>/</font><font color=Magenta>2</font><font color=Cyan>)</font> pp <font color=Cyan>`controlled`</font> ctl
<a name="line-650"></a>  rotZ_at <font color=Cyan>(</font><font color=Blue><i>-</i></font>theta<font color=Cyan>/</font><font color=Magenta>2</font><font color=Cyan>)</font> qq <font color=Cyan>`controlled`</font> ctl
<a name="line-651"></a>  qnot_at qq <font color=Cyan>`controlled`</font> pp  <font color=Blue><i>-- control ctl is not needed</i></font>
<a name="line-652"></a>  rotZ_at <font color=Cyan>(</font>theta<font color=Cyan>/</font><font color=Magenta>2</font><font color=Cyan>)</font> qq <font color=Cyan>`controlled`</font> ctl
<a name="line-653"></a>  qnot_at qq <font color=Cyan>`controlled`</font> pp  <font color=Blue><i>-- control ctl is not needed</i></font>
<a name="line-654"></a>  comment_with_label <font color=Magenta>"EXIT: two_electron_circuit_orthodox"</font> <font color=Cyan>(</font>qs<font color=Cyan>,</font>ctl<font color=Cyan>)</font> <font color=Cyan>(</font><font color=Magenta>"qs"</font><font color=Cyan>,</font><font color=Magenta>"ctl"</font><font color=Cyan>)</font>
<a name="line-655"></a>                                                                         
<a name="line-656"></a><font color=Blue><i>-- all other cases aren't Coulomb operators, so fall back to</i></font>
<a name="line-657"></a><font color=Blue><i>-- two_electron_circuit.</i></font>
<a name="line-658"></a><font color=Blue>two_electron_circuit_orthodox</font> theta p q r s qs ctl <font color=Red>=</font> <font color=Green><u>do</u></font>
<a name="line-659"></a>  two_electron_circuit theta p q r s qs ctl
<a name="line-660"></a>  
<a name="line-661"></a><font color=Blue><i>-- ----------------------------------------------------------------------</i></font>
<a name="line-662"></a><font color=Blue><i>-- * Testing</i></font>
<a name="line-663"></a>
<a name="line-664"></a><font color=Blue><i>-- $ We provide two functions, accessible via command line options,</i></font>
<a name="line-665"></a><font color=Blue><i>-- that allow the user to display individual templates. </i></font>
<a name="line-666"></a>
<a name="line-667"></a><a name="show_one_electron"></a><font color=Blue><i>-- | Display the circuit for the hermitianized one-electron interaction,</i></font>
<a name="line-668"></a><font color=Blue><i>-- with &#952;=1.</i></font>
<a name="line-669"></a><font color=Blue>show_one_electron</font> <font color=Red>::</font> Format <font color=Red>-&gt;</font> GateBase <font color=Red>-&gt;</font> Int <font color=Red>-&gt;</font> Int <font color=Red>-&gt;</font> IO ()
<a name="line-670"></a><font color=Blue>show_one_electron</font> format gatebase p q <font color=Red>=</font> 
<a name="line-671"></a>  print_generic format <font color=Cyan>(</font>decompose_generic gatebase circuit<font color=Cyan>)</font> <font color=Cyan>(</font>replicate <font color=Cyan>(</font>n<font color=Blue><i>-</i></font>m<font color=Cyan>)</font> qubit<font color=Cyan>)</font> <font color=Green><u>where</u></font>
<a name="line-672"></a>    circuit qs <font color=Red>=</font> one_electron_circuit <font color=Magenta>1.0</font> <font color=Cyan>(</font>p<font color=Blue><i>-</i></font>m<font color=Cyan>)</font> <font color=Cyan>(</font>q<font color=Blue><i>-</i></font>m<font color=Cyan>)</font> qs []
<a name="line-673"></a>    n <font color=Red>=</font> maximum <font color=Red>[</font>p<font color=Cyan>,</font>q<font color=Red>]</font> <font color=Cyan>+</font> <font color=Magenta>1</font>
<a name="line-674"></a>    m <font color=Red>=</font> minimum <font color=Red>[</font>p<font color=Cyan>,</font>q<font color=Red>]</font>
<a name="line-675"></a>
<a name="line-676"></a><a name="show_two_electron"></a><font color=Blue><i>-- | Display the circuit for the hermitianized two-electron interaction, </i></font>
<a name="line-677"></a><font color=Blue><i>-- with &#952;=1. </i></font>
<a name="line-678"></a><font color=Blue>show_two_electron</font> <font color=Red>::</font> Format <font color=Red>-&gt;</font> GateBase <font color=Red>-&gt;</font> Int <font color=Red>-&gt;</font> Int <font color=Red>-&gt;</font> Int <font color=Red>-&gt;</font> Int <font color=Red>-&gt;</font> IO ()
<a name="line-679"></a><font color=Blue>show_two_electron</font> format gatebase p q r s <font color=Red>=</font> 
<a name="line-680"></a>  print_generic format <font color=Cyan>(</font>decompose_generic gatebase circuit<font color=Cyan>)</font> <font color=Cyan>(</font>replicate <font color=Cyan>(</font>n<font color=Blue><i>-</i></font>m<font color=Cyan>)</font> qubit<font color=Cyan>)</font> <font color=Green><u>where</u></font>
<a name="line-681"></a>    circuit qs <font color=Red>=</font> two_electron_circuit <font color=Magenta>1.0</font> <font color=Cyan>(</font>p<font color=Blue><i>-</i></font>m<font color=Cyan>)</font> <font color=Cyan>(</font>q<font color=Blue><i>-</i></font>m<font color=Cyan>)</font> <font color=Cyan>(</font>r<font color=Blue><i>-</i></font>m<font color=Cyan>)</font> <font color=Cyan>(</font>s<font color=Blue><i>-</i></font>m<font color=Cyan>)</font> qs []
<a name="line-682"></a>    n <font color=Red>=</font> maximum <font color=Red>[</font>p<font color=Cyan>,</font>q<font color=Cyan>,</font>r<font color=Cyan>,</font>s<font color=Red>]</font> <font color=Cyan>+</font> <font color=Magenta>1</font>
<a name="line-683"></a>    m <font color=Red>=</font> minimum <font color=Red>[</font>p<font color=Cyan>,</font>q<font color=Cyan>,</font>r<font color=Cyan>,</font>s<font color=Red>]</font>
<a name="line-684"></a>
<a name="line-685"></a><a name="show_two_electron_orthodox"></a><font color=Blue><i>-- | Like 'show_two_electron', but use the \"orthodox\" template for</i></font>
<a name="line-686"></a><font color=Blue><i>-- the Coulomb operator.</i></font>
<a name="line-687"></a><font color=Blue>show_two_electron_orthodox</font> <font color=Red>::</font> Format <font color=Red>-&gt;</font> GateBase <font color=Red>-&gt;</font> Int <font color=Red>-&gt;</font> Int <font color=Red>-&gt;</font> Int <font color=Red>-&gt;</font> Int <font color=Red>-&gt;</font> IO ()
<a name="line-688"></a><font color=Blue>show_two_electron_orthodox</font> format gatebase p q r s <font color=Red>=</font> 
<a name="line-689"></a>  print_generic format <font color=Cyan>(</font>decompose_generic gatebase circuit<font color=Cyan>)</font> <font color=Cyan>(</font>replicate <font color=Cyan>(</font>n<font color=Blue><i>-</i></font>m<font color=Cyan>)</font> qubit<font color=Cyan>)</font> <font color=Green><u>where</u></font>
<a name="line-690"></a>    circuit qs <font color=Red>=</font> two_electron_circuit_orthodox <font color=Magenta>1.0</font> <font color=Cyan>(</font>p<font color=Blue><i>-</i></font>m<font color=Cyan>)</font> <font color=Cyan>(</font>q<font color=Blue><i>-</i></font>m<font color=Cyan>)</font> <font color=Cyan>(</font>r<font color=Blue><i>-</i></font>m<font color=Cyan>)</font> <font color=Cyan>(</font>s<font color=Blue><i>-</i></font>m<font color=Cyan>)</font> qs []
<a name="line-691"></a>    n <font color=Red>=</font> maximum <font color=Red>[</font>p<font color=Cyan>,</font>q<font color=Cyan>,</font>r<font color=Cyan>,</font>s<font color=Red>]</font> <font color=Cyan>+</font> <font color=Magenta>1</font>
<a name="line-692"></a>    m <font color=Red>=</font> minimum <font color=Red>[</font>p<font color=Cyan>,</font>q<font color=Cyan>,</font>r<font color=Cyan>,</font>s<font color=Red>]</font>
</pre>
</body>
</html>