<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<!-- Generated by HsColour, http://code.haskell.org/~malcolm/hscolour/ -->
<title>Haskell code</title>
</head>
<body>
<pre><a name="line-1"></a><font color=Blue><i>-- | This module implements the classical operations on ideals used in Hallgren&#8217;s</i></font>
<a name="line-2"></a><font color=Blue><i>-- algorithm (including also classical versions of the quantum operations required).</i></font>
<a name="line-3"></a> 
<a name="line-4"></a><font color=Green><u>module</u></font> Algorithms<font color=Cyan>.</font>CL<font color=Cyan>.</font>RegulatorClassical <font color=Green><u>where</u></font>
<a name="line-5"></a>
<a name="line-6"></a><font color=Green><u>import</u></font> Data<font color=Cyan>.</font>Maybe
<a name="line-7"></a>
<a name="line-8"></a><font color=Green><u>import</u></font> QuipperLib<font color=Cyan>.</font>Arith
<a name="line-9"></a><font color=Green><u>import</u></font> QuipperLib<font color=Cyan>.</font>FPReal
<a name="line-10"></a>
<a name="line-11"></a><font color=Green><u>import</u></font> Algorithms<font color=Cyan>.</font>CL<font color=Cyan>.</font>Auxiliary
<a name="line-12"></a><font color=Green><u>import</u></font> Algorithms<font color=Cyan>.</font>CL<font color=Cyan>.</font>Types
<a name="line-13"></a>
<a name="line-14"></a><font color=Blue><i>-- ======================================================================</i></font>
<a name="line-15"></a><font color=Blue><i>-- * Basic operations on ideals</i></font>
<a name="line-16"></a>
<a name="line-17"></a><a name="unit_ideal"></a><font color=Blue><i>-- | @'unit_ideal' /bigD/ /l/@: the unit ideal /O/, for &#916; = /bigD/, with the ideal&#8217;s coefficients given as /l/-bit integers.  </i></font>
<a name="line-18"></a><font color=Blue><i>-- ([Jozsa 2003], Prop. 14.)</i></font>
<a name="line-19"></a><font color=Blue>unit_ideal</font> <font color=Red>::</font> CLIntP <font color=Red>-&gt;</font> Ideal
<a name="line-20"></a><font color=Blue>unit_ideal</font> <font color=Red>=</font> forget_reduced <font color=Cyan>.</font> unit_idealRed 
<a name="line-21"></a>
<a name="line-22"></a><a name="unit_idealRed"></a><font color=Blue><i>-- | Like 'unit_ideal', but considered as a reduced ideal.</i></font>
<a name="line-23"></a><font color=Blue>unit_idealRed</font> <font color=Red>::</font> CLIntP <font color=Red>-&gt;</font> IdealRed
<a name="line-24"></a><font color=Blue>unit_idealRed</font> bigD <font color=Red>=</font> assert <font color=Cyan>(</font>is_valid_bigD bigD<font color=Cyan>)</font> <font color=Cyan>(</font><font color=Magenta>"unit_idealRed: "</font> <font color=Cyan>++</font> show bigD <font color=Cyan>++</font> <font color=Magenta>" not valid discriminant"</font><font color=Cyan>)</font> 
<a name="line-25"></a>                  <font color=Cyan>$</font> IdealRed bigD <font color=Magenta>1</font> <font color=Cyan>(</font>tau bigD <font color=Cyan>(</font>fromIntegral bigD<font color=Cyan>)</font> <font color=Magenta>1</font><font color=Cyan>)</font>
<a name="line-26"></a>
<a name="line-27"></a><a name="c_of_ideal"></a><font color=Blue><i>-- | The integer constant /c/ of an ideal.</i></font>
<a name="line-28"></a><font color=Blue><i>--   ([Jozsa 2003], page 14 bottom: \"Since 4/a/ divides /b/[sup 2]-/D/</i></font>
<a name="line-29"></a><font color=Blue><i>--   (cf. proposition 16) we introduce the integer /c/ = |/D/ &#8722; /b/[sup 2]|\/(4/a/)\")</i></font>
<a name="line-30"></a><font color=Blue>c_of_ideal</font> <font color=Red>::</font> Ideal <font color=Red>-&gt;</font> CLInt
<a name="line-31"></a><font color=Blue>c_of_ideal</font> i<font color=Red>@</font><font color=Cyan>(</font>Ideal bigD m l a b<font color=Cyan>)</font> <font color=Red>=</font>
<a name="line-32"></a>    <font color=Green><u>if</u></font> <font color=Cyan>(</font>num <font color=Cyan>`mod`</font> denom <font color=Cyan>==</font> <font color=Magenta>0</font><font color=Cyan>)</font> <font color=Green><u>then</u></font> num <font color=Cyan>`div`</font> denom
<a name="line-33"></a>                              <font color=Green><u>else</u></font> error error_string
<a name="line-34"></a>    <font color=Green><u>where</u></font> num   <font color=Red>=</font> abs <font color=Cyan>(</font><font color=Cyan>(</font>fromIntegral bigD<font color=Cyan>)</font> <font color=Blue><i>-</i></font> b<font color=Cyan>*</font>b<font color=Cyan>)</font>
<a name="line-35"></a>          denom <font color=Red>=</font> <font color=Magenta>4</font><font color=Cyan>*</font>a
<a name="line-36"></a>          error_string <font color=Red>=</font> <font color=Magenta>"rho of ideal ["</font> <font color=Cyan>++</font> show i <font color=Cyan>++</font> <font color=Magenta>"] produces non-integer c"</font>
<a name="line-37"></a>
<a name="line-38"></a><a name="gamma_of_ideal"></a><font color=Blue><i>-- | &#947;(/I/) = (/b/+&#8730;&#916;)\/(2/a/) for a given ideal /I/.</i></font>
<a name="line-39"></a><font color=Blue><i>--   ([Jozsa 2003], Sec. 6.2.)</i></font>
<a name="line-40"></a><font color=Blue>gamma_of_ideal</font> <font color=Red>::</font> Ideal <font color=Red>-&gt;</font> AlgNum
<a name="line-41"></a><font color=Blue>gamma_of_ideal</font> <font color=Cyan>(</font>Ideal bigD m l a b<font color=Cyan>)</font> <font color=Red>=</font> AlgNum a' b' bigD
<a name="line-42"></a>    <font color=Green><u>where</u></font>
<a name="line-43"></a>        a' <font color=Red>=</font> <font color=Cyan>(</font>fromIntegral b <font color=Cyan>/</font> fromIntegral <font color=Cyan>(</font><font color=Magenta>2</font><font color=Cyan>*</font>a<font color=Cyan>)</font><font color=Cyan>)</font> <font color=Red>::</font> CLRational
<a name="line-44"></a>        b' <font color=Red>=</font> <font color=Cyan>(</font>fromIntegral <font color=Magenta>1</font> <font color=Cyan>/</font> fromIntegral <font color=Cyan>(</font><font color=Magenta>2</font><font color=Cyan>*</font>a<font color=Cyan>)</font><font color=Cyan>)</font> <font color=Red>::</font> CLRational
<a name="line-45"></a>  <font color=Blue><i>-- Recall: @'AlgNum' u v bigD@ represents (u + v * &#8730;bigD).</i></font>
<a name="line-46"></a>
<a name="line-47"></a><a name="rho"></a><font color=Blue><i>-- | The reduction function &#961; on ideals.</i></font>
<a name="line-48"></a><font color=Blue><i>-- ([Jozsa 2003], Sec. 6.2.)</i></font>
<a name="line-49"></a><font color=Blue>rho</font> <font color=Red>::</font> Ideal <font color=Red>-&gt;</font> Ideal
<a name="line-50"></a><font color=Blue>rho</font> ii<font color=Red>@</font><font color=Cyan>(</font>Ideal bigD m l a b<font color=Cyan>)</font> <font color=Red>=</font> <font color=Cyan>(</font>Ideal bigD m'' l'' a' b'<font color=Cyan>)</font>
<a name="line-51"></a>    <font color=Green><u>where</u></font>
<a name="line-52"></a>        <font color=Blue><i>-- With little algebra, one can derive these:</i></font>
<a name="line-53"></a>        m'   <font color=Red>=</font> m <font color=Cyan>*</font> a
<a name="line-54"></a>        l'   <font color=Red>=</font> l <font color=Cyan>*</font> a'
<a name="line-55"></a>        m''  <font color=Red>=</font> m' <font color=Cyan>`div`</font> <font color=Cyan>(</font>gcd m' l'<font color=Cyan>)</font>
<a name="line-56"></a>        l''  <font color=Red>=</font> l' <font color=Cyan>`div`</font> <font color=Cyan>(</font>gcd m' l'<font color=Cyan>)</font>
<a name="line-57"></a>        <font color=Blue><i>-- From  [Jozsa 2003], p.15, equation (10)</i></font>
<a name="line-58"></a>        a'   <font color=Red>=</font> c_of_ideal ii
<a name="line-59"></a>        b'   <font color=Red>=</font> tau bigD <font color=Cyan>(</font><font color=Blue><i>-</i></font>b<font color=Cyan>)</font> a'
<a name="line-60"></a>
<a name="line-61"></a><a name="rho_inv"></a><font color=Blue><i>-- | The &#961;[sup -1] function on ideals.  Inverse to 'rho'.</i></font>
<a name="line-62"></a><font color=Blue><i>-- ([Jozsa 2003], Sec. 6.4.)</i></font>
<a name="line-63"></a><font color=Blue>rho_inv</font> <font color=Red>::</font> Ideal <font color=Red>-&gt;</font> Ideal
<a name="line-64"></a><font color=Blue>rho_inv</font> <font color=Cyan>(</font>Ideal bigD m l a b<font color=Cyan>)</font> <font color=Red>=</font> <font color=Cyan>(</font>Ideal bigD m'' l'' a'' b''<font color=Cyan>)</font>
<a name="line-65"></a>    <font color=Green><u>where</u></font>
<a name="line-66"></a>        <font color=Blue><i>-- Create m and l</i></font>
<a name="line-67"></a>        m'    <font color=Red>=</font> m <font color=Cyan>*</font> a
<a name="line-68"></a>        l'    <font color=Red>=</font> l <font color=Cyan>*</font> a''
<a name="line-69"></a>        <font color=Blue><i>-- Reduce them to have no common denominator</i></font>
<a name="line-70"></a>        m''   <font color=Red>=</font> m' <font color=Cyan>`div`</font> <font color=Cyan>(</font>gcd m' l'<font color=Cyan>)</font>
<a name="line-71"></a>        l''   <font color=Red>=</font> l' <font color=Cyan>`div`</font> <font color=Cyan>(</font>gcd m' l'<font color=Cyan>)</font>
<a name="line-72"></a>        <font color=Blue><i>-- Calculate b* (b' below)</i></font>
<a name="line-73"></a>        b'    <font color=Red>=</font> tau bigD <font color=Cyan>(</font><font color=Blue><i>-</i></font>b<font color=Cyan>)</font> a
<a name="line-74"></a>        <font color=Blue><i>-- Calculate new a and b</i></font>
<a name="line-75"></a>        a''   <font color=Red>=</font> <font color=Cyan>(</font><font color=Cyan>(</font>fromIntegral bigD<font color=Cyan>)</font> <font color=Blue><i>-</i></font> b'<font color=Cyan>*</font>b'<font color=Cyan>)</font> <font color=Cyan>`divchk`</font> <font color=Cyan>(</font><font color=Magenta>4</font><font color=Cyan>*</font>a<font color=Cyan>)</font>
<a name="line-76"></a>        b''   <font color=Red>=</font> tau bigD b' a''
<a name="line-77"></a>
<a name="line-78"></a><a name="rho_red"></a><font color=Blue><i>-- | The &#961; operation on reduced ideals.</i></font>
<a name="line-79"></a><font color=Blue>rho_red</font> <font color=Red>::</font> IdealRed <font color=Red>-&gt;</font> IdealRed
<a name="line-80"></a><font color=Blue>rho_red</font> <font color=Red>=</font> to_reduced <font color=Cyan>.</font> rho <font color=Cyan>.</font> forget_reduced
<a name="line-81"></a>
<a name="line-82"></a><a name="rho_inv_red"></a><font color=Blue><i>-- | The &#961;[sup &#8211;1] operation on reduced ideals.</i></font>
<a name="line-83"></a><font color=Blue>rho_inv_red</font> <font color=Red>::</font> IdealRed <font color=Red>-&gt;</font> IdealRed
<a name="line-84"></a><font color=Blue>rho_inv_red</font> <font color=Red>=</font> to_reduced <font color=Cyan>.</font> rho_inv <font color=Cyan>.</font> forget_reduced
<a name="line-85"></a>
<a name="line-86"></a><a name="rho_d"></a><font color=Blue><i>-- | The &#961; operation on ideals-with-distance.</i></font>
<a name="line-87"></a><font color=Blue>rho_d</font> <font color=Red>::</font> IdDist <font color=Red>-&gt;</font> IdDist
<a name="line-88"></a><font color=Blue>rho_d</font> <font color=Cyan>(</font>ii<font color=Cyan>,</font> del<font color=Cyan>)</font> <font color=Red>=</font> <font color=Cyan>(</font>rho ii<font color=Cyan>,</font> del <font color=Cyan>+</font> del_change<font color=Cyan>)</font>
<a name="line-89"></a>  <font color=Green><u>where</u></font>
<a name="line-90"></a>    gamma <font color=Red>=</font> gamma_of_ideal ii
<a name="line-91"></a>    gamma_bar_by_gamma <font color=Red>=</font> <font color=Cyan>(</font>floating_of_AlgNum <font color=Cyan>$</font> conjugate gamma<font color=Cyan>)</font> <font color=Cyan>/</font> <font color=Cyan>(</font>floating_of_AlgNum gamma<font color=Cyan>)</font>
<a name="line-92"></a>    del_change <font color=Red>=</font> <font color=Cyan>(</font>log <font color=Cyan>$</font> abs gamma_bar_by_gamma<font color=Cyan>)</font> <font color=Cyan>/</font> <font color=Magenta>2</font>
<a name="line-93"></a>
<a name="line-94"></a><a name="rho_inv_d"></a><font color=Blue><i>-- | The &#961;[sup &#8211;1] operation on ideals-with-distance.</i></font>
<a name="line-95"></a><font color=Blue>rho_inv_d</font> <font color=Red>::</font> IdDist <font color=Red>-&gt;</font> IdDist
<a name="line-96"></a><font color=Blue>rho_inv_d</font> <font color=Cyan>(</font>ii<font color=Cyan>,</font> del<font color=Cyan>)</font> <font color=Red>=</font> <font color=Cyan>(</font>ii'<font color=Cyan>,</font> del <font color=Blue><i>-</i></font> del_change<font color=Cyan>)</font>
<a name="line-97"></a>  <font color=Green><u>where</u></font>
<a name="line-98"></a>    ii' <font color=Red>=</font> rho_inv ii
<a name="line-99"></a>    gamma <font color=Red>=</font> gamma_of_ideal ii'
<a name="line-100"></a>    gamma_bar_by_gamma <font color=Red>=</font> <font color=Cyan>(</font>floating_of_AlgNum <font color=Cyan>$</font> conjugate gamma<font color=Cyan>)</font> <font color=Cyan>/</font> <font color=Cyan>(</font>floating_of_AlgNum gamma<font color=Cyan>)</font>
<a name="line-101"></a>    del_change <font color=Red>=</font> <font color=Cyan>(</font>log <font color=Cyan>$</font> abs gamma_bar_by_gamma<font color=Cyan>)</font> <font color=Cyan>/</font> <font color=Magenta>2</font>
<a name="line-102"></a>
<a name="line-103"></a><a name="rho_num"></a><font color=Blue><i>-- | The &#961; operation on ideals-with-generator (i.e. pairs of an ideal /I/ and an 'AlgNum' /x/ such that /I/ is the principal ideal (/x/)).</i></font>
<a name="line-104"></a><font color=Blue>rho_num</font> <font color=Red>::</font> <font color=Cyan>(</font>Ideal<font color=Cyan>,</font>AlgNum<font color=Cyan>)</font> <font color=Red>-&gt;</font> <font color=Cyan>(</font>Ideal<font color=Cyan>,</font>AlgNum<font color=Cyan>)</font>
<a name="line-105"></a><font color=Blue>rho_num</font> <font color=Cyan>(</font>ii<font color=Cyan>,</font> gen<font color=Cyan>)</font> <font color=Red>=</font> <font color=Cyan>(</font>rho ii<font color=Cyan>,</font> gen <font color=Cyan>/</font> <font color=Cyan>(</font>gamma_of_ideal ii<font color=Cyan>)</font><font color=Cyan>)</font>
<a name="line-106"></a>
<a name="line-107"></a><a name="rho_red_num"></a><font color=Blue><i>-- | Apply &#961; to an reduced-ideals-with-generator</i></font>
<a name="line-108"></a><font color=Blue>rho_red_num</font> <font color=Red>::</font> <font color=Cyan>(</font>IdealRed<font color=Cyan>,</font>AlgNum<font color=Cyan>)</font> <font color=Red>-&gt;</font> <font color=Cyan>(</font>IdealRed<font color=Cyan>,</font>AlgNum<font color=Cyan>)</font>
<a name="line-109"></a><font color=Blue>rho_red_num</font> <font color=Cyan>(</font>ii<font color=Cyan>,</font> gen<font color=Cyan>)</font> <font color=Red>=</font> <font color=Cyan>(</font>rho_red ii<font color=Cyan>,</font> gen <font color=Cyan>/</font> <font color=Cyan>(</font>gamma_of_ideal <font color=Cyan>$</font> forget_reduced ii<font color=Cyan>)</font><font color=Cyan>)</font>
<a name="line-110"></a>
<a name="line-111"></a><font color=Blue><i>-- ======================================================================</i></font>
<a name="line-112"></a><font color=Blue><i>-- * Ideal reductions (bounded)</i></font>
<a name="line-113"></a>
<a name="line-114"></a><a name="reduce"></a><font color=Blue><i>-- | Reduce an ideal, by repeatedly applying &#961;.</i></font>
<a name="line-115"></a><font color=Blue>reduce</font> <font color=Red>::</font> Ideal <font color=Red>-&gt;</font> IdealRed
<a name="line-116"></a><font color=Blue>reduce</font> ii <font color=Red>=</font> to_reduced <font color=Cyan>$</font> while <font color=Cyan>(</font>not <font color=Cyan>.</font> is_reduced<font color=Cyan>)</font> rho ii
<a name="line-117"></a>
<a name="line-118"></a><a name="bounded_reduce"></a><font color=Blue><i>-- | Reduce an ideal within a bounded loop. Applies the &#961; function</i></font>
<a name="line-119"></a><font color=Blue><i>--   until the ideal is reduced. Used in 'star' and 'fJN' algorithms.</i></font>
<a name="line-120"></a><font color=Blue>bounded_reduce</font> <font color=Red>::</font> IdDist <font color=Red>-&gt;</font> IdDist
<a name="line-121"></a><font color=Blue>bounded_reduce</font> k<font color=Red>@</font><font color=Cyan>(</font>ideal<font color=Red>@</font><font color=Cyan>(</font>Ideal bigD m l a b<font color=Cyan>)</font><font color=Cyan>,</font>dist<font color=Cyan>)</font> <font color=Red>=</font> 
<a name="line-122"></a>    fst <font color=Cyan>$</font> bounded_while condition bound func <font color=Cyan>(</font>k<font color=Cyan>,</font><font color=Magenta>0</font><font color=Cyan>)</font>
<a name="line-123"></a>    <font color=Green><u>where</u></font>
<a name="line-124"></a>        <font color=Blue><i>-- NOTE: some uncertainty regarding loop bound.</i></font>
<a name="line-125"></a>        bound             <font color=Red>=</font> ceiling <font color=Cyan>$</font> bound_log <font color=Cyan>+</font> <font color=Magenta>1</font>
<a name="line-126"></a>        bound_log         <font color=Red>=</font> <font color=Cyan>(</font>logBase <font color=Magenta>2</font> <font color=Cyan>(</font><font color=Cyan>(</font>fromIntegral bound_a<font color=Cyan>)</font> 
<a name="line-127"></a>                            <font color=Cyan>/</font> <font color=Cyan>(</font>sqrt <font color=Cyan>$</font> fromIntegral <font color=Cyan>$</font> bigD_of_Ideal <font color=Cyan>$</font> ideal<font color=Cyan>)</font><font color=Cyan>)</font><font color=Cyan>)</font>
<a name="line-128"></a>        bound_a           <font color=Red>=</font> <font color=Magenta>2</font> <font color=Cyan>^</font> <font color=Cyan>(</font>fromJust <font color=Cyan>(</font>intm_length <font color=Cyan>$</font> a<font color=Cyan>)</font><font color=Cyan>)</font>
<a name="line-129"></a>
<a name="line-130"></a>        condition <font color=Cyan>(</font>k<font color=Cyan>,</font>itr<font color=Cyan>)</font> <font color=Red>=</font> not <font color=Cyan>$</font> is_reduced <font color=Cyan>$</font> fst k
<a name="line-131"></a>        func      <font color=Cyan>(</font>k<font color=Cyan>,</font>itr<font color=Cyan>)</font> <font color=Red>=</font> <font color=Cyan>(</font><font color=Cyan>(</font>rho_d k<font color=Cyan>)</font><font color=Cyan>,</font><font color=Cyan>(</font>itr<font color=Cyan>+</font><font color=Magenta>1</font><font color=Cyan>)</font><font color=Cyan>)</font>
<a name="line-132"></a>
<a name="line-133"></a><a name="bounded_step"></a><font color=Blue><i>-- | Apply a function (like &#961;,&#961;[sup -1],&#961;[sup 2]) to an ideal, bounded</i></font>
<a name="line-134"></a><font color=Blue><i>--   by 3*ln(&#916;)\/2*ln(2). Execute while satisfies condition function.</i></font>
<a name="line-135"></a><font color=Blue>bounded_step</font> <font color=Red>::</font> <font color=Cyan>(</font>IdDist <font color=Red>-&gt;</font> Bool<font color=Cyan>)</font> <font color=Red>-&gt;</font> <font color=Cyan>(</font>IdDist <font color=Red>-&gt;</font> IdDist<font color=Cyan>)</font> <font color=Red>-&gt;</font> IdDist <font color=Red>-&gt;</font> IdDist
<a name="line-136"></a><font color=Blue>bounded_step</font> condition step_function ideal <font color=Red>=</font>
<a name="line-137"></a>    <font color=Blue><i>-- Execute a bounded while loop</i></font>
<a name="line-138"></a>    bounded_while condition bound step_function ideal
<a name="line-139"></a>    <font color=Green><u>where</u></font>
<a name="line-140"></a>        bound <font color=Red>=</font> ceiling <font color=Cyan>$</font> <font color=Cyan>(</font><font color=Magenta>3</font> <font color=Cyan>*</font> <font color=Cyan>(</font>log <font color=Cyan>$</font> fromIntegral <font color=Cyan>$</font> bigD_of_Ideal <font color=Cyan>$</font> fst ideal<font color=Cyan>)</font><font color=Cyan>)</font> <font color=Cyan>/</font> <font color=Cyan>(</font><font color=Magenta>2</font> <font color=Cyan>*</font> log <font color=Magenta>2</font><font color=Cyan>)</font>
<a name="line-141"></a>
<a name="line-142"></a><a name="bounded_step_delta"></a><font color=Blue><i>-- | Like 'bounded_step', but the condition is checked against delta of the</i></font>
<a name="line-143"></a><font color=Blue><i>--   current ideal.</i></font>
<a name="line-144"></a><font color=Blue>bounded_step_delta</font> <font color=Red>::</font> <font color=Cyan>(</font>CLReal <font color=Red>-&gt;</font> Bool<font color=Cyan>)</font> <font color=Red>-&gt;</font> <font color=Cyan>(</font>IdDist <font color=Red>-&gt;</font> IdDist<font color=Cyan>)</font> <font color=Red>-&gt;</font> IdDist <font color=Red>-&gt;</font> IdDist
<a name="line-145"></a><font color=Blue>bounded_step_delta</font> condition step_function ideal <font color=Red>=</font>
<a name="line-146"></a>    bounded_step new_condition step_function ideal
<a name="line-147"></a>    <font color=Green><u>where</u></font> new_condition <font color=Red>=</font> <font color=Cyan>(</font><font color=Red>\</font>k <font color=Red>-&gt;</font> condition <font color=Cyan>(</font>delta k<font color=Cyan>)</font><font color=Cyan>)</font>
<a name="line-148"></a>
<a name="line-149"></a><font color=Blue><i>-- ======================================================================</i></font>
<a name="line-150"></a><font color=Blue><i>-- * Products of ideals</i></font>
<a name="line-151"></a>
<a name="line-152"></a><font color=Blue><i>-- | The ordinary (not necessarily reduced) product of two reduced fractional ideals.</i></font>
<a name="line-153"></a><font color=Blue><i>-- </i></font>
<a name="line-154"></a><font color=Blue><i>-- /I/&#8901;/J/ of [Jozsa 2003], Sec 7.1, following the description</i></font>
<a name="line-155"></a><font color=Blue><i>-- given in Prop. 34.</i></font>
<a name="line-156"></a>
<a name="line-157"></a><a name="dot"></a><font color=Blue><i>-- NOTE: assumes I, J reduced.  Type should reflect this!</i></font>
<a name="line-158"></a><font color=Blue>dot</font> <font color=Red>::</font> IdDist <font color=Red>-&gt;</font> IdDist <font color=Red>-&gt;</font> IdDist
<a name="line-159"></a><font color=Blue>dot</font> i1<font color=Red>@</font><font color=Cyan>(</font>Ideal bigD1 m1 l1 a1 b1<font color=Cyan>,</font> delta1<font color=Cyan>)</font> i2<font color=Red>@</font><font color=Cyan>(</font>Ideal bigD2 m2 l2 a2 b2<font color=Cyan>,</font> delta2<font color=Cyan>)</font> <font color=Red>=</font>
<a name="line-160"></a>    assert_reduced <font color=Cyan>(</font>fst i1<font color=Cyan>)</font> <font color=Cyan>$</font>
<a name="line-161"></a>        assert_reduced <font color=Cyan>(</font>fst i2<font color=Cyan>)</font> <font color=Cyan>$</font>
<a name="line-162"></a>            <font color=Cyan>(</font>Ideal bigD1 m l a3 b3<font color=Cyan>,</font> del<font color=Cyan>)</font>
<a name="line-163"></a>    <font color=Green><u>where</u></font>
<a name="line-164"></a>        sqrtd <font color=Red>::</font> CLReal
<a name="line-165"></a>        sqrtd <font color=Red>=</font> sqrt <font color=Cyan>(</font>fromIntegral bigD1<font color=Cyan>)</font>
<a name="line-166"></a>        <font color=Cyan>(</font>k'<font color=Cyan>,</font> u'<font color=Cyan>,</font> v'<font color=Cyan>)</font> <font color=Red>=</font> extended_euclid a1 a2
<a name="line-167"></a>        <font color=Cyan>(</font>k<font color=Cyan>,</font>  x<font color=Cyan>,</font>  w <font color=Cyan>)</font> <font color=Red>=</font> extended_euclid k' <font color=Cyan>(</font><font color=Cyan>(</font>b1 <font color=Cyan>+</font> b2<font color=Cyan>)</font> <font color=Cyan>`divchk`</font> <font color=Magenta>2</font><font color=Cyan>)</font>
<a name="line-168"></a>        a3 <font color=Red>=</font> <font color=Cyan>(</font>a1 <font color=Cyan>*</font> a2<font color=Cyan>)</font> <font color=Cyan>`divchk`</font> <font color=Cyan>(</font>k <font color=Cyan>*</font> k<font color=Cyan>)</font>
<a name="line-169"></a>        t1 <font color=Red>=</font> x <font color=Cyan>*</font> u' <font color=Cyan>*</font> a1 <font color=Cyan>*</font> b2
<a name="line-170"></a>        t2 <font color=Red>=</font> x <font color=Cyan>*</font> v' <font color=Cyan>*</font> a2 <font color=Cyan>*</font> b1
<a name="line-171"></a>        t3 <font color=Red>=</font> w<font color=Cyan>*</font><font color=Cyan>(</font>b1 <font color=Cyan>*</font> b2 <font color=Cyan>+</font> <font color=Cyan>(</font>fromIntegral bigD1<font color=Cyan>)</font><font color=Cyan>)</font> <font color=Cyan>`divchk`</font> <font color=Magenta>2</font>
<a name="line-172"></a>        t  <font color=Red>=</font> <font color=Cyan>(</font>t1 <font color=Cyan>+</font> t2 <font color=Cyan>+</font> t3<font color=Cyan>)</font> <font color=Cyan>`divchk`</font> k
<a name="line-173"></a>        b3 <font color=Red>=</font> tau bigD1 t a3
<a name="line-174"></a>        m <font color=Red>=</font> k
<a name="line-175"></a>        l <font color=Red>=</font> a3
<a name="line-176"></a>        del <font color=Red>=</font> <font color=Cyan>(</font><font color=Cyan>(</font>delta i1<font color=Cyan>)</font> <font color=Cyan>+</font> <font color=Cyan>(</font>delta i2<font color=Cyan>)</font><font color=Cyan>)</font>
<a name="line-177"></a>
<a name="line-178"></a><a name="dot'"></a><font color=Blue><i>-- | The dot-square /I/&#8901;/I/ of an ideal-with-distance /I/.</i></font>
<a name="line-179"></a><font color=Blue>dot'</font> <font color=Red>::</font> IdDist <font color=Red>-&gt;</font> IdDist
<a name="line-180"></a><font color=Blue>dot'</font> i1<font color=Red>@</font><font color=Cyan>(</font>Ideal bigD1 m1 l1 a1 b1<font color=Cyan>,</font> delta1<font color=Cyan>)</font> <font color=Red>=</font>
<a name="line-181"></a>    assert_reduced <font color=Cyan>(</font>fst i1<font color=Cyan>)</font> <font color=Cyan>$</font>
<a name="line-182"></a>            <font color=Cyan>(</font>Ideal bigD1 m l a3 b3<font color=Cyan>,</font> del<font color=Cyan>)</font>
<a name="line-183"></a>    <font color=Green><u>where</u></font>
<a name="line-184"></a>        sqrtd <font color=Red>::</font> CLReal
<a name="line-185"></a>        sqrtd <font color=Red>=</font> sqrt <font color=Cyan>(</font>fromIntegral bigD1<font color=Cyan>)</font>
<a name="line-186"></a>        <font color=Cyan>(</font>k<font color=Cyan>,</font> u<font color=Cyan>,</font> w<font color=Cyan>)</font> <font color=Red>=</font> extended_euclid <font color=Cyan>(</font>abs a1<font color=Cyan>)</font> <font color=Cyan>(</font>abs b1<font color=Cyan>)</font>
<a name="line-187"></a>        a3 <font color=Red>=</font> <font color=Cyan>(</font>a1 <font color=Cyan>*</font> a1<font color=Cyan>)</font> <font color=Cyan>`divchk`</font> <font color=Cyan>(</font>k <font color=Cyan>*</font> k<font color=Cyan>)</font>
<a name="line-188"></a>        t1 <font color=Red>=</font> u <font color=Cyan>*</font> a1 <font color=Cyan>*</font> b1
<a name="line-189"></a>        t3 <font color=Red>=</font> w<font color=Cyan>*</font><font color=Cyan>(</font>b1 <font color=Cyan>*</font> b1 <font color=Cyan>+</font> <font color=Cyan>(</font>fromIntegral bigD1<font color=Cyan>)</font><font color=Cyan>)</font> <font color=Cyan>`divchk`</font> <font color=Magenta>2</font>
<a name="line-190"></a>        t  <font color=Red>=</font> <font color=Cyan>(</font>t1 <font color=Cyan>+</font> t3<font color=Cyan>)</font> <font color=Cyan>`divchk`</font> k
<a name="line-191"></a>        b3 <font color=Red>=</font> tau bigD1 t a3
<a name="line-192"></a>        m <font color=Red>=</font> k
<a name="line-193"></a>        <font color=Blue><i>-- l = a3</i></font>
<a name="line-194"></a>        l <font color=Red>=</font> <font color=Magenta>1</font>
<a name="line-195"></a>        del <font color=Red>=</font> <font color=Cyan>(</font><font color=Cyan>(</font>delta i1<font color=Cyan>)</font> <font color=Cyan>+</font> <font color=Cyan>(</font>delta i1<font color=Cyan>)</font><font color=Cyan>)</font>
<a name="line-196"></a>
<a name="line-197"></a><font color=Blue><i>-- | The star-product of two ideals-with-distance.</i></font>
<a name="line-198"></a><font color=Blue><i>--</i></font>
<a name="line-199"></a><font color=Blue><i>-- This is /I/*/J/ of [Jozsa 2003], Sec. 7.1, defined as the first reduced</i></font>
<a name="line-200"></a><font color=Blue><i>-- ideal-with-distance following /I/&#8901;/J/.</i></font>
<a name="line-201"></a>
<a name="line-202"></a><a name="star"></a><font color=Blue><i>-- NOTE: assumes I, J reduced.  Type should reflect this!</i></font>
<a name="line-203"></a><font color=Blue>star</font> <font color=Red>::</font> IdDist <font color=Red>-&gt;</font> IdDist <font color=Red>-&gt;</font> IdDist
<a name="line-204"></a><font color=Blue>star</font> i j <font color=Red>=</font>
<a name="line-205"></a>    <font color=Green><u>if</u></font> <font color=Cyan>(</font>delta k1 <font color=Cyan>&lt;=</font> delta i_dot_j<font color=Cyan>)</font>
<a name="line-206"></a>        <font color=Green><u>then</u></font>       bounded_step_delta <font color=Cyan>(</font><font color=Cyan>&lt;=</font> delta i_dot_j<font color=Cyan>)</font> rho_d k1
<a name="line-207"></a>        <font color=Green><u>else</u></font> rho_d <font color=Cyan>$</font> bounded_step_delta <font color=Cyan>(</font><font color=Cyan>&gt;=</font> delta i_dot_j<font color=Cyan>)</font> rho_inv_d k1
<a name="line-208"></a>    <font color=Green><u>where</u></font>
<a name="line-209"></a>        i_dot_j <font color=Red>=</font> i <font color=Cyan>`dot`</font> j
<a name="line-210"></a>        <font color=Blue><i>-- FIX: Over bound (infinite loop) in reducing the following:</i></font>
<a name="line-211"></a>        <font color=Blue><i>--      &lt;m:1 l:3 a:3 b:2 bigD:28 del:1.1&gt;*&lt;m:1 l:3 a:3 b:4 bigD:28 del:1.6&gt;</i></font>
<a name="line-212"></a>        k1      <font color=Red>=</font> bounded_reduce i_dot_j
<a name="line-213"></a>
<a name="line-214"></a><font color=Blue><i>-- ======================================================================</i></font>
<a name="line-215"></a><font color=Blue><i>-- * The function f[sub /N/], and variants</i></font>
<a name="line-216"></a>
<a name="line-217"></a><a name="compute_injl"></a><font color=Blue><i>-- | Compute the expression i\/N + j\/L.</i></font>
<a name="line-218"></a><font color=Blue>compute_injl</font> <font color=Red>::</font> <font color=Cyan>(</font>Integral int<font color=Cyan>)</font> <font color=Red>=&gt;</font> CLInt <font color=Red>-&gt;</font> int <font color=Red>-&gt;</font> CLInt <font color=Red>-&gt;</font> int <font color=Red>-&gt;</font> CLReal
<a name="line-219"></a><font color=Blue>compute_injl</font> i nn j ll <font color=Red>=</font>
<a name="line-220"></a>    <font color=Cyan>(</font>fromIntegral i<font color=Cyan>)</font><font color=Cyan>/</font><font color=Cyan>(</font>fromIntegral nn<font color=Cyan>)</font> <font color=Cyan>+</font> <font color=Cyan>(</font>fromIntegral j<font color=Cyan>)</font><font color=Cyan>/</font><font color=Cyan>(</font>fromIntegral ll<font color=Cyan>)</font>
<a name="line-221"></a>
<a name="line-222"></a><a name="fN"></a><font color=Blue><i>-- |  @'fN' /i/ /j/ /n/ /l/ &#916;@: find the minimal ideal-with-distance (/J/,&#948;[sub /J/]) such that &#948;[sub /J/] &gt; /x/, where /x/ = /i/\//N/ + /j/\//L/, where /N/ = 2[sup /n/], /L/ = 2[sup /l/]. Return (/i/,/J/,&#948;[sub /J/]&#8211;/x/).  Work under the assumption that /R/ &lt; 2[sup /s/].</i></font>
<a name="line-223"></a><font color=Blue><i>--</i></font>
<a name="line-224"></a><font color=Blue><i>-- This is the function /h/ of [Jozsa 2003, Section 9], discretized with precision 1\//N/ = 2[sup &#8722;/n/],</i></font>
<a name="line-225"></a><font color=Blue><i>-- and perturbed by the jitter parameter /j/\//L/.</i></font>
<a name="line-226"></a><font color=Blue>fN</font> <font color=Red>::</font> <font color=Cyan>(</font>Integral int<font color=Cyan>)</font> <font color=Red>=&gt;</font> CLInt <font color=Red>-&gt;</font> CLInt <font color=Red>-&gt;</font> int <font color=Red>-&gt;</font> int <font color=Red>-&gt;</font> CLIntP <font color=Red>-&gt;</font> <font color=Cyan>(</font>Ideal<font color=Cyan>,</font> CLInt<font color=Cyan>)</font>
<a name="line-227"></a><font color=Blue>fN</font> i j nn ll bigD <font color=Red>=</font>
<a name="line-228"></a>  <font color=Green><u>let</u></font> <font color=Cyan>(</font><font color=Cyan>(</font>ideal_J<font color=Cyan>,</font> <font color=Green><u>_</u></font><font color=Cyan>)</font><font color=Cyan>,</font> diff<font color=Cyan>)</font> <font color=Red>=</font> fN_d i j nn ll bigD
<a name="line-229"></a>  <font color=Green><u>in</u></font> <font color=Cyan>(</font>ideal_J<font color=Cyan>,</font> diff<font color=Cyan>)</font>
<a name="line-230"></a>
<a name="line-231"></a><a name="fN_d"></a><font color=Blue><i>-- | Like 'fN', but returning an ideal-with-distance not just an ideal.</i></font>
<a name="line-232"></a><font color=Blue>fN_d</font> <font color=Red>::</font> <font color=Cyan>(</font>Integral int<font color=Cyan>)</font> <font color=Red>=&gt;</font> CLInt <font color=Red>-&gt;</font> CLInt <font color=Red>-&gt;</font> int <font color=Red>-&gt;</font> int <font color=Red>-&gt;</font> CLIntP <font color=Red>-&gt;</font> <font color=Cyan>(</font>IdDist<font color=Cyan>,</font> CLInt<font color=Cyan>)</font>
<a name="line-233"></a><font color=Blue>fN_d</font> i j nn ll bigD <font color=Red>=</font>
<a name="line-234"></a>    <font color=Cyan>(</font>j_star_19<font color=Cyan>,</font> floor <font color=Cyan>$</font> <font color=Cyan>(</font>fromIntegral nn<font color=Cyan>)</font> <font color=Cyan>*</font> <font color=Cyan>(</font>toRational <font color=Cyan>$</font> injl <font color=Blue><i>-</i></font> <font color=Cyan>(</font>snd j_star_19<font color=Cyan>)</font><font color=Cyan>)</font><font color=Cyan>)</font>
<a name="line-235"></a>    <font color=Green><u>where</u></font>
<a name="line-236"></a>        <font color=Blue><i>-- Expression "i/N + j/L" used repeatedly</i></font>
<a name="line-237"></a>        injl     <font color=Red>=</font> compute_injl i nn j ll
<a name="line-238"></a>
<a name="line-239"></a>        <font color=Blue><i>-- Generate J1</i></font>
<a name="line-240"></a>        j1       <font color=Red>=</font> rho_d <font color=Cyan>$</font> rho_d <font color=Cyan>$</font> <font color=Cyan>(</font>unit_ideal bigD<font color=Cyan>,</font> <font color=Magenta>0</font><font color=Cyan>)</font>
<a name="line-241"></a>
<a name="line-242"></a>        <font color=Blue><i>-- Generate Jk's (make an infinite list and take only what is needed)</i></font>
<a name="line-243"></a>        jks      <font color=Red>=</font> takeWhile <font color=Cyan>(</font><font color=Red>\</font>jk <font color=Red>-&gt;</font> <font color=Cyan>(</font>delta jk<font color=Cyan>)</font> <font color=Cyan>&lt;=</font> injl<font color=Cyan>)</font> <font color=Cyan>$</font>
<a name="line-244"></a>                        bounded_iterate bound_jks
<a name="line-245"></a>                            <font color=Cyan>(</font><font color=Red>\</font>jk <font color=Red>-&gt;</font> jk <font color=Cyan>`star`</font> jk<font color=Cyan>)</font> j1
<a name="line-246"></a>                   <font color=Green><u>where</u></font>
<a name="line-247"></a>                       <font color=Blue><i>-- Bound for jk generation</i></font>
<a name="line-248"></a>                       max_i     <font color=Red>=</font> <font color=Magenta>2</font><font color=Cyan>^</font><font color=Cyan>(</font>fromJust <font color=Cyan>(</font>intm_length <font color=Cyan>$</font> i<font color=Cyan>)</font><font color=Cyan>)</font>
<a name="line-249"></a>                       bound_jks <font color=Red>=</font> ceiling <font color=Cyan>$</font>
<a name="line-250"></a>                                    <font color=Cyan>(</font>log <font color=Cyan>$</font> fromIntegral max_i<font color=Cyan>)</font> <font color=Cyan>/</font>
<a name="line-251"></a>                                        <font color=Cyan>(</font><font color=Cyan>(</font>fromIntegral nn<font color=Cyan>)</font> <font color=Cyan>*</font> <font color=Cyan>(</font>delta j1<font color=Cyan>)</font><font color=Cyan>)</font>
<a name="line-252"></a>
<a name="line-253"></a>        <font color=Blue><i>-- Apply all Jk's to J* using '*' in reverse (remember that the last</i></font>
<a name="line-254"></a>        <font color=Blue><i>-- element is J* itself)</i></font>
<a name="line-255"></a>        j_star_14   <font color=Red>=</font> foldr1 applyJkIfConditionHolds jks
<a name="line-256"></a>
<a name="line-257"></a>        <font color=Blue><i>-- Apply Jk to J* if a condition holds.</i></font>
<a name="line-258"></a>        applyJkIfConditionHolds <font color=Red>::</font> IdDist <font color=Red>-&gt;</font> IdDist <font color=Red>-&gt;</font> IdDist
<a name="line-259"></a>        applyJkIfConditionHolds jk jstar <font color=Red>=</font>
<a name="line-260"></a>            <font color=Green><u>if</u></font> <font color=Cyan>(</font>delta <font color=Cyan>(</font>jstar <font color=Cyan>`star`</font> jk<font color=Cyan>)</font> <font color=Cyan>&lt;=</font> injl<font color=Cyan>)</font> <font color=Green><u>then</u></font> jstar <font color=Cyan>`star`</font> jk <font color=Green><u>else</u></font> jstar
<a name="line-261"></a>
<a name="line-262"></a>        <font color=Blue><i>-- Go forward one step at a time as much as needed</i></font>
<a name="line-263"></a>        j_star_17   <font color=Red>=</font> bounded_step_delta <font color=Cyan>(</font><font color=Cyan>&lt;</font> injl<font color=Cyan>)</font> <font color=Cyan>(</font>rho_d<font color=Cyan>.</font>rho_d<font color=Cyan>)</font> j_star_14
<a name="line-264"></a>
<a name="line-265"></a>        <font color=Blue><i>-- Go back one step if needed</i></font>
<a name="line-266"></a>        j_star_19   <font color=Red>=</font> <font color=Green><u>if</u></font> <font color=Cyan>(</font>delta <font color=Cyan>(</font>rho_inv_d j_star_17<font color=Cyan>)</font> <font color=Cyan>&gt;=</font> injl<font color=Cyan>)</font>
<a name="line-267"></a>                      <font color=Green><u>then</u></font> rho_inv_d j_star_17
<a name="line-268"></a>                      <font color=Green><u>else</u></font> j_star_17
<a name="line-269"></a>
<a name="line-270"></a><a name="fJN"></a><font color=Blue><i>-- | Analogue of 'fN', working within the cycle determined by a given ideal /J/.</i></font>
<a name="line-271"></a><font color=Blue><i>--   ([Hallgren 2006], Section 5.)</i></font>
<a name="line-272"></a><font color=Blue>fJN</font> <font color=Red>::</font> IdDist <font color=Red>-&gt;</font> CLInt <font color=Red>-&gt;</font> CLInt <font color=Red>-&gt;</font> CLInt <font color=Red>-&gt;</font> CLInt <font color=Red>-&gt;</font> CLIntP <font color=Red>-&gt;</font> <font color=Cyan>(</font>Ideal<font color=Cyan>,</font> CLInt<font color=Cyan>)</font>
<a name="line-273"></a><font color=Blue>fJN</font> ideal_J i j nn ll bigD <font color=Red>=</font>
<a name="line-274"></a>  <font color=Green><u>let</u></font> <font color=Cyan>(</font><font color=Cyan>(</font>ideal_J'<font color=Cyan>,</font> <font color=Green><u>_</u></font><font color=Cyan>)</font><font color=Cyan>,</font> diff<font color=Cyan>)</font> <font color=Red>=</font> fJN_d ideal_J i j nn ll bigD
<a name="line-275"></a>  <font color=Green><u>in</u></font> <font color=Cyan>(</font>ideal_J'<font color=Cyan>,</font> diff<font color=Cyan>)</font>
<a name="line-276"></a>
<a name="line-277"></a><a name="fJN_d"></a><font color=Blue><i>-- | Like 'fJN', but returning an ideal-with-distance not just an ideal.</i></font>
<a name="line-278"></a><font color=Blue>fJN_d</font> <font color=Red>::</font> IdDist <font color=Red>-&gt;</font> CLInt <font color=Red>-&gt;</font> CLInt <font color=Red>-&gt;</font> CLInt <font color=Red>-&gt;</font> CLInt <font color=Red>-&gt;</font> CLIntP <font color=Red>-&gt;</font> <font color=Cyan>(</font>IdDist<font color=Cyan>,</font> CLInt<font color=Cyan>)</font>
<a name="line-279"></a><font color=Blue>fJN_d</font> ideal_J i j nn ll bigD <font color=Red>=</font>
<a name="line-280"></a>    <font color=Cyan>(</font>ideal_KFinal<font color=Cyan>,</font> floor <font color=Cyan>$</font> <font color=Cyan>(</font>fromIntegral nn<font color=Cyan>)</font> <font color=Cyan>*</font> <font color=Cyan>(</font>injl <font color=Blue><i>-</i></font> <font color=Cyan>(</font>delta ideal_KFinal<font color=Cyan>)</font><font color=Cyan>)</font><font color=Cyan>)</font>
<a name="line-281"></a>    <font color=Green><u>where</u></font>
<a name="line-282"></a>        <font color=Blue><i>-- Expression "i/N + j/L"</i></font>
<a name="line-283"></a>        injl      <font color=Red>=</font> compute_injl i nn j ll
<a name="line-284"></a>
<a name="line-285"></a>        <font color=Blue><i>-- Generate I and K</i></font>
<a name="line-286"></a>        ideal_I <font color=Red>=</font> fst <font color=Cyan>(</font>fN_d i j nn ll bigD<font color=Cyan>)</font>
<a name="line-287"></a>        ideal_K <font color=Red>=</font> bounded_reduce <font color=Cyan>(</font>ideal_I <font color=Cyan>`dot`</font> ideal_J<font color=Cyan>)</font>
<a name="line-288"></a>
<a name="line-289"></a>        <font color=Blue><i>-- Step forward/backward as much as needed</i></font>
<a name="line-290"></a>        ideal_KFinal <font color=Red>=</font>
<a name="line-291"></a>            <font color=Green><u>if</u></font> <font color=Cyan>(</font>delta ideal_K <font color=Cyan>&lt;=</font> injl<font color=Cyan>)</font>
<a name="line-292"></a>            <font color=Green><u>then</u></font>        bounded_step_delta <font color=Cyan>(</font><font color=Cyan>&lt;</font>  injl<font color=Cyan>)</font> <font color=Cyan>(</font>rho_d<font color=Cyan>)</font>    ideal_K
<a name="line-293"></a>            <font color=Green><u>else</u></font> rho_d <font color=Cyan>$</font> bounded_step_delta <font color=Cyan>(</font><font color=Cyan>&gt;=</font> injl<font color=Cyan>)</font> <font color=Cyan>(</font>rho_inv_d<font color=Cyan>)</font> ideal_K
<a name="line-294"></a>
<a name="line-295"></a><font color=Blue><i>-- ======================================================================</i></font>
<a name="line-296"></a><font color=Blue><i>-- * Classical period-finding</i></font>
<a name="line-297"></a>
<a name="line-298"></a><font color=Blue><i>-- $ Functions for classically finding the regulator and fundamental unit of a field using the period of /f_N/.</i></font>
<a name="line-299"></a>
<a name="line-300"></a><font color=Blue><i>-- ======================================================================</i></font>
<a name="line-301"></a><font color=Blue><i>-- ** Auxiliary functions</i></font>
<a name="line-302"></a>
<a name="line-303"></a><a name="order"></a><font color=Blue><i>-- | Find the order of an endofunction on an argument.  That is, @'order' /f/ /x/@ returns the first /n/ &gt; 0 such that /f/[sup /n/](/x/) = /x/. </i></font>
<a name="line-304"></a><font color=Blue><i>--</i></font>
<a name="line-305"></a><font color=Blue><i>--  Method: simple brute-force search/comparison.</i></font>
<a name="line-306"></a><font color=Blue>order</font> <font color=Red>::</font> <font color=Cyan>(</font>Eq a<font color=Cyan>)</font> <font color=Red>=&gt;</font> <font color=Cyan>(</font>a <font color=Red>-&gt;</font> a<font color=Cyan>)</font> <font color=Red>-&gt;</font> a <font color=Red>-&gt;</font> Int
<a name="line-307"></a><font color=Blue>order</font> <font color=Red>=</font> order_with_projection id
<a name="line-308"></a>
<a name="line-309"></a><a name="order_with_projection"></a><font color=Blue><i>-- | Given a function /p/, an endofunction /f/, and an argument /x/, returns the first /n/ &gt; 0 such that /p/(/f/[sup /n/](/x/)) = /p/(/x/).  </i></font>
<a name="line-310"></a><font color=Blue><i>--</i></font>
<a name="line-311"></a><font color=Blue><i>-- Method: simple brute-force search/comparison.</i></font>
<a name="line-312"></a><font color=Blue>order_with_projection</font> <font color=Red>::</font> <font color=Cyan>(</font>Eq b<font color=Cyan>)</font> <font color=Red>=&gt;</font> <font color=Cyan>(</font>a <font color=Red>-&gt;</font> b<font color=Cyan>)</font> <font color=Red>-&gt;</font> <font color=Cyan>(</font>a <font color=Red>-&gt;</font> a<font color=Cyan>)</font> <font color=Red>-&gt;</font> a <font color=Red>-&gt;</font> Int
<a name="line-313"></a><font color=Blue>order_with_projection</font> p f x <font color=Red>=</font> <font color=Magenta>1</font> <font color=Cyan>+</font> <font color=Cyan>(</font>length <font color=Cyan>$</font> takeWhile <font color=Cyan>(</font><font color=Red>\</font>y <font color=Red>-&gt;</font> p y <font color=Cyan>/=</font> p x<font color=Cyan>)</font> <font color=Cyan>(</font>tail <font color=Cyan>$</font> iterate f x<font color=Cyan>)</font><font color=Cyan>)</font>
<a name="line-314"></a>
<a name="line-315"></a><a name="first_return_with_projection"></a><font color=Blue><i>-- | Given a function /p/, an endofunction /f/, and an argument /x/, return /f/[sup /n/](/x/), for the first /n/ &gt; 0 such that /p/(/f/[sup /n/](/x/)) = /p/(/x/).  </i></font>
<a name="line-316"></a><font color=Blue><i>--</i></font>
<a name="line-317"></a><font color=Blue><i>-- Method: simple brute-force search/comparison.</i></font>
<a name="line-318"></a><font color=Blue>first_return_with_projection</font> <font color=Red>::</font> <font color=Cyan>(</font>Eq b<font color=Cyan>)</font> <font color=Red>=&gt;</font> <font color=Cyan>(</font>a <font color=Red>-&gt;</font> b<font color=Cyan>)</font> <font color=Red>-&gt;</font> <font color=Cyan>(</font>a <font color=Red>-&gt;</font> a<font color=Cyan>)</font> <font color=Red>-&gt;</font> a <font color=Red>-&gt;</font> a
<a name="line-319"></a><font color=Blue>first_return_with_projection</font> p f x <font color=Red>=</font> head <font color=Cyan>$</font> dropWhile <font color=Cyan>(</font><font color=Red>\</font>y <font color=Red>-&gt;</font> p y <font color=Cyan>/=</font> p x<font color=Cyan>)</font> <font color=Cyan>$</font> tail <font color=Cyan>$</font> iterate f x
<a name="line-320"></a>
<a name="line-321"></a><a name="first_return_with_proj_bdd"></a><font color=Blue><i>-- | Given a bound /b/, a function /p/, an endofunction /f/, and an argument /x/, return /f/[sup /n/](/x/), for the first /n/ &gt; 0 such that /p/(/f/[sup /n/](/x/)) = /p/(/x/), if there exists such an /n/ &#8804; /b/.</i></font>
<a name="line-322"></a><font color=Blue><i>--</i></font>
<a name="line-323"></a><font color=Blue><i>-- Method: simple brute-force search/comparison.</i></font>
<a name="line-324"></a><font color=Blue>first_return_with_proj_bdd</font> <font color=Red>::</font> <font color=Cyan>(</font>Eq b<font color=Cyan>)</font> <font color=Red>=&gt;</font> Int <font color=Red>-&gt;</font> <font color=Cyan>(</font>a <font color=Red>-&gt;</font> b<font color=Cyan>)</font> <font color=Red>-&gt;</font> <font color=Cyan>(</font>a <font color=Red>-&gt;</font> a<font color=Cyan>)</font> <font color=Red>-&gt;</font> a <font color=Red>-&gt;</font> Maybe a
<a name="line-325"></a><font color=Blue>first_return_with_proj_bdd</font> b p f x <font color=Red>=</font> listToMaybe <font color=Cyan>$</font> dropWhile <font color=Cyan>(</font><font color=Red>\</font>y <font color=Red>-&gt;</font> p y <font color=Cyan>/=</font> p x<font color=Cyan>)</font> <font color=Cyan>$</font> take b <font color=Cyan>$</font> tail <font color=Cyan>$</font> iterate f x
<a name="line-326"></a>
<a name="line-327"></a><a name="period"></a><font color=Blue><i>-- | Find the period of a function on integers, assuming that it is periodic and injective on its period.  That is, @'period' /f/@ returns the first /n/ &gt; 0 such that /f/(/n/) = /f/(0).  Method: simple brute-force search/comparison.</i></font>
<a name="line-328"></a><font color=Blue>period</font> <font color=Red>::</font> <font color=Cyan>(</font>Eq a<font color=Cyan>,</font> Integral int<font color=Cyan>)</font> <font color=Red>=&gt;</font> <font color=Cyan>(</font>int <font color=Red>-&gt;</font> a<font color=Cyan>)</font> <font color=Red>-&gt;</font> int
<a name="line-329"></a><font color=Blue>period</font> f <font color=Red>=</font> minimum <font color=Red>[</font> n <font color=Red>|</font> n <font color=Red>&lt;-</font> <font color=Red>[</font><font color=Magenta>1</font><font color=Red>..</font><font color=Red>]</font><font color=Cyan>,</font> f n <font color=Cyan>==</font> f <font color=Magenta>0</font> <font color=Red>]</font>
<a name="line-330"></a> 
<a name="line-331"></a><font color=Blue><i>-- ======================================================================</i></font>
<a name="line-332"></a><font color=Blue><i>-- ** Haskell native arithmetic</i></font>
<a name="line-333"></a>
<a name="line-334"></a><font color=Blue><i>-- $ The functions of this section use Haskell&#8217;s native integer and floating computation.</i></font>
<a name="line-335"></a>
<a name="line-336"></a><a name="regulator"></a><font color=Blue><i>-- | Find the regulator /R/ = log &#949;[sub 0] of a field, given the discriminant &#916;, </i></font>
<a name="line-337"></a><font color=Blue><i>-- by finding (classically) the order of &#961;.  </i></font>
<a name="line-338"></a><font color=Blue><i>--</i></font>
<a name="line-339"></a><font color=Blue><i>-- Uses 'IdDist' and 'rho_d'.</i></font>
<a name="line-340"></a><font color=Blue>regulator</font> <font color=Red>::</font> CLIntP <font color=Red>-&gt;</font> FPReal
<a name="line-341"></a><font color=Blue>regulator</font> bigD <font color=Red>=</font> snd <font color=Cyan>$</font> head <font color=Cyan>$</font> dropWhile <font color=Cyan>(</font><font color=Red>\</font><font color=Cyan>(</font>ii<font color=Cyan>,</font><font color=Green><u>_</u></font><font color=Cyan>)</font> <font color=Red>-&gt;</font> ii <font color=Cyan>/=</font> calO<font color=Cyan>)</font> <font color=Cyan>$</font> tail <font color=Cyan>$</font> iterate rho_d <font color=Cyan>$</font> <font color=Cyan>(</font>calO<font color=Cyan>,</font><font color=Magenta>0</font><font color=Cyan>)</font>
<a name="line-342"></a>  <font color=Green><u>where</u></font> calO <font color=Red>=</font> unit_ideal bigD
<a name="line-343"></a>
<a name="line-344"></a><a name="fundamental_unit"></a><font color=Blue><i>-- | Find the fundamental unit &#949;[sub 0] of a field, given the discriminant &#916;, </i></font>
<a name="line-345"></a><font color=Blue><i>-- by finding (classically) the order of &#961;.</i></font>
<a name="line-346"></a><font color=Blue><i>--</i></font>
<a name="line-347"></a><font color=Blue><i>-- Uses '(Ideal,Number)' and 'rho_num'.</i></font>
<a name="line-348"></a><font color=Blue>fundamental_unit</font> <font color=Red>::</font> CLIntP <font color=Red>-&gt;</font> AlgNum
<a name="line-349"></a><font color=Blue>fundamental_unit</font> bigD <font color=Red>=</font> maximum <font color=Red>[</font>eps<font color=Cyan>,</font> <font color=Blue><i>-</i></font>eps<font color=Cyan>,</font> <font color=Magenta>1</font><font color=Cyan>/</font>eps<font color=Cyan>,</font> <font color=Blue><i>-</i></font><font color=Magenta>1</font><font color=Cyan>/</font>eps<font color=Red>]</font>
<a name="line-350"></a>  <font color=Green><u>where</u></font> eps <font color=Red>=</font> snd <font color=Cyan>$</font> first_return_with_projection fst rho_num <font color=Cyan>(</font>calO<font color=Cyan>,</font><font color=Magenta>1</font><font color=Cyan>)</font>
<a name="line-351"></a>        calO <font color=Red>=</font> unit_ideal bigD
<a name="line-352"></a>
<a name="line-353"></a><a name="fundamental_solution"></a><font color=Blue><i>-- | Find the fundamental solution of Pell&#8217;s equation, given /d/.</i></font>
<a name="line-354"></a><font color=Blue><i>--</i></font>
<a name="line-355"></a><font color=Blue><i>-- Solutions of Pell&#8217;s equations are integer pairs (/x/,/y/) such that</i></font>
<a name="line-356"></a><font color=Blue><i>-- /x/,/y/ &gt; 0, and (/x/ + /y/&#8730;d)(/x/ &#8211; /y/&#8730;d) = 1.</i></font>
<a name="line-357"></a><font color=Blue><i>--</i></font>
<a name="line-358"></a><font color=Blue><i>-- In this situation, (/x/ + /y/&#8730;d) is a unit of the algebraic integers </i></font>
<a name="line-359"></a><font color=Blue><i>-- of /K/, and is &gt;1, so we simply search the powers of &#949;[sub 0] for a</i></font>
<a name="line-360"></a><font color=Blue><i>-- unit of the desired form.</i></font>
<a name="line-361"></a><font color=Blue>fundamental_solution</font> <font color=Red>::</font> CLIntP <font color=Red>-&gt;</font> <font color=Cyan>(</font>Integer<font color=Cyan>,</font>Integer<font color=Cyan>)</font>
<a name="line-362"></a><font color=Blue>fundamental_solution</font> d <font color=Red>=</font> head pell_solutions
<a name="line-363"></a>  <font color=Green><u>where</u></font> bigD <font color=Red>=</font> bigD_of_d d
<a name="line-364"></a>        eps0 <font color=Red>=</font> fundamental_unit bigD
<a name="line-365"></a>        pell_solutions <font color=Red>=</font> 
<a name="line-366"></a>          <font color=Red>[</font> <font color=Cyan>(</font>round x<font color=Cyan>,</font> round y<font color=Cyan>)</font> <font color=Red>|</font> n <font color=Red>&lt;-</font> <font color=Red>[</font><font color=Magenta>1</font><font color=Red>..</font><font color=Red>]</font><font color=Cyan>,</font>
<a name="line-367"></a>                                 <font color=Green><u>let</u></font> eps<font color=Red>@</font><font color=Cyan>(</font>AlgNum a b <font color=Green><u>_</u></font><font color=Cyan>)</font> <font color=Red>=</font> eps0<font color=Cyan>^</font>n<font color=Cyan>,</font>
<a name="line-368"></a>                                 a <font color=Cyan>&gt;=</font> <font color=Magenta>0</font><font color=Cyan>,</font> b <font color=Cyan>&gt;=</font> <font color=Magenta>0</font><font color=Cyan>,</font>
<a name="line-369"></a>                                 <font color=Green><u>let</u></font> x <font color=Red>=</font> a<font color=Cyan>,</font>
<a name="line-370"></a>                                 <font color=Green><u>let</u></font> y <font color=Red>=</font> <font color=Green><u>if</u></font> bigD <font color=Cyan>==</font> d <font color=Green><u>then</u></font> b <font color=Green><u>else</u></font> <font color=Magenta>2</font><font color=Cyan>*</font>b<font color=Cyan>,</font>
<a name="line-371"></a>                                 is_int x<font color=Cyan>,</font> is_int y<font color=Cyan>,</font>
<a name="line-372"></a>                                 eps <font color=Cyan>*</font> <font color=Cyan>(</font>conjugate eps<font color=Cyan>)</font> <font color=Cyan>==</font> <font color=Magenta>1</font><font color=Red>]</font>
<a name="line-373"></a>
<a name="line-374"></a><font color=Blue><i>-- ======================================================================</i></font>
<a name="line-375"></a><font color=Blue><i>-- ** Fixed-precision arithmetic</i></font>
<a name="line-376"></a>
<a name="line-377"></a><font color=Blue><i>-- $ The functions of this section perform period-finding using fixed-precision arithmetic.</i></font>
<a name="line-378"></a><font color=Blue><i>-- This should parallel closely (though at present not exactly, due to the implementations </i></font>
<a name="line-379"></a><font color=Blue><i>-- of floating-point operations) the quantum circuit implementations, and hence allows</i></font>
<a name="line-380"></a><font color=Blue><i>-- testing of whether the chosen precisions are accurate.</i></font>
<a name="line-381"></a>
<a name="line-382"></a><a name="regulator_fixed_prec"></a><font color=Blue><i>-- | Find the regulator /R/ = log &#949;[sub 0] of a field, given the discriminant &#916;, </i></font>
<a name="line-383"></a><font color=Blue><i>-- by finding (classically) the order of &#961;</i></font>
<a name="line-384"></a><font color=Blue><i>-- using fixed-precision arithmetic: 'fix_sizes_Ideal' for 'Ideal's,</i></font>
<a name="line-385"></a><font color=Blue><i>-- and given an assumed bound /b/ on log[sub 2] /R/.</i></font>
<a name="line-386"></a><font color=Blue><i>--</i></font>
<a name="line-387"></a><font color=Blue><i>-- Uses 'IdDist' and 'rho_d'.</i></font>
<a name="line-388"></a><font color=Blue>regulator_fixed_prec</font> <font color=Red>::</font> Int <font color=Red>-&gt;</font> CLIntP <font color=Red>-&gt;</font> Maybe FPReal
<a name="line-389"></a><font color=Blue>regulator_fixed_prec</font> b bigD <font color=Red>=</font> fmap snd <font color=Cyan>(</font>first_return_with_proj_bdd b' fst rho_d <font color=Cyan>(</font>calO<font color=Cyan>,</font>zero<font color=Cyan>)</font><font color=Cyan>)</font>
<a name="line-390"></a>  <font color=Green><u>where</u></font> calO <font color=Red>=</font> fix_sizes_Ideal <font color=Cyan>$</font> unit_ideal bigD
<a name="line-391"></a>        n <font color=Red>=</font> n_of_bigD bigD
<a name="line-392"></a>  <font color=Blue><i>-- S = 2RN, so this /i/ gives an assumed bound on log_2 S:  </i></font>
<a name="line-393"></a>        i <font color=Red>=</font> <font color=Magenta>1</font> <font color=Cyan>+</font> b <font color=Cyan>+</font> n
<a name="line-394"></a>  <font color=Blue><i>-- Following precisions are as used in 'approximate_regulator_circuit', 'q_fN':</i></font>
<a name="line-395"></a>        q <font color=Red>=</font> <font color=Magenta>2</font> <font color=Cyan>+</font> <font color=Magenta>2</font> <font color=Cyan>*</font> i 
<a name="line-396"></a>        l <font color=Red>=</font> <font color=Magenta>4</font> <font color=Cyan>+</font> q <font color=Cyan>+</font> n
<a name="line-397"></a>        p <font color=Red>=</font> precision_for_fN bigD n l
<a name="line-398"></a>        zero <font color=Red>=</font> fprealx <font color=Cyan>(</font><font color=Blue><i>-</i></font>p<font color=Cyan>)</font> <font color=Cyan>(</font>intm <font color=Cyan>(</font>q <font color=Blue><i>-</i></font> n <font color=Cyan>+</font> p<font color=Cyan>)</font> <font color=Magenta>0</font><font color=Cyan>)</font>
<a name="line-399"></a>  <font color=Blue><i>-- &#948;(I, &#961;^2 (I)) &#8805; &#8730;2 for any I, so the order of &#961; is at most 2R / (&#8730;2 / 2):</i></font>
<a name="line-400"></a>        b' <font color=Red>=</font> ceiling <font color=Cyan>$</font> <font color=Magenta>2</font> <font color=Cyan>*</font> sqrt<font color=Cyan>(</font><font color=Magenta>2</font><font color=Cyan>)</font> <font color=Cyan>*</font> <font color=Cyan>(</font>fromIntegral <font color=Magenta>2</font><font color=Cyan>^</font>b<font color=Cyan>)</font>
<a name="line-401"></a>
<a name="line-402"></a>
<a name="line-403"></a><font color=Blue><i>{-
<a name="line-404"></a>Waiting for 'AlgNum' to be rebased using 'IntM' instead of 'Integer'.
<a name="line-405"></a>
<a name="line-406"></a>-- | Find the fundamental unit &#949;[sub 0] of a field, given the discriminant &#916;, 
<a name="line-407"></a>-- by finding (classically) the order of &#961;,
<a name="line-408"></a>-- using fixed-precision arithmetic: 'fix_sizes_Ideal' for 'Ideal's,
<a name="line-409"></a>-- and a given /l/ for the 'AlgNum's generating them.
<a name="line-410"></a>--
<a name="line-411"></a>-- Uses '(Ideal,Number)' and 'rho_num'.
<a name="line-412"></a>fundamental_unit_with_fixed :: Int -&gt; CLIntP -&gt; AlgNum
<a name="line-413"></a>fundamental_unit_with_fixed l bigD = maximum [eps, -eps, 1/eps, -1/eps]
<a name="line-414"></a>  where eps = snd $ head $ dropWhile (\(ii,_) -&gt; ii /= calO) $ tail $ iterate rho_num $ (calO,one)
<a name="line-415"></a>        calO = fix_sizes_Ideal $ unit_ideal bigD
<a name="line-416"></a>        one = intm_with_length (Just l) 1
<a name="line-417"></a>-}</i></font>
</pre>
</body>
</html>