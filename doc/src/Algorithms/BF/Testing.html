<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<!-- Generated by HsColour, http://code.haskell.org/~malcolm/hscolour/ -->
<title>Haskell code</title>
</head>
<body>
<pre><a name="line-1"></a><font color=Blue><i>-- | This module provides some testing facilities for the Boolean</i></font>
<a name="line-2"></a><font color=Blue><i>-- Formula algorithm, as well as some auxiliary function definitions.</i></font>
<a name="line-3"></a><font color=Blue><i>-- See "Algorithms.BF.Main" for an overview of the boolean formula algorithm.</i></font>
<a name="line-4"></a><font color=Green><u>module</u></font> Algorithms<font color=Cyan>.</font>BF<font color=Cyan>.</font>Testing <font color=Green><u>where</u></font>
<a name="line-5"></a>
<a name="line-6"></a><font color=Green><u>import</u></font> Algorithms<font color=Cyan>.</font>BF<font color=Cyan>.</font>BooleanFormula
<a name="line-7"></a><font color=Green><u>import</u></font> Algorithms<font color=Cyan>.</font>BF<font color=Cyan>.</font>Hex
<a name="line-8"></a><font color=Green><u>import</u></font> Algorithms<font color=Cyan>.</font>BF<font color=Cyan>.</font>HexBoard
<a name="line-9"></a><font color=Green><u>import</u></font> Quipper
<a name="line-10"></a><font color=Green><u>import</u></font> QuipperLib<font color=Cyan>.</font>Simulation
<a name="line-11"></a><font color=Green><u>import</u></font> QuipperLib<font color=Cyan>.</font>Unboxing
<a name="line-12"></a>
<a name="line-13"></a><font color=Blue><i>-- * Auxiliary definitions</i></font>
<a name="line-14"></a>
<a name="line-15"></a><a name="moves_to_hex"></a><font color=Blue><i>-- | Convert  list of moves, into a 'HexBoard'.</i></font>
<a name="line-16"></a><font color=Blue>moves_to_hex</font> <font color=Red>::</font> BooleanFormulaOracle <font color=Red>-&gt;</font> <font color=Red>[</font>Int<font color=Red>]</font> <font color=Red>-&gt;</font> HexBoard
<a name="line-17"></a><font color=Blue>moves_to_hex</font> o moves <font color=Red>=</font> fromPos o pos
<a name="line-18"></a>  <font color=Green><u>where</u></font> pos <font color=Red>=</font> moves_to_pos o moves
<a name="line-19"></a>
<a name="line-20"></a><a name="moves_to_pos"></a><font color=Blue><i>-- | Convert a list of moves, into a list of positions.</i></font>
<a name="line-21"></a><font color=Blue>moves_to_pos</font> <font color=Red>::</font> BooleanFormulaOracle <font color=Red>-&gt;</font> <font color=Red>[</font>Int<font color=Red>]</font> <font color=Red>-&gt;</font> <font color=Red>[</font><font color=Red>[</font>Bool<font color=Red>]</font><font color=Red>]</font>
<a name="line-22"></a><font color=Blue>moves_to_pos</font> o moves <font color=Red>=</font> map <font color=Cyan>(</font>int2bools <font color=Cyan>(</font>oracle_m o<font color=Cyan>)</font><font color=Cyan>)</font> moves
<a name="line-23"></a>
<a name="line-24"></a><a name="set_bool"></a><font color=Blue><i>-- | Set the position in board, at the given address, to the given boolean.</i></font>
<a name="line-25"></a><font color=Blue>set_bool</font> <font color=Red>::</font> <font color=Red>[</font>Bool<font color=Red>]</font> <font color=Red>-&gt;</font> <font color=Red>[</font>Bool<font color=Red>]</font> <font color=Red>-&gt;</font> Bool <font color=Red>-&gt;</font> <font color=Red>[</font>Bool<font color=Red>]</font>
<a name="line-26"></a><font color=Blue>set_bool</font> board address value <font color=Red>=</font> <font color=Cyan>(</font>take n board<font color=Cyan>)</font> <font color=Cyan>++</font> value<font color=Red><b>:</b></font><font color=Cyan>(</font>drop <font color=Cyan>(</font>n<font color=Cyan>+</font><font color=Magenta>1</font><font color=Cyan>)</font> board<font color=Cyan>)</font>
<a name="line-27"></a>    <font color=Green><u>where</u></font> n <font color=Red>=</font> bools2int address
<a name="line-28"></a>
<a name="line-29"></a><a name="fromPos"></a><font color=Blue><i>-- | Create the description of a Hex board, from the given classical state</i></font>
<a name="line-30"></a><font color=Blue><i>-- of a position register from the Boolean Formula algorithm.</i></font>
<a name="line-31"></a><font color=Blue>fromPos</font> <font color=Red>::</font> BooleanFormulaOracle <font color=Red>-&gt;</font> <font color=Red>[</font><font color=Red>[</font>Bool<font color=Red>]</font><font color=Red>]</font> <font color=Red>-&gt;</font> HexBoard
<a name="line-32"></a><font color=Blue>fromPos</font> o pos <font color=Red>=</font> fromPos' pos <font color=Cyan>(</font>start_board o<font color=Cyan>)</font> <font color=Cyan>(</font>odd <font color=Cyan>(</font>oracle_s o<font color=Cyan>)</font><font color=Cyan>)</font>
<a name="line-33"></a>  <font color=Green><u>where</u></font>
<a name="line-34"></a>    fromPos' <font color=Red>::</font> <font color=Red>[</font><font color=Red>[</font>Bool<font color=Red>]</font><font color=Red>]</font> <font color=Red>-&gt;</font> HexBoard <font color=Red>-&gt;</font> Bool <font color=Red>-&gt;</font> HexBoard
<a name="line-35"></a>    fromPos' [] rb <font color=Green><u>_</u></font> <font color=Red>=</font> rb
<a name="line-36"></a>    fromPos' <font color=Cyan>(</font>p<font color=Red><b>:</b></font>ps<font color=Cyan>)</font> <font color=Cyan>(</font>red<font color=Cyan>,</font>blue<font color=Cyan>)</font> is_red <font color=Red>=</font> fromPos' ps <font color=Cyan>(</font><font color=Green><u>if</u></font> is_red <font color=Green><u>then</u></font> <font color=Cyan>(</font>set_bool red p True<font color=Cyan>,</font>set_bool blue p False<font color=Cyan>)</font> <font color=Green><u>else</u></font> <font color=Cyan>(</font>set_bool red p False<font color=Cyan>,</font>set_bool blue p True<font color=Cyan>)</font><font color=Cyan>)</font> <font color=Cyan>(</font>not is_red<font color=Cyan>)</font>
<a name="line-37"></a>
<a name="line-38"></a><font color=Blue><i>-- * Testing various circuits</i></font>
<a name="line-39"></a>
<a name="line-40"></a><a name="double"></a><font color=Blue><i>-- | A dummy value of type 'Double', to feed the type in the simulator.</i></font>
<a name="line-41"></a><font color=Blue>double</font> <font color=Red>::</font> Double
<a name="line-42"></a><font color=Blue>double</font> <font color=Red>=</font> undefined
<a name="line-43"></a>
<a name="line-44"></a><a name="oracle_with_input"></a><font color=Blue><i>-- | Construct the oracle circuit, initialized with the given boolean inputs.</i></font>
<a name="line-45"></a><font color=Blue>oracle_with_input</font> <font color=Red>::</font> BooleanFormulaOracle <font color=Red>-&gt;</font> BoolRegister <font color=Red>-&gt;</font> Circ BooleanFormulaRegister 
<a name="line-46"></a><font color=Blue>oracle_with_input</font> o input <font color=Red>=</font> <font color=Green><u>do</u></font>
<a name="line-47"></a> reg <font color=Red>&lt;-</font> qinit input
<a name="line-48"></a> oracle o reg
<a name="line-49"></a> return reg
<a name="line-50"></a>
<a name="line-51"></a><a name="run_oracle_with_input"></a><font color=Blue><i>-- | Simulate the oracle circuit with the given boolean inputs, to</i></font>
<a name="line-52"></a><font color=Blue><i>-- give boolean outputs.</i></font>
<a name="line-53"></a><font color=Blue>run_oracle_with_input</font> <font color=Red>::</font> BooleanFormulaOracle <font color=Red>-&gt;</font> BoolRegister <font color=Red>-&gt;</font> IO BoolRegister
<a name="line-54"></a><font color=Blue>run_oracle_with_input</font> oracle input <font color=Red>=</font> <font color=Green><u>do</u></font>
<a name="line-55"></a>  run_generic_io double <font color=Cyan>(</font>unbox <font color=Cyan>(</font>oracle_with_input oracle input<font color=Cyan>)</font><font color=Cyan>)</font> 
<a name="line-56"></a>
<a name="line-57"></a><a name="diffuse_with_input"></a><font color=Blue><i>-- | Return the diffuse circuit, initialized with the given boolean</i></font>
<a name="line-58"></a><font color=Blue><i>-- inputs.</i></font>
<a name="line-59"></a><font color=Blue>diffuse_with_input</font> <font color=Red>::</font> BoolRegister <font color=Red>-&gt;</font> Circ BooleanFormulaRegister 
<a name="line-60"></a><font color=Blue>diffuse_with_input</font> input <font color=Red>=</font> <font color=Green><u>do</u></font>
<a name="line-61"></a> reg <font color=Red>&lt;-</font> qinit input
<a name="line-62"></a> diffuse reg
<a name="line-63"></a> return reg
<a name="line-64"></a>
<a name="line-65"></a><a name="run_diffuse_with_input"></a><font color=Blue><i>-- | Simulate the diffuse circuit with the given boolean inputs, </i></font>
<a name="line-66"></a><font color=Blue><i>-- to give boolean outputs.</i></font>
<a name="line-67"></a><font color=Blue>run_diffuse_with_input</font> <font color=Red>::</font> BoolRegister <font color=Red>-&gt;</font> IO BoolRegister
<a name="line-68"></a><font color=Blue>run_diffuse_with_input</font> input <font color=Red>=</font> <font color=Green><u>do</u></font>
<a name="line-69"></a>  run_generic_io double <font color=Cyan>(</font>diffuse_with_input input<font color=Cyan>)</font> 
<a name="line-70"></a>
<a name="line-71"></a><a name="walk_with_input"></a><font color=Blue><i>-- | Return the walk circuit, initialized with the given boolean inputs.</i></font>
<a name="line-72"></a><font color=Blue>walk_with_input</font> <font color=Red>::</font> BoolRegister <font color=Red>-&gt;</font> Circ BooleanFormulaRegister 
<a name="line-73"></a><font color=Blue>walk_with_input</font> input <font color=Red>=</font> <font color=Green><u>do</u></font>
<a name="line-74"></a> reg <font color=Red>&lt;-</font> qinit input
<a name="line-75"></a> walk reg
<a name="line-76"></a> return reg
<a name="line-77"></a>
<a name="line-78"></a><a name="run_walk_with_input"></a><font color=Blue><i>-- | Simulate the walk circuit with the given boolean inputs, to give</i></font>
<a name="line-79"></a><font color=Blue><i>-- boolean outputs.</i></font>
<a name="line-80"></a><font color=Blue>run_walk_with_input</font> <font color=Red>::</font> BoolRegister <font color=Red>-&gt;</font> IO BoolRegister
<a name="line-81"></a><font color=Blue>run_walk_with_input</font> input <font color=Red>=</font> <font color=Green><u>do</u></font>
<a name="line-82"></a>  run_generic_io double <font color=Cyan>(</font>walk_with_input input<font color=Cyan>)</font> 
<a name="line-83"></a>
<a name="line-84"></a><a name="undo_oracle_with_input"></a><font color=Blue><i>-- | Return the 'undo_oracle' circuit, initialized with the given</i></font>
<a name="line-85"></a><font color=Blue><i>-- boolean inputs.</i></font>
<a name="line-86"></a><font color=Blue>undo_oracle_with_input</font> <font color=Red>::</font> BooleanFormulaOracle <font color=Red>-&gt;</font> BoolRegister <font color=Red>-&gt;</font> Circ BooleanFormulaRegister
<a name="line-87"></a><font color=Blue>undo_oracle_with_input</font> o input <font color=Red>=</font> <font color=Green><u>do</u></font>
<a name="line-88"></a> reg <font color=Red>&lt;-</font> qinit input
<a name="line-89"></a> undo_oracle o reg
<a name="line-90"></a> return reg
<a name="line-91"></a>
<a name="line-92"></a><a name="run_undo_oracle_with_input"></a><font color=Blue><i>-- | Simulate the 'undo_oracle' circuit with the given boolean inputs,</i></font>
<a name="line-93"></a><font color=Blue><i>-- to give boolean outputs.</i></font>
<a name="line-94"></a><font color=Blue>run_undo_oracle_with_input</font> <font color=Red>::</font> BooleanFormulaOracle <font color=Red>-&gt;</font> BoolRegister <font color=Red>-&gt;</font> IO BoolRegister
<a name="line-95"></a><font color=Blue>run_undo_oracle_with_input</font> oracle input <font color=Red>=</font> <font color=Green><u>do</u></font>
<a name="line-96"></a>  run_generic_io double <font color=Cyan>(</font>unbox <font color=Cyan>(</font>undo_oracle_with_input oracle input<font color=Cyan>)</font><font color=Cyan>)</font> 
<a name="line-97"></a>
<a name="line-98"></a><font color=Blue><i>-- * Oracle, diffuse, walk, and undo_oracle</i></font>
<a name="line-99"></a>
<a name="line-100"></a><a name="run_odwu_with_input"></a><font color=Blue><i>-- | Create a register from the given boolean inputs,</i></font>
<a name="line-101"></a><font color=Blue><i>-- and then run the oracle circuit, followed by the diffusion step,</i></font>
<a name="line-102"></a><font color=Blue><i>-- followed by the walk step, and finally the 'undo_oracle' circuit.</i></font>
<a name="line-103"></a><font color=Blue><i>-- </i></font>
<a name="line-104"></a><font color=Blue><i>-- This is really a test of all four parts. The return values when</i></font>
<a name="line-105"></a><font color=Blue><i>-- running this step can be fed forward into the next iteration, and</i></font>
<a name="line-106"></a><font color=Blue><i>-- the 'undo_oracle' step should have returned the eight work qubits</i></font>
<a name="line-107"></a><font color=Blue><i>-- back to the initial 'False' states.</i></font>
<a name="line-108"></a><font color=Blue><i>-- </i></font>
<a name="line-109"></a><font color=Blue><i>-- We break the simulation into the four separate steps, so that we are</i></font>
<a name="line-110"></a><font color=Blue><i>-- not trying to simulate the walk/undo_oracle steps over a quantum state, as</i></font>
<a name="line-111"></a><font color=Blue><i>-- this gives us an overhead.</i></font>
<a name="line-112"></a><font color=Blue>run_odwu_with_input</font> <font color=Red>::</font> BooleanFormulaOracle <font color=Red>-&gt;</font> BoolRegister <font color=Red>-&gt;</font> IO BoolRegister
<a name="line-113"></a><font color=Blue>run_odwu_with_input</font> o input <font color=Red>=</font> <font color=Green><u>do</u></font>
<a name="line-114"></a>  oracle_output <font color=Red>&lt;-</font> run_oracle_with_input o input
<a name="line-115"></a>  diffuse_output <font color=Red>&lt;-</font> run_diffuse_with_input oracle_output
<a name="line-116"></a>  walk_output <font color=Red>&lt;-</font> run_walk_with_input diffuse_output
<a name="line-117"></a>  run_undo_oracle_with_input o walk_output
<a name="line-118"></a>
<a name="line-119"></a><a name="repeat_odwu_n"></a><font color=Blue><i>-- | Simulate the /odwu/ circuit, running it /n/ times and passing the</i></font>
<a name="line-120"></a><font color=Blue><i>-- output of each iteration as inputs to the next iteration.</i></font>
<a name="line-121"></a><font color=Blue><i>-- The overall return value is a representation of the HexBoard at each step of</i></font>
<a name="line-122"></a><font color=Blue><i>-- the simulation.</i></font>
<a name="line-123"></a><font color=Blue>repeat_odwu_n</font> <font color=Red>::</font> Int <font color=Red>-&gt;</font> BooleanFormulaOracle <font color=Red>-&gt;</font> BoolRegister <font color=Red>-&gt;</font> IO <font color=Red>[</font>HexBoard<font color=Red>]</font>
<a name="line-124"></a><font color=Blue>repeat_odwu_n</font> n oracle input <font color=Red>=</font> repeat_odwu_n' n oracle input []
<a name="line-125"></a>  <font color=Green><u>where</u></font>
<a name="line-126"></a>    repeat_odwu_n' <font color=Magenta>0</font> <font color=Green><u>_</u></font> <font color=Green><u>_</u></font> accum <font color=Red>=</font> return <font color=Cyan>(</font>reverse accum<font color=Cyan>)</font>
<a name="line-127"></a>    repeat_odwu_n' n oracle input accum <font color=Red>=</font> <font color=Green><u>do</u></font>
<a name="line-128"></a>      output <font color=Red>&lt;-</font> run_odwu_with_input oracle input
<a name="line-129"></a>      <font color=Green><u>let</u></font> flags <font color=Red>=</font> position_flags output
<a name="line-130"></a>      <font color=Green><u>let</u></font> pos <font color=Red>=</font> position output
<a name="line-131"></a>      <font color=Green><u>let</u></font> hexboard <font color=Red>=</font> start_board <font color=Cyan>(</font>update_start_board oracle <font color=Cyan>(</font>fromPos oracle <font color=Cyan>(</font>tidy flags pos<font color=Cyan>)</font><font color=Cyan>)</font><font color=Cyan>)</font>
<a name="line-132"></a>      repeat_odwu_n' <font color=Cyan>(</font>n<font color=Blue><i>-</i></font><font color=Magenta>1</font><font color=Cyan>)</font> oracle output <font color=Cyan>(</font>hexboard<font color=Red><b>:</b></font>accum<font color=Cyan>)</font>
<a name="line-133"></a>
<a name="line-134"></a><a name="repeat_odwu_infinite"></a><font color=Blue><i>-- | Simulate the /odwu/ circuit, running it repeatedly and passing</i></font>
<a name="line-135"></a><font color=Blue><i>-- the output of each iteration as inputs to the next iteration.</i></font>
<a name="line-136"></a><font color=Blue><i>-- Outputs an ASCII representation of the position register/board after each step.</i></font>
<a name="line-137"></a><font color=Blue>repeat_odwu_infinite</font> <font color=Red>::</font> BooleanFormulaOracle <font color=Red>-&gt;</font> BoolRegister <font color=Red>-&gt;</font> IO ()
<a name="line-138"></a><font color=Blue>repeat_odwu_infinite</font> oracle input <font color=Red>=</font> <font color=Green><u>do</u></font>
<a name="line-139"></a>  output <font color=Red>&lt;-</font> run_odwu_with_input oracle input
<a name="line-140"></a>  <font color=Green><u>let</u></font> flags <font color=Red>=</font> position_flags output
<a name="line-141"></a>  <font color=Green><u>let</u></font> pos <font color=Red>=</font> position output
<a name="line-142"></a>  putStrLn <font color=Magenta>"Position Register: "</font>
<a name="line-143"></a>  putStr <font color=Cyan>(</font>show <font color=Cyan>(</font><font color=Cyan>(</font><font color=Red>\</font><font color=Cyan>(</font>l<font color=Cyan>,</font>p<font color=Cyan>)</font> <font color=Red>-&gt;</font> <font color=Red>[</font><font color=Green><u>if</u></font> l <font color=Green><u>then</u></font> <font color=Magenta>'L'</font> <font color=Green><u>else</u></font> <font color=Magenta>' '</font><font color=Cyan>,</font><font color=Green><u>if</u></font> p <font color=Green><u>then</u></font> <font color=Magenta>'P'</font> <font color=Green><u>else</u></font> <font color=Magenta>' '</font><font color=Red>]</font><font color=Cyan>)</font> flags<font color=Cyan>)</font><font color=Cyan>)</font>
<a name="line-144"></a>  putStr <font color=Magenta>" : "</font>
<a name="line-145"></a>  putStrLn <font color=Cyan>(</font>show <font color=Cyan>(</font>map bools2int pos<font color=Cyan>)</font><font color=Cyan>)</font> 
<a name="line-146"></a>  output_start_board ASCII <font color=Cyan>(</font>update_start_board oracle <font color=Cyan>(</font>fromPos oracle <font color=Cyan>(</font>tidy flags pos<font color=Cyan>)</font><font color=Cyan>)</font><font color=Cyan>)</font>
<a name="line-147"></a>  repeat_odwu_infinite oracle output
<a name="line-148"></a>
<a name="line-149"></a><a name="tidy"></a><font color=Blue><i>-- | Trim any leading zeroes from a pos register, </i></font>
<a name="line-150"></a><font color=Blue><i>-- and a single leading 1, if we're not at a paraleaf,</i></font>
<a name="line-151"></a><font color=Blue><i>-- and a 3, if we're at the root.</i></font>
<a name="line-152"></a><font color=Blue>tidy</font> <font color=Red>::</font> <font color=Cyan>(</font>Bool<font color=Cyan>,</font>Bool<font color=Cyan>)</font> <font color=Red>-&gt;</font> <font color=Red>[</font><font color=Red>[</font>Bool<font color=Red>]</font><font color=Red>]</font> <font color=Red>-&gt;</font> <font color=Red>[</font><font color=Red>[</font>Bool<font color=Red>]</font><font color=Red>]</font>
<a name="line-153"></a><font color=Blue>tidy</font> flags pos <font color=Red>=</font> <font color=Green><u>if</u></font> pos <font color=Cyan>==</font> <font color=Cyan>(</font>zeroes <font color=Cyan>++</font> <font color=Red>[</font>three<font color=Red>]</font><font color=Cyan>)</font> <font color=Green><u>then</u></font> [] <font color=Green><u>else</u></font> tidy' flags pos
<a name="line-154"></a>  <font color=Green><u>where</u></font>
<a name="line-155"></a>    zeroes <font color=Red>=</font> replicate <font color=Cyan>(</font>length pos <font color=Blue><i>-</i></font> <font color=Magenta>1</font><font color=Cyan>)</font> <font color=Cyan>(</font>replicate <font color=Cyan>(</font>length <font color=Cyan>(</font>head pos<font color=Cyan>)</font><font color=Cyan>)</font> False<font color=Cyan>)</font>
<a name="line-156"></a>    three <font color=Red>=</font> <font color=Cyan>(</font>replicate <font color=Cyan>(</font>length <font color=Cyan>(</font>head pos<font color=Cyan>)</font> <font color=Blue><i>-</i></font> <font color=Magenta>2</font><font color=Cyan>)</font> False<font color=Cyan>)</font> <font color=Cyan>++</font> <font color=Red>[</font>True<font color=Cyan>,</font>True<font color=Red>]</font>
<a name="line-157"></a>    tidy' <font color=Green><u>_</u></font> [] <font color=Red>=</font> []
<a name="line-158"></a>    tidy' <font color=Cyan>(</font>l<font color=Cyan>,</font>p<font color=Cyan>)</font> <font color=Cyan>(</font>a<font color=Red><b>:</b></font><font color=Green><u>as</u></font><font color=Cyan>)</font> <font color=Red>=</font> <font color=Green><u>case</u></font> <font color=Cyan>(</font>a <font color=Cyan>==</font> replicate <font color=Cyan>(</font>length a<font color=Cyan>)</font> False<font color=Cyan>)</font> <font color=Green><u>of</u></font>
<a name="line-159"></a>      True <font color=Red>-&gt;</font> tidy' <font color=Cyan>(</font>l<font color=Cyan>,</font>p<font color=Cyan>)</font> <font color=Green><u>as</u></font>
<a name="line-160"></a>      False <font color=Red>-&gt;</font> <font color=Green><u>case</u></font> <font color=Cyan>(</font>a <font color=Cyan>==</font> <font color=Cyan>(</font>replicate <font color=Cyan>(</font>length a <font color=Blue><i>-</i></font> <font color=Magenta>1</font><font color=Cyan>)</font> False<font color=Cyan>)</font> <font color=Cyan>++</font> <font color=Red>[</font>True<font color=Red>]</font><font color=Cyan>)</font> <font color=Green><u>of</u></font>
<a name="line-161"></a>        False <font color=Red>-&gt;</font> a<font color=Red><b>:</b></font><font color=Green><u>as</u></font>
<a name="line-162"></a>        True <font color=Red>-&gt;</font> <font color=Green><u>if</u></font> p <font color=Green><u>then</u></font> <font color=Cyan>(</font>a<font color=Red><b>:</b></font><font color=Green><u>as</u></font><font color=Cyan>)</font> <font color=Green><u>else</u></font> <font color=Green><u>as</u></font>
<a name="line-163"></a>
<a name="line-164"></a><a name="hex_with_input"></a><font color=Blue><i>-- | Return the 'Hex' circuit, initialized for the given oracle, with the given </i></font>
<a name="line-165"></a><font color=Blue><i>-- boolean inputs.</i></font>
<a name="line-166"></a><font color=Blue>hex_with_input</font> <font color=Red>::</font> BooleanFormulaOracle <font color=Red>-&gt;</font> BoolRegister <font color=Red>-&gt;</font> Circ Qubit
<a name="line-167"></a><font color=Blue>hex_with_input</font> oracle input <font color=Red>=</font> <font color=Green><u>do</u></font>
<a name="line-168"></a>    <font color=Green><u>let</u></font> init <font color=Red>=</font> start_board oracle
<a name="line-169"></a>    <font color=Green><u>let</u></font> s <font color=Red>=</font> oracle_s oracle
<a name="line-170"></a>    <font color=Green><u>let</u></font> x_max <font color=Red>=</font> oracle_x_max oracle
<a name="line-171"></a>    reg <font color=Red>&lt;-</font> qinit input
<a name="line-172"></a>    <font color=Green><u>let</u></font> pos <font color=Red>=</font> position reg
<a name="line-173"></a>    <font color=Green><u>let</u></font> binary <font color=Red>=</font> work_binary reg
<a name="line-174"></a>    <font color=Cyan>(</font><font color=Green><u>_</u></font><font color=Cyan>,</font>binary'<font color=Cyan>)</font> <font color=Red>&lt;-</font> hex_oracle init s x_max <font color=Cyan>(</font>pos<font color=Cyan>,</font>binary<font color=Cyan>)</font>
<a name="line-175"></a>    return binary'
<a name="line-176"></a>
<a name="line-177"></a><a name="run_hex_with_input"></a><font color=Blue><i>-- | Simulate the running of the 'Hex' circuit, initialized for the given oracle, </i></font>
<a name="line-178"></a><font color=Blue><i>-- with the given boolean inputs.</i></font>
<a name="line-179"></a><font color=Blue>run_hex_with_input</font> <font color=Red>::</font> BooleanFormulaOracle <font color=Red>-&gt;</font> BoolRegister <font color=Red>-&gt;</font> IO Bool
<a name="line-180"></a><font color=Blue>run_hex_with_input</font> oracle input <font color=Red>=</font> run_generic_io double <font color=Cyan>(</font>hex_with_input oracle input<font color=Cyan>)</font>
<a name="line-181"></a>
<a name="line-182"></a><a name="checkwin_trace"></a><font color=Blue><i>-- | Simulate the running of the 'checkwin_red' subroutine for the</i></font>
<a name="line-183"></a><font color=Blue><i>-- given oracle, and keep track of the state of certain \"traced\" qubits within that </i></font>
<a name="line-184"></a><font color=Blue><i>-- subroutine, which represent the Hex board at each iteration of the while loop in</i></font>
<a name="line-185"></a><font color=Blue><i>-- the 'flood_fill' algorithm.</i></font>
<a name="line-186"></a><font color=Blue>checkwin_trace</font> <font color=Red>::</font> BooleanFormulaOracle <font color=Red>-&gt;</font> IO <font color=Red>[</font><font color=Red>[</font>Bool<font color=Red>]</font><font color=Red>]</font>
<a name="line-187"></a><font color=Blue>checkwin_trace</font> o <font color=Red>=</font> <font color=Green><u>do</u></font>
<a name="line-188"></a> <font color=Green><u>let</u></font> circuit <font color=Red>=</font> hex_with_input o <font color=Cyan>(</font>createRegister o<font color=Cyan>)</font>
<a name="line-189"></a> trace <font color=Red>&lt;-</font> run_generic_trace_io double circuit 
<a name="line-190"></a> <font color=Blue><i>--  trace :: [QuantumTrace] = [Vector Double [Bool]] = [Vector [([Bool],Double)]]</i></font>
<a name="line-191"></a> <font color=Green><u>let</u></font> boards <font color=Red>=</font> map <font color=Cyan>(</font><font color=Red>\</font><font color=Cyan>(</font>Vector <font color=Red>[</font><font color=Cyan>(</font>bs<font color=Cyan>,</font><font color=Green><u>_</u></font><font color=Cyan>)</font><font color=Red>]</font><font color=Cyan>)</font> <font color=Red>-&gt;</font> bs<font color=Cyan>)</font> trace
<a name="line-192"></a> return boards
<a name="line-193"></a>
<a name="line-194"></a>
</pre>
</body>
</html>