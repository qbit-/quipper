<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<!-- Generated by HsColour, http://code.haskell.org/~malcolm/hscolour/ -->
<title>Haskell code</title>
</head>
<body>
<pre><a name="line-1"></a><font color=Blue><i>-- | This module provides global definitions for </i></font>
<a name="line-2"></a><font color=Blue><i>-- the Unique Shortest Vector algorithm.</i></font>
<a name="line-3"></a>
<a name="line-4"></a><font color=Green><u>module</u></font> Algorithms<font color=Cyan>.</font>USV<font color=Cyan>.</font>Definitions <font color=Green><u>where</u></font>
<a name="line-5"></a>
<a name="line-6"></a><font color=Green><u>import</u></font> Quipper
<a name="line-7"></a><font color=Green><u>import</u></font> QuipperLib<font color=Cyan>.</font>Arith
<a name="line-8"></a>
<a name="line-9"></a><font color=Green><u>import</u></font> Control<font color=Cyan>.</font>Monad <font color=Cyan>(</font>foldM<font color=Cyan>,</font> zipWithM<font color=Cyan>,</font> replicateM<font color=Cyan>)</font>
<a name="line-10"></a><font color=Green><u>import</u></font> <font color=Green><u>qualified</u></font> Math<font color=Cyan>.</font>Lattices<font color=Cyan>.</font>LLL 
<a name="line-11"></a><font color=Green><u>import</u></font> Data<font color=Cyan>.</font>Array
<a name="line-12"></a><font color=Green><u>import</u></font> Data<font color=Cyan>.</font>List <font color=Cyan>(</font>mapAccumL<font color=Cyan>)</font>
<a name="line-13"></a><font color=Green><u>import</u></font> Data<font color=Cyan>.</font>Numbers<font color=Cyan>.</font>Primes
<a name="line-14"></a><font color=Green><u>import</u></font> System<font color=Cyan>.</font>Random
<a name="line-15"></a><font color=Green><u>import</u></font> <font color=Green><u>qualified</u></font> Data<font color=Cyan>.</font>Map <font color=Green><u>as</u></font> Map
<a name="line-16"></a><font color=Green><u>import</u></font> Data<font color=Cyan>.</font>Map <font color=Cyan>(</font>Map<font color=Cyan>)</font>
<a name="line-17"></a>
<a name="line-18"></a>
<a name="line-19"></a><font color=Blue><i>-- ==============================================================</i></font>
<a name="line-20"></a><font color=Blue><i>-- * Types for the Unique Shortest Vector algorithm </i></font>
<a name="line-21"></a>
<a name="line-22"></a><a name="TwoPoint"></a><font color=Blue><i>-- | An input to 'tPP': a pair of a 'Qubit' and a list</i></font>
<a name="line-23"></a><a name="TwoPoint"></a><font color=Blue><i>-- of 'QDInt's. Holds a superposition of two vectors with an</i></font>
<a name="line-24"></a><a name="TwoPoint"></a><font color=Blue><i>-- unknown fixed difference.</i></font>
<a name="line-25"></a><a name="TwoPoint"></a><font color=Green><u>type</u></font> TwoPoint <font color=Red>=</font> <font color=Cyan>(</font>Qubit<font color=Cyan>,</font> <font color=Red>[</font>QDInt<font color=Red>]</font><font color=Cyan>)</font>
<a name="line-26"></a>
<a name="line-27"></a><a name="CosetState"></a><font color=Blue><i>-- | An input to 'dCP': a pair of a 'Qubit' and a</i></font>
<a name="line-28"></a><a name="CosetState"></a><font color=Blue><i>-- 'QDInt'. Holds a superposition of two numbers with an</i></font>
<a name="line-29"></a><a name="CosetState"></a><font color=Blue><i>-- unknown fixed difference.</i></font>
<a name="line-30"></a><a name="CosetState"></a><font color=Green><u>type</u></font> CosetState <font color=Red>=</font> <font color=Cyan>(</font>Qubit<font color=Cyan>,</font> QDInt<font color=Cyan>)</font>
<a name="line-31"></a>
<a name="line-32"></a><a name="Psi_k"></a><font color=Blue><i>-- | An input to 'sieving': a pair of a 'Qubit' and an </i></font>
<a name="line-33"></a><a name="Psi_k"></a><font color=Blue><i>-- integer. Holds a state of the form:</i></font>
<a name="line-34"></a><a name="Psi_k"></a><font color=Blue><i>--</i></font>
<a name="line-35"></a><a name="Psi_k"></a><font color=Blue><i>-- \[image CosetState.png] </i></font>
<a name="line-36"></a><a name="Psi_k"></a><font color=Blue><i>--</i></font>
<a name="line-37"></a><a name="Psi_k"></a><font color=Blue><i>-- together with the integer /k/.</i></font>
<a name="line-38"></a><a name="Psi_k"></a><font color=Green><u>type</u></font> Psi_k <font color=Red>=</font> <font color=Cyan>(</font>Qubit<font color=Cyan>,</font> Int<font color=Cyan>)</font>
<a name="line-39"></a>
<a name="line-40"></a>
<a name="line-41"></a><font color=Blue><i>-- ==============================================================</i></font>
<a name="line-42"></a><font color=Blue><i>-- * General purpose functions</i></font>
<a name="line-43"></a>
<a name="line-44"></a><a name="concat_pair"></a><font color=Blue><i>-- | Concatenate two pairs of lists componentwise. </i></font>
<a name="line-45"></a><font color=Blue>concat_pair</font> <font color=Red>::</font> <font color=Cyan>(</font><font color=Red>[</font>a<font color=Red>]</font><font color=Cyan>,</font><font color=Red>[</font>b<font color=Red>]</font><font color=Cyan>)</font> <font color=Red>-&gt;</font> <font color=Cyan>(</font><font color=Red>[</font>a<font color=Red>]</font><font color=Cyan>,</font><font color=Red>[</font>b<font color=Red>]</font><font color=Cyan>)</font> <font color=Red>-&gt;</font> <font color=Cyan>(</font><font color=Red>[</font>a<font color=Red>]</font><font color=Cyan>,</font><font color=Red>[</font>b<font color=Red>]</font><font color=Cyan>)</font>
<a name="line-46"></a><font color=Blue>concat_pair</font> <font color=Cyan>(</font>i<font color=Cyan>,</font>j<font color=Cyan>)</font> <font color=Cyan>(</font>k<font color=Cyan>,</font>l<font color=Cyan>)</font> <font color=Red>=</font> <font color=Cyan>(</font>i <font color=Cyan>++</font> k<font color=Cyan>,</font> j <font color=Cyan>++</font> l<font color=Cyan>)</font>
<a name="line-47"></a>
<a name="line-48"></a><a name="multi_split"></a><font color=Blue><i>-- | Construct a list of random number generators.</i></font>
<a name="line-49"></a><font color=Blue>multi_split</font> <font color=Red>::</font> StdGen <font color=Red>-&gt;</font> <font color=Red>[</font>StdGen<font color=Red>]</font>
<a name="line-50"></a><font color=Blue>multi_split</font> gen <font color=Red>=</font> gen1 <font color=Red><b>:</b></font> multi_split gen2 <font color=Green><u>where</u></font>
<a name="line-51"></a>  <font color=Cyan>(</font>gen1<font color=Cyan>,</font> gen2<font color=Cyan>)</font> <font color=Red>=</font> split gen
<a name="line-52"></a>
<a name="line-53"></a><a name="find"></a><font color=Blue><i>-- | Given a list /l/, a predicate /p/ and an error message /msg/, </i></font>
<a name="line-54"></a><font color=Blue><i>-- return a pair (/a/,/l'/) where /a/ is the first element </i></font>
<a name="line-55"></a><font color=Blue><i>-- of /l/ satisfying /p/ and /l'/ is the remaining list. </i></font>
<a name="line-56"></a><font color=Blue><i>-- If no such element exists, raise an error and display /msg/.</i></font>
<a name="line-57"></a><font color=Blue>find</font> <font color=Red>::</font> <font color=Red>[</font>a<font color=Red>]</font> <font color=Red>-&gt;</font> <font color=Cyan>(</font>a <font color=Red>-&gt;</font> Bool<font color=Cyan>)</font> <font color=Red>-&gt;</font> String <font color=Red>-&gt;</font> <font color=Cyan>(</font>a<font color=Cyan>,</font> <font color=Red>[</font>a<font color=Red>]</font><font color=Cyan>)</font>
<a name="line-58"></a><font color=Blue>find</font> [] condition msg <font color=Red>=</font> error msg
<a name="line-59"></a><font color=Blue>find</font> <font color=Cyan>(</font>a<font color=Red><b>:</b></font><font color=Green><u>as</u></font><font color=Cyan>)</font> condition msg <font color=Red>=</font>
<a name="line-60"></a>  <font color=Green><u>if</u></font> <font color=Cyan>(</font>condition a<font color=Cyan>)</font> <font color=Green><u>then</u></font> <font color=Cyan>(</font>a<font color=Cyan>,</font><font color=Green><u>as</u></font><font color=Cyan>)</font>
<a name="line-61"></a>  <font color=Green><u>else</u></font> <font color=Cyan>(</font>b<font color=Cyan>,</font><font color=Cyan>(</font>a<font color=Red><b>:</b></font>bs<font color=Cyan>)</font><font color=Cyan>)</font>
<a name="line-62"></a>    <font color=Green><u>where</u></font> 
<a name="line-63"></a>      <font color=Cyan>(</font>b<font color=Cyan>,</font>bs<font color=Cyan>)</font> <font color=Red>=</font> find <font color=Green><u>as</u></font> condition msg
<a name="line-64"></a>
<a name="line-65"></a><a name="separate"></a><font color=Blue><i>-- | Given a list /l/ and a predicate /p/, return a pair</i></font>
<a name="line-66"></a><font color=Blue><i>-- (/l1/, /l2/) where /l1/ contains the elements of /l/ </i></font>
<a name="line-67"></a><font color=Blue><i>-- satisfying /p/ and /l2/ the others.</i></font>
<a name="line-68"></a><font color=Blue>separate</font> <font color=Red>::</font> <font color=Red>[</font>a<font color=Red>]</font> <font color=Red>-&gt;</font> <font color=Cyan>(</font>a <font color=Red>-&gt;</font> Bool<font color=Cyan>)</font> <font color=Red>-&gt;</font> <font color=Cyan>(</font><font color=Red>[</font>a<font color=Red>]</font><font color=Cyan>,</font> <font color=Red>[</font>a<font color=Red>]</font><font color=Cyan>)</font>
<a name="line-69"></a><font color=Blue>separate</font> [] condition <font color=Red>=</font> <font color=Cyan>(</font>[]<font color=Cyan>,</font>[]<font color=Cyan>)</font>
<a name="line-70"></a><font color=Blue>separate</font> <font color=Cyan>(</font>h<font color=Red><b>:</b></font>t<font color=Cyan>)</font> condition <font color=Red>=</font>
<a name="line-71"></a>  <font color=Green><u>if</u></font> <font color=Cyan>(</font>condition h<font color=Cyan>)</font> <font color=Green><u>then</u></font> concat_pair <font color=Cyan>(</font><font color=Red>[</font>h<font color=Red>]</font><font color=Cyan>,</font>[]<font color=Cyan>)</font> <font color=Cyan>(</font>separate t condition<font color=Cyan>)</font>
<a name="line-72"></a>  <font color=Green><u>else</u></font> concat_pair <font color=Cyan>(</font>[]<font color=Cyan>,</font><font color=Red>[</font>h<font color=Red>]</font><font color=Cyan>)</font> <font color=Cyan>(</font>separate t condition<font color=Cyan>)</font>
<a name="line-73"></a>
<a name="line-74"></a><a name="expand"></a><font color=Blue><i>-- | Given integers /m/ and /n/, compute the </i></font>
<a name="line-75"></a><font color=Blue><i>-- big-endian expansion of /m/ in base /n/.</i></font>
<a name="line-76"></a><font color=Blue>expand</font> <font color=Red>::</font> Integer <font color=Red>-&gt;</font> Integer <font color=Red>-&gt;</font> <font color=Red>[</font>Integer<font color=Red>]</font>
<a name="line-77"></a><font color=Blue>expand</font> <font color=Green><u>_</u></font> n <font color=Red>|</font> n <font color=Cyan>&lt;=</font> <font color=Magenta>1</font> <font color=Red>=</font> error <font color=Cyan>(</font><font color=Magenta>"Cannot expand a number in base "</font> <font color=Cyan>++</font> show n <font color=Cyan>++</font> <font color=Magenta>"."</font><font color=Cyan>)</font>
<a name="line-78"></a><font color=Blue>expand</font> <font color=Magenta>0</font> n <font color=Red>=</font> <font color=Red>[</font><font color=Magenta>0</font><font color=Red>]</font>
<a name="line-79"></a><font color=Blue>expand</font> m n <font color=Red>=</font> reverse <font color=Cyan>$</font> expand_aux m n [] 
<a name="line-80"></a>  <font color=Green><u>where</u></font>
<a name="line-81"></a>    expand_aux <font color=Magenta>0</font> n l <font color=Red>=</font> l
<a name="line-82"></a>    expand_aux m n l <font color=Red>=</font> <font color=Cyan>(</font>m<font color=Blue><i>-</i></font>s<font color=Cyan>)</font> <font color=Red><b>:</b></font> expand_aux r n l <font color=Green><u>where</u></font>
<a name="line-83"></a>      r <font color=Red>=</font> m <font color=Cyan>`div`</font> n
<a name="line-84"></a>      s <font color=Red>=</font> n<font color=Cyan>*</font>r
<a name="line-85"></a>
<a name="line-86"></a><a name="qdiscard_psi_ks"></a><font color=Blue><i>-- | Discard a list of 'Psi_k's</i></font>
<a name="line-87"></a><font color=Blue>qdiscard_psi_ks</font> <font color=Red>::</font> <font color=Red>[</font>Psi_k<font color=Red>]</font> <font color=Red>-&gt;</font> Circ ()
<a name="line-88"></a><font color=Blue>qdiscard_psi_ks</font> l <font color=Red>=</font> <font color=Green><u>do</u></font>
<a name="line-89"></a>  mapM <font color=Cyan>(</font><font color=Red>\</font><font color=Cyan>(</font>q<font color=Cyan>,</font>n<font color=Cyan>)</font> <font color=Red>-&gt;</font> <font color=Green><u>do</u></font>
<a name="line-90"></a>    qdiscard q
<a name="line-91"></a>    return ()<font color=Cyan>)</font> l
<a name="line-92"></a>  return ()
<a name="line-93"></a>
<a name="line-94"></a><a name="find_partners"></a><font color=Blue><i>-- | Given a list of people, and a function assigning a religion to</i></font>
<a name="line-95"></a><font color=Blue><i>-- each person, divide the people into couples of the same religion.</i></font>
<a name="line-96"></a><font color=Blue><i>-- Some people will remain single if there isn't a suitable</i></font>
<a name="line-97"></a><font color=Blue><i>-- partner. Return a list of couples and a list of single people.</i></font>
<a name="line-98"></a><font color=Blue><i>-- </i></font>
<a name="line-99"></a><font color=Blue><i>-- The algorithm proceeds as follows. We have a room for each</i></font>
<a name="line-100"></a><font color=Blue><i>-- religion. Initially the rooms are empty. As each person arrives,</i></font>
<a name="line-101"></a><font color=Blue><i>-- they go to their room. If the room is empty, they stay there. If</i></font>
<a name="line-102"></a><font color=Blue><i>-- the room is occupied, they marry the occupant and join the list</i></font>
<a name="line-103"></a><font color=Blue><i>-- of couples. At the end, all single people are retrieved from</i></font>
<a name="line-104"></a><font color=Blue><i>-- their rooms.</i></font>
<a name="line-105"></a><font color=Blue><i>-- </i></font>
<a name="line-106"></a><font color=Blue><i>-- This function is lazy, i.e., couples are formed as they are</i></font>
<a name="line-107"></a><font color=Blue><i>-- found. Only the singles have to wait until the end of the list.</i></font>
<a name="line-108"></a><font color=Blue><i>-- </i></font>
<a name="line-109"></a><font color=Blue><i>-- Running time is O(/n/ log /n/).</i></font>
<a name="line-110"></a><font color=Blue>find_partners</font> <font color=Red>::</font> <font color=Cyan>(</font>Ord b<font color=Cyan>)</font> <font color=Red>=&gt;</font> <font color=Cyan>(</font>a <font color=Red>-&gt;</font> b<font color=Cyan>)</font> <font color=Red>-&gt;</font> <font color=Red>[</font>a<font color=Red>]</font> <font color=Red>-&gt;</font> <font color=Cyan>(</font><font color=Red>[</font><font color=Cyan>(</font>a<font color=Cyan>,</font>a<font color=Cyan>)</font><font color=Red>]</font><font color=Cyan>,</font> <font color=Red>[</font>a<font color=Red>]</font><font color=Cyan>)</font>
<a name="line-111"></a><font color=Blue>find_partners</font> f <font color=Red>=</font> find_partners_in_rooms Map<font color=Cyan>.</font>empty
<a name="line-112"></a>  <font color=Green><u>where</u></font>
<a name="line-113"></a>    <font color=Blue><i>--find_partners_in_rooms :: Map b a -&gt; [a] -&gt; ([(a,a)], [a])</i></font>
<a name="line-114"></a>    find_partners_in_rooms rooms [] <font color=Red>=</font> <font color=Cyan>(</font>[]<font color=Cyan>,</font> Map<font color=Cyan>.</font>elems rooms<font color=Cyan>)</font>
<a name="line-115"></a>    find_partners_in_rooms rooms <font color=Cyan>(</font>a<font color=Red><b>:</b></font><font color=Green><u>as</u></font><font color=Cyan>)</font> <font color=Red>=</font>
<a name="line-116"></a>      <font color=Green><u>case</u></font> Map<font color=Cyan>.</font>lookup <font color=Cyan>(</font>f a<font color=Cyan>)</font> rooms <font color=Green><u>of</u></font>
<a name="line-117"></a>        Just c <font color=Red>-&gt;</font> <font color=Cyan>(</font><font color=Cyan>(</font>a<font color=Cyan>,</font>c<font color=Cyan>)</font><font color=Red><b>:</b></font>pairs<font color=Cyan>,</font> singles<font color=Cyan>)</font>
<a name="line-118"></a>          <font color=Green><u>where</u></font> <font color=Cyan>(</font>pairs<font color=Cyan>,</font> singles<font color=Cyan>)</font> <font color=Red>=</font> find_partners_in_rooms rooms' <font color=Green><u>as</u></font>
<a name="line-119"></a>                rooms' <font color=Red>=</font> Map<font color=Cyan>.</font>delete <font color=Cyan>(</font>f a<font color=Cyan>)</font> rooms
<a name="line-120"></a>        Nothing <font color=Red>-&gt;</font> find_partners_in_rooms rooms' <font color=Green><u>as</u></font>
<a name="line-121"></a>          <font color=Green><u>where</u></font> rooms' <font color=Red>=</font> Map<font color=Cyan>.</font>insert <font color=Cyan>(</font>f a<font color=Cyan>)</font> a rooms 
<a name="line-122"></a>
<a name="line-123"></a>
<a name="line-124"></a><font color=Blue><i>-- ==============================================================</i></font>
<a name="line-125"></a><font color=Blue><i>-- * Linear algebra</i></font>
<a name="line-126"></a>
<a name="line-127"></a><a name="norm"></a><font color=Blue><i>-- | Compute the Euclidean norm of a vector.</i></font>
<a name="line-128"></a><font color=Blue>norm</font> <font color=Red>::</font> <font color=Red>[</font>Integer<font color=Red>]</font> <font color=Red>-&gt;</font> Float
<a name="line-129"></a><font color=Blue>norm</font> v <font color=Red>=</font> sqrt <font color=Cyan>$</font> fromIntegral <font color=Cyan>$</font> foldl <font color=Cyan>(</font><font color=Cyan>+</font><font color=Cyan>)</font> <font color=Magenta>0</font> <font color=Cyan>$</font> map <font color=Cyan>(</font><font color=Red>\</font>x <font color=Red>-&gt;</font> x<font color=Cyan>^</font><font color=Magenta>2</font><font color=Cyan>)</font> v
<a name="line-130"></a>
<a name="line-131"></a><a name="vector_add"></a><font color=Blue><i>-- | Compute the sum of two vectors.</i></font>
<a name="line-132"></a><font color=Blue>vector_add</font> <font color=Red>::</font> Num a <font color=Red>=&gt;</font> <font color=Red>[</font>a<font color=Red>]</font> <font color=Red>-&gt;</font> <font color=Red>[</font>a<font color=Red>]</font> <font color=Red>-&gt;</font> <font color=Red>[</font>a<font color=Red>]</font> 
<a name="line-133"></a><font color=Blue>vector_add</font> u v <font color=Red>=</font> zipWith <font color=Cyan>(</font><font color=Cyan>+</font><font color=Cyan>)</font> u v
<a name="line-134"></a>
<a name="line-135"></a><a name="q_vector_add"></a><font color=Blue><i>-- | Quantum version of 'vector_add'.</i></font>
<a name="line-136"></a><font color=Blue>q_vector_add</font> <font color=Red>::</font> <font color=Red>[</font>QDInt<font color=Red>]</font> <font color=Red>-&gt;</font> <font color=Red>[</font>QDInt<font color=Red>]</font> <font color=Red>-&gt;</font> Circ <font color=Red>[</font>QDInt<font color=Red>]</font>
<a name="line-137"></a><font color=Blue>q_vector_add</font> u v <font color=Red>=</font> <font color=Green><u>do</u></font>
<a name="line-138"></a>  w <font color=Red>&lt;-</font> zipWithM q_add u v
<a name="line-139"></a>  return <font color=Cyan>(</font>map <font color=Cyan>(</font><font color=Red>\</font><font color=Cyan>(</font><font color=Green><u>_</u></font><font color=Cyan>,</font><font color=Green><u>_</u></font><font color=Cyan>,</font>z<font color=Cyan>)</font> <font color=Red>-&gt;</font> z<font color=Cyan>)</font> w<font color=Cyan>)</font>
<a name="line-140"></a>
<a name="line-141"></a><a name="scalar_mult"></a><font color=Blue><i>-- | Compute the multiplication of a scalar with a vector.</i></font>
<a name="line-142"></a><font color=Blue>scalar_mult</font> <font color=Red>::</font> Num a <font color=Red>=&gt;</font> a <font color=Red>-&gt;</font> <font color=Red>[</font>a<font color=Red>]</font> <font color=Red>-&gt;</font> <font color=Red>[</font>a<font color=Red>]</font>
<a name="line-143"></a><font color=Blue>scalar_mult</font> n v <font color=Red>=</font> map <font color=Cyan>(</font><font color=Red>\</font>x <font color=Red>-&gt;</font> n<font color=Cyan>*</font>x<font color=Cyan>)</font> v
<a name="line-144"></a>
<a name="line-145"></a><a name="q_scalar_mult"></a><font color=Blue><i>-- | Quantum version of 'scalar_mult'.</i></font>
<a name="line-146"></a><font color=Blue>q_scalar_mult</font> <font color=Red>::</font> QDInt <font color=Red>-&gt;</font> <font color=Red>[</font>QDInt<font color=Red>]</font> <font color=Red>-&gt;</font> Circ <font color=Red>[</font>QDInt<font color=Red>]</font>
<a name="line-147"></a><font color=Blue>q_scalar_mult</font> a v <font color=Red>=</font> <font color=Green><u>do</u></font>
<a name="line-148"></a>  v' <font color=Red>&lt;-</font> mapM <font color=Cyan>(</font><font color=Red>\</font>u <font color=Red>-&gt;</font> <font color=Green><u>do</u></font>
<a name="line-149"></a>    <font color=Cyan>(</font><font color=Green><u>_</u></font><font color=Cyan>,</font><font color=Green><u>_</u></font><font color=Cyan>,</font>z<font color=Cyan>)</font> <font color=Red>&lt;-</font> q_mult a u
<a name="line-150"></a>    return z<font color=Cyan>)</font> v
<a name="line-151"></a>  return v'
<a name="line-152"></a>
<a name="line-153"></a><a name="matrix_mult"></a><font color=Blue><i>-- | Multiply an /n/&#215;/m/-matrix by an /m/-dimensional column </i></font>
<a name="line-154"></a><font color=Blue><i>-- vector to obtain an /n/-dimensional column vector. The </i></font>
<a name="line-155"></a><font color=Blue><i>-- matrix is represented as a list of /m/ columns. </i></font>
<a name="line-156"></a><font color=Blue><i>-- </i></font>
<a name="line-157"></a><font color=Blue><i>-- Precondition: /m/ &gt; 0.</i></font>
<a name="line-158"></a><font color=Blue><i>-- </i></font>
<a name="line-159"></a><font color=Blue><i>-- Example:</i></font>
<a name="line-160"></a><font color=Blue><i>-- </i></font>
<a name="line-161"></a><font color=Blue><i>-- &gt; matrix_mult [[1,2,3],[1,0,0]] [1,1] = [2,2,3]</i></font>
<a name="line-162"></a><font color=Blue>matrix_mult</font> <font color=Red>::</font> <font color=Red>[</font><font color=Red>[</font>Integer<font color=Red>]</font><font color=Red>]</font> <font color=Red>-&gt;</font> <font color=Red>[</font>Integer<font color=Red>]</font> <font color=Red>-&gt;</font> <font color=Red>[</font>Integer<font color=Red>]</font>
<a name="line-163"></a><font color=Blue>matrix_mult</font> m a <font color=Red>=</font> foldl vector_add zero <font color=Cyan>$</font> zipWith scalar_mult a m
<a name="line-164"></a>  <font color=Green><u>where</u></font>
<a name="line-165"></a>    zero <font color=Red>=</font> replicate <font color=Cyan>(</font>length <font color=Cyan>(</font>head m<font color=Cyan>)</font><font color=Cyan>)</font> <font color=Magenta>0</font>
<a name="line-166"></a>
<a name="line-167"></a><a name="q_matrix_mult"></a><font color=Blue><i>-- | Quantum version of 'matrix_mult'.</i></font>
<a name="line-168"></a><font color=Blue>q_matrix_mult</font> <font color=Red>::</font> <font color=Red>[</font><font color=Red>[</font>QDInt<font color=Red>]</font><font color=Red>]</font> <font color=Red>-&gt;</font> <font color=Red>[</font>QDInt<font color=Red>]</font> <font color=Red>-&gt;</font> Circ <font color=Red>[</font>QDInt<font color=Red>]</font>
<a name="line-169"></a><font color=Blue>q_matrix_mult</font> m a <font color=Red>=</font> <font color=Green><u>do</u></font>
<a name="line-170"></a>  <font color=Green><u>let</u></font> l1 <font color=Red>=</font> length <font color=Cyan>(</font>head m<font color=Cyan>)</font>
<a name="line-171"></a>      l2 <font color=Red>=</font> qdint_length <font color=Cyan>(</font>head a<font color=Cyan>)</font>
<a name="line-172"></a>  zero <font color=Red>&lt;-</font> qinit <font color=Cyan>(</font>replicate l1 <font color=Cyan>(</font>intm l2 <font color=Magenta>0</font><font color=Cyan>)</font><font color=Cyan>)</font>
<a name="line-173"></a>  m <font color=Red>&lt;-</font> zipWithM q_scalar_mult a m
<a name="line-174"></a>  result <font color=Red>&lt;-</font> foldM q_vector_add zero m
<a name="line-175"></a>  return result
<a name="line-176"></a>
<a name="line-177"></a><a name="is_zero_vector"></a><font color=Blue><i>-- | Check whether a vector is 0.</i></font>
<a name="line-178"></a><font color=Blue>is_zero_vector</font> <font color=Red>::</font> <font color=Red>[</font>Integer<font color=Red>]</font> <font color=Red>-&gt;</font> Bool
<a name="line-179"></a><font color=Blue>is_zero_vector</font> <font color=Red>=</font> all <font color=Cyan>(</font><font color=Cyan>==</font> <font color=Magenta>0</font><font color=Cyan>)</font>
<a name="line-180"></a>
<a name="line-181"></a>
<a name="line-182"></a><font color=Blue><i>-- ==============================================================</i></font>
<a name="line-183"></a><font color=Blue><i>-- * Euclid's algorithm</i></font>
<a name="line-184"></a>
<a name="line-185"></a><a name="ext_euclid"></a><font color=Blue><i>-- | The extended Euclidean algorithm. 'ext_euclid' /a/ /b/ returns</i></font>
<a name="line-186"></a><font color=Blue><i>-- (/x/, /y/, /z/, /w/, /d/) such that:</i></font>
<a name="line-187"></a><font color=Blue><i>-- </i></font>
<a name="line-188"></a><font color=Blue><i>-- * 0 &#8804; /d/ = gcd(/a/, /b/), the greatest common divisor of /a/ and</i></font>
<a name="line-189"></a><font color=Blue><i>-- /b/;</i></font>
<a name="line-190"></a><font color=Blue><i>-- </i></font>
<a name="line-191"></a><font color=Blue><i>-- * /ax/ + /by/ = /d/;</i></font>
<a name="line-192"></a><font color=Blue><i>-- </i></font>
<a name="line-193"></a><font color=Blue><i>-- * /az/ + /bw/ = 0;</i></font>
<a name="line-194"></a><font color=Blue><i>-- </i></font>
<a name="line-195"></a><font color=Blue><i>-- * the determinant /xw/ - /yz/ = 1.</i></font>
<a name="line-196"></a><font color=Blue>ext_euclid</font> <font color=Red>::</font> Integer <font color=Red>-&gt;</font> Integer <font color=Red>-&gt;</font> <font color=Cyan>(</font>Integer<font color=Cyan>,</font> Integer<font color=Cyan>,</font> Integer<font color=Cyan>,</font> Integer<font color=Cyan>,</font> Integer<font color=Cyan>)</font>
<a name="line-197"></a><font color=Blue>ext_euclid</font> a b <font color=Red>=</font> ext_euclid_rec <font color=Magenta>1</font> <font color=Magenta>0</font> <font color=Magenta>0</font> <font color=Magenta>1</font> a b <font color=Magenta>1</font> <font color=Green><u>where</u></font>
<a name="line-198"></a>  
<a name="line-199"></a>  <font color=Blue><i>-- the invariants for ext_euclid_rec are:</i></font>
<a name="line-200"></a>  <font color=Blue><i>-- </i></font>
<a name="line-201"></a>  <font color=Blue><i>-- [ x y ] [ a ]  =  [ r ]</i></font>
<a name="line-202"></a>  <font color=Blue><i>-- [ z w ] [ b ]     [ s ]</i></font>
<a name="line-203"></a>  <font color=Blue><i>-- </i></font>
<a name="line-204"></a>  <font color=Blue><i>-- and det [[x y] [z w]] = t = &#177;1.</i></font>
<a name="line-205"></a>  
<a name="line-206"></a>  ext_euclid_rec x y z w r s t <font color=Red>|</font> r <font color=Cyan>&lt;</font> <font color=Magenta>0</font> <font color=Red>=</font>
<a name="line-207"></a>    ext_euclid_rec <font color=Cyan>(</font><font color=Blue><i>-</i></font>x<font color=Cyan>)</font> <font color=Cyan>(</font><font color=Blue><i>-</i></font>y<font color=Cyan>)</font> z w <font color=Cyan>(</font><font color=Blue><i>-</i></font>r<font color=Cyan>)</font> s <font color=Cyan>(</font><font color=Blue><i>-</i></font>t<font color=Cyan>)</font>
<a name="line-208"></a>  ext_euclid_rec x y z w r s t <font color=Red>|</font> s <font color=Cyan>&lt;</font> <font color=Magenta>0</font> <font color=Red>=</font> 
<a name="line-209"></a>    ext_euclid_rec x y <font color=Cyan>(</font><font color=Blue><i>-</i></font>z<font color=Cyan>)</font> <font color=Cyan>(</font><font color=Blue><i>-</i></font>w<font color=Cyan>)</font> r <font color=Cyan>(</font><font color=Blue><i>-</i></font>s<font color=Cyan>)</font> <font color=Cyan>(</font><font color=Blue><i>-</i></font>t<font color=Cyan>)</font>
<a name="line-210"></a>  ext_euclid_rec x y z w r s t <font color=Red>|</font> r <font color=Cyan>&lt;</font> s <font color=Red>=</font> 
<a name="line-211"></a>    ext_euclid_rec z w x y s r <font color=Cyan>(</font><font color=Blue><i>-</i></font>t<font color=Cyan>)</font>
<a name="line-212"></a>  ext_euclid_rec x y z w r s t <font color=Red>|</font> <font color=Magenta>0</font> <font color=Cyan>&lt;</font> s <font color=Red>=</font>
<a name="line-213"></a>    ext_euclid_rec z w <font color=Cyan>(</font>x<font color=Blue><i>-</i></font>q<font color=Cyan>*</font>z<font color=Cyan>)</font> <font color=Cyan>(</font>y<font color=Blue><i>-</i></font>q<font color=Cyan>*</font>w<font color=Cyan>)</font> s <font color=Cyan>(</font>r<font color=Blue><i>-</i></font>q<font color=Cyan>*</font>s<font color=Cyan>)</font> <font color=Cyan>(</font><font color=Blue><i>-</i></font>t<font color=Cyan>)</font>
<a name="line-214"></a>    <font color=Green><u>where</u></font> q <font color=Red>=</font> r <font color=Cyan>`div`</font> s
<a name="line-215"></a>  ext_euclid_rec x y z w r s t <font color=Red>=</font> <font color=Blue><i>-- Note: s = 0, r &#8805; 0.</i></font>
<a name="line-216"></a>    <font color=Cyan>(</font>x<font color=Cyan>,</font> y<font color=Cyan>,</font> t<font color=Cyan>*</font>z<font color=Cyan>,</font> t<font color=Cyan>*</font>w<font color=Cyan>,</font> r<font color=Cyan>)</font>
<a name="line-217"></a>
<a name="line-218"></a>
<a name="line-219"></a><font color=Blue><i>-- ==============================================================</i></font>
<a name="line-220"></a><font color=Blue><i>-- * Classical subroutines </i></font>
<a name="line-221"></a>
<a name="line-222"></a><a name="lll"></a><font color=Blue><i>-- | Reduce a basis using the Lenstra-Lenstra-Lov&#225;scz algorithm.</i></font>
<a name="line-223"></a><font color=Blue><i>--</i></font>
<a name="line-224"></a><font color=Blue><i>-- Uses the corresponding Haskell library. </i></font>
<a name="line-225"></a><font color=Blue>lll</font> <font color=Red>::</font> <font color=Red>[</font><font color=Red>[</font>Integer<font color=Red>]</font><font color=Red>]</font> <font color=Red>-&gt;</font> <font color=Red>[</font><font color=Red>[</font>Integer<font color=Red>]</font><font color=Red>]</font>
<a name="line-226"></a><font color=Blue>lll</font> bb <font color=Red>=</font> bb_reduced_integral
<a name="line-227"></a>  <font color=Green><u>where</u></font>
<a name="line-228"></a>    bb_rational <font color=Red>=</font> map <font color=Cyan>(</font><font color=Red>\</font>v <font color=Red>-&gt;</font> map toRational v<font color=Cyan>)</font> bb
<a name="line-229"></a>    bb_reduced <font color=Red>=</font> Math<font color=Cyan>.</font>Lattices<font color=Cyan>.</font>LLL<font color=Cyan>.</font>lll bb_rational
<a name="line-230"></a>    bb_reduced_integral <font color=Red>=</font> map <font color=Cyan>(</font><font color=Red>\</font>v <font color=Red>-&gt;</font> map ceiling v<font color=Cyan>)</font> <font color=Cyan>(</font>elems bb_reduced<font color=Cyan>)</font>
<a name="line-231"></a>
<a name="line-232"></a><a name="find_prime"></a><font color=Blue><i>-- | Given an integer /m/, find the smallest prime /p/ such that /m/ &#8804;</i></font>
<a name="line-233"></a><font color=Blue><i>-- /p/ &#8804; 2/m/.</i></font>
<a name="line-234"></a><font color=Blue><i>-- </i></font>
<a name="line-235"></a><font color=Blue><i>-- Uses preexisting 'isPrime' algorithm. </i></font>
<a name="line-236"></a><font color=Blue>find_prime</font> <font color=Red>::</font> Int <font color=Red>-&gt;</font> Int
<a name="line-237"></a><font color=Blue>find_prime</font> m <font color=Red>=</font> head <font color=Cyan>$</font> filter isPrime <font color=Red>[</font><font color=Cyan>(</font>m<font color=Cyan>)</font><font color=Red>..</font><font color=Cyan>(</font><font color=Magenta>2</font><font color=Cyan>*</font>m<font color=Cyan>)</font><font color=Red>]</font>
<a name="line-238"></a>
<a name="line-239"></a><a name="is_in_lattice"></a><font color=Blue><i>-- | Given a vector /u/ and a basis /bb/ = [/b/[sub 0], &#8230;, </i></font>
<a name="line-240"></a><font color=Blue><i>-- /b/[sub /n/-1]], determine whether /u/ belongs to the lattice</i></font>
<a name="line-241"></a><font color=Blue><i>-- generated by /bb/, i.e., whether there exist integers /a/[sub 0],</i></font>
<a name="line-242"></a><font color=Blue><i>-- &#8230;, /a/[sub /n/-1] such that /u/ = /a/[sub 0]/b/[sub 0] + &#8230; +</i></font>
<a name="line-243"></a><font color=Blue><i>-- /a/[sub /n/-1]/b/[sub /n/-1]. </i></font>
<a name="line-244"></a><font color=Blue><i>-- </i></font>
<a name="line-245"></a><font color=Blue><i>-- Precondition: /u/ and /b/[sub 0], &#8230;, /b/[sub /n/-1] must all be</i></font>
<a name="line-246"></a><font color=Blue><i>-- of the same dimension.</i></font>
<a name="line-247"></a><font color=Blue><i>-- </i></font>
<a name="line-248"></a><font color=Blue><i>-- The algorithm proceeds as follows: first, do invertible integer</i></font>
<a name="line-249"></a><font color=Blue><i>-- column operations on /b/[sub 0], &#8230;, /b/[sub /n/-1] until the top</i></font>
<a name="line-250"></a><font color=Blue><i>-- entries of /b/[sub 1], &#8230;, /b/[sub /n/-1] are 0. This can be done</i></font>
<a name="line-251"></a><font color=Blue><i>-- efficiently by using the extended Euclidean algorithm for two</i></font>
<a name="line-252"></a><font color=Blue><i>-- columns at a time. Then check whether the top entry of /b/[sub 0]</i></font>
<a name="line-253"></a><font color=Blue><i>-- divides the top entry of /u/. If no, output 'False'. Otherwise, if</i></font>
<a name="line-254"></a><font color=Blue><i>-- the top entry of /b/[sub 0] is 0, drop the top row and continue</i></font>
<a name="line-255"></a><font color=Blue><i>-- recursively. Otherwise, subtract an appropriate multiple of </i></font>
<a name="line-256"></a><font color=Blue><i>-- /b/[sub 0] from /u/, drop /b/[sub 0], drop the top row, and</i></font>
<a name="line-257"></a><font color=Blue><i>-- continue recursively. Trivial base cases occur when the number of</i></font>
<a name="line-258"></a><font color=Blue><i>-- rows or columns reaches 0.</i></font>
<a name="line-259"></a><font color=Blue>is_in_lattice</font> <font color=Red>::</font> <font color=Red>[</font>Integer<font color=Red>]</font> <font color=Red>-&gt;</font> <font color=Red>[</font><font color=Red>[</font>Integer<font color=Red>]</font><font color=Red>]</font> <font color=Red>-&gt;</font> Bool
<a name="line-260"></a><font color=Blue>is_in_lattice</font> [] bb <font color=Red>=</font> True
<a name="line-261"></a><font color=Blue>is_in_lattice</font> u [] <font color=Red>=</font> is_zero_vector u
<a name="line-262"></a><font color=Blue>is_in_lattice</font> <font color=Cyan>(</font>u0<font color=Red><b>:</b></font>us<font color=Cyan>)</font> <font color=Cyan>(</font>b0<font color=Red><b>:</b></font>bs<font color=Cyan>)</font> <font color=Red>=</font>
<a name="line-263"></a>  <font color=Green><u>let</u></font> <font color=Cyan>(</font>c00<font color=Red><b>:</b></font>c0s<font color=Cyan>,</font> cs<font color=Cyan>)</font> <font color=Red>=</font> mapAccumL column_op b0 bs <font color=Green><u>in</u></font>
<a name="line-264"></a>  <font color=Green><u>if</u></font> c00 <font color=Cyan>==</font> <font color=Magenta>0</font> 
<a name="line-265"></a>  <font color=Green><u>then</u></font> <font color=Green><u>if</u></font> u0 <font color=Cyan>/=</font> <font color=Magenta>0</font> 
<a name="line-266"></a>       <font color=Green><u>then</u></font> False 
<a name="line-267"></a>       <font color=Green><u>else</u></font> is_in_lattice us <font color=Cyan>(</font>c0s<font color=Red><b>:</b></font>cs<font color=Cyan>)</font>
<a name="line-268"></a>  <font color=Green><u>else</u></font> <font color=Green><u>if</u></font> u0 <font color=Cyan>`mod`</font> c00 <font color=Cyan>/=</font> <font color=Magenta>0</font>
<a name="line-269"></a>       <font color=Green><u>then</u></font> False
<a name="line-270"></a>       <font color=Green><u>else</u></font> 
<a name="line-271"></a>         <font color=Green><u>let</u></font> q <font color=Red>=</font> u0 <font color=Cyan>`div`</font> c00    
<a name="line-272"></a>             us' <font color=Red>=</font> us <font color=Cyan>`vector_add`</font> <font color=Cyan>(</font><font color=Cyan>(</font><font color=Blue><i>-</i></font>q<font color=Cyan>)</font> <font color=Cyan>`scalar_mult`</font> c0s<font color=Cyan>)</font>
<a name="line-273"></a>         <font color=Green><u>in</u></font> is_in_lattice us' cs
<a name="line-274"></a>
<a name="line-275"></a><a name="reduce_lattice"></a><font color=Blue><i>-- | Given a basis /bb/ = [/b/[sub 0], &#8230;, /b/[sub /n/-1]], find</i></font>
<a name="line-276"></a><font color=Blue><i>-- another equivalent basis whose elements are linearly independent.</i></font>
<a name="line-277"></a><font color=Blue>reduce_lattice</font> <font color=Red>::</font> <font color=Red>[</font><font color=Red>[</font>Integer<font color=Red>]</font><font color=Red>]</font> <font color=Red>-&gt;</font> <font color=Red>[</font><font color=Red>[</font>Integer<font color=Red>]</font><font color=Red>]</font>
<a name="line-278"></a><font color=Blue>reduce_lattice</font> [] <font color=Red>=</font> []
<a name="line-279"></a><font color=Blue>reduce_lattice</font> <font color=Cyan>(</font>[]<font color=Red><b>:</b></font>bs<font color=Cyan>)</font> <font color=Red>=</font> []
<a name="line-280"></a><font color=Blue>reduce_lattice</font> <font color=Cyan>(</font>b0<font color=Red><b>:</b></font>bs<font color=Cyan>)</font> <font color=Red>=</font>
<a name="line-281"></a>  <font color=Green><u>let</u></font> <font color=Cyan>(</font>c0<font color=Cyan>,</font> cs<font color=Cyan>)</font> <font color=Red>=</font> mapAccumL column_op b0 bs <font color=Green><u>in</u></font>
<a name="line-282"></a>  <font color=Green><u>case</u></font> c0 <font color=Green><u>of</u></font>
<a name="line-283"></a>    <font color=Magenta>0</font> <font color=Red><b>:</b></font> c0s <font color=Red>-&gt;</font> <font color=Red>[</font> <font color=Magenta>0</font><font color=Red><b>:</b></font>x <font color=Red>|</font> x <font color=Red>&lt;-</font> reduce_lattice <font color=Cyan>(</font>c0s<font color=Red><b>:</b></font>cs<font color=Cyan>)</font> <font color=Red>]</font>
<a name="line-284"></a>    <font color=Green><u>_</u></font>  <font color=Red>-&gt;</font> c0 <font color=Red><b>:</b></font> <font color=Red>[</font> <font color=Magenta>0</font><font color=Red><b>:</b></font>x <font color=Red>|</font> x <font color=Red>&lt;-</font> reduce_lattice cs <font color=Red>]</font>
<a name="line-285"></a>  
<a name="line-286"></a><a name="column_op"></a><font color=Blue><i>-- | Perform a reversible column operation on two integer vectors,</i></font>
<a name="line-287"></a><font color=Blue><i>-- creating (and then dropping) a leading zero in the second vector.</i></font>
<a name="line-288"></a><font color=Blue>column_op</font> <font color=Red>::</font> <font color=Red>[</font>Integer<font color=Red>]</font> <font color=Red>-&gt;</font> <font color=Red>[</font>Integer<font color=Red>]</font> <font color=Red>-&gt;</font> <font color=Cyan>(</font><font color=Red>[</font>Integer<font color=Red>]</font><font color=Cyan>,</font> <font color=Red>[</font>Integer<font color=Red>]</font><font color=Cyan>)</font>
<a name="line-289"></a><font color=Blue>column_op</font> <font color=Cyan>(</font>m<font color=Red><b>:</b></font>ms<font color=Cyan>)</font> <font color=Cyan>(</font>n<font color=Red><b>:</b></font>ns<font color=Cyan>)</font> <font color=Red>=</font> <font color=Cyan>(</font>m'<font color=Red><b>:</b></font>ms'<font color=Cyan>,</font> ns'<font color=Cyan>)</font> <font color=Green><u>where</u></font>
<a name="line-290"></a>  <font color=Cyan>(</font>x<font color=Cyan>,</font> y<font color=Cyan>,</font> z<font color=Cyan>,</font> w<font color=Cyan>,</font> d<font color=Cyan>)</font> <font color=Red>=</font> ext_euclid m n
<a name="line-291"></a>  m' <font color=Red>=</font> x<font color=Cyan>*</font>m <font color=Cyan>+</font> y<font color=Cyan>*</font>n  <font color=Blue><i>-- m' == d by extended Euclid's algorithm</i></font>
<a name="line-292"></a>  n' <font color=Red>=</font> z<font color=Cyan>*</font>m <font color=Cyan>+</font> w<font color=Cyan>*</font>n  <font color=Blue><i>-- n' == 0 by extended Euclid's algorithm</i></font>
<a name="line-293"></a>  ms' <font color=Red>=</font> <font color=Cyan>(</font>x <font color=Cyan>`scalar_mult`</font> ms<font color=Cyan>)</font> <font color=Cyan>`vector_add`</font> <font color=Cyan>(</font>y <font color=Cyan>`scalar_mult`</font> ns<font color=Cyan>)</font>
<a name="line-294"></a>  ns' <font color=Red>=</font> <font color=Cyan>(</font>z <font color=Cyan>`scalar_mult`</font> ms<font color=Cyan>)</font> <font color=Cyan>`vector_add`</font> <font color=Cyan>(</font>w <font color=Cyan>`scalar_mult`</font> ns<font color=Cyan>)</font>
<a name="line-295"></a><font color=Blue>column_op</font> <font color=Green><u>_</u></font> <font color=Green><u>_</u></font> <font color=Red>=</font> error <font color=Magenta>"is_in_lattice: dimension mismatch"</font>
<a name="line-296"></a>
</pre>
</body>
</html>