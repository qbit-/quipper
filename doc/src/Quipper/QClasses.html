<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<!-- Generated by HsColour, http://code.haskell.org/~malcolm/hscolour/ -->
<title>Haskell code</title>
</head>
<body>
<pre><a name="line-1"></a><font color=Blue><i>{-# LANGUAGE MultiParamTypeClasses #-}</i></font>
<a name="line-2"></a><font color=Blue><i>{-# LANGUAGE FlexibleInstances #-}</i></font>
<a name="line-3"></a><font color=Blue><i>{-# LANGUAGE UndecidableInstances #-}</i></font>
<a name="line-4"></a><font color=Blue><i>{-# LANGUAGE FlexibleContexts #-}</i></font>
<a name="line-5"></a>
<a name="line-6"></a><font color=Blue><i>-- | This module defines quantum analogues of some Haskell type</i></font>
<a name="line-7"></a><font color=Blue><i>-- classes. For instance, Haskell&#8217;s @'Eq' a@ has one method</i></font>
<a name="line-8"></a><font color=Blue><i>-- </i></font>
<a name="line-9"></a><font color=Blue><i>-- &gt; (==) :: a -&gt; a -&gt; Bool.  </i></font>
<a name="line-10"></a><font color=Blue><i>-- </i></font>
<a name="line-11"></a><font color=Blue><i>-- Correspondingly, our @'QEq' a qa ca@ has a method</i></font>
<a name="line-12"></a><font color=Blue><i>-- </i></font>
<a name="line-13"></a><font color=Blue><i>-- &gt; q_is_equal :: qa -&gt; qa -&gt; Circ (qa,qa,Qubit).  </i></font>
<a name="line-14"></a><font color=Blue><i>-- </i></font>
<a name="line-15"></a><font color=Blue><i>-- All quantum type classes assume that their instance types are</i></font>
<a name="line-16"></a><font color=Blue><i>-- 'QData' (or sometimes 'QCData').</i></font>
<a name="line-17"></a><font color=Blue><i>-- </i></font>
<a name="line-18"></a><font color=Blue><i>-- Quantum type classes are designed to play nicely with the</i></font>
<a name="line-19"></a><font color=Blue><i>-- translation of "Quipper.CircLifting". </i></font>
<a name="line-20"></a>
<a name="line-21"></a><font color=Green><u>module</u></font> Quipper<font color=Cyan>.</font>QClasses <font color=Green><u>where</u></font>
<a name="line-22"></a>
<a name="line-23"></a><font color=Green><u>import</u></font> Quipper<font color=Cyan>.</font>Generic
<a name="line-24"></a><font color=Green><u>import</u></font> Quipper<font color=Cyan>.</font>QData
<a name="line-25"></a><font color=Green><u>import</u></font> Quipper<font color=Cyan>.</font>Monad
<a name="line-26"></a>
<a name="line-27"></a><font color=Blue><i>-- ----------------------------------------------------------------------</i></font>
<a name="line-28"></a><font color=Blue><i>-- * The type class QEq</i></font>
<a name="line-29"></a>
<a name="line-30"></a><a name="QEq"></a><font color=Blue><i>-- | This is a quantum analogue of Haskell&#8217;s 'Eq' type class. Default</i></font>
<a name="line-31"></a><a name="QEq"></a><font color=Blue><i>-- implementations are provided; by default, equality is bitwise</i></font>
<a name="line-32"></a><a name="QEq"></a><font color=Blue><i>-- equality of the underlying data structure. However, specific</i></font>
<a name="line-33"></a><a name="QEq"></a><font color=Blue><i>-- instances can provide custom implementations. In this case,</i></font>
<a name="line-34"></a><a name="QEq"></a><font color=Blue><i>-- 'q_is_equal' is a minimal complete definition.</i></font>
<a name="line-35"></a><a name="QEq"></a><font color=Green><u>class</u></font> <font color=Cyan>(</font>QCData qc<font color=Cyan>)</font> <font color=Red>=&gt;</font> QEq qc <font color=Green><u>where</u></font>
<a name="line-36"></a>  
<a name="line-37"></a>  <font color=Blue><i>-- | Test for equality. </i></font>
<a name="line-38"></a>  q_is_equal <font color=Red>::</font> qc <font color=Red>-&gt;</font> qc <font color=Red>-&gt;</font> Circ <font color=Cyan>(</font>qc<font color=Cyan>,</font> qc<font color=Cyan>,</font> Qubit<font color=Cyan>)</font>
<a name="line-39"></a>  q_is_equal qx qy <font color=Red>=</font> <font color=Green><u>do</u></font>
<a name="line-40"></a>    <font color=Cyan>(</font>qx<font color=Cyan>,</font>qy<font color=Cyan>)</font> <font color=Red>&lt;-</font> controlled_not qx qy
<a name="line-41"></a>    test <font color=Red>&lt;-</font> qinit False
<a name="line-42"></a>    test <font color=Red>&lt;-</font> qnot test <font color=Cyan>`controlled`</font> qx <font color=Cyan>.==.</font> qc_false qx
<a name="line-43"></a>    <font color=Cyan>(</font>qx<font color=Cyan>,</font>qy<font color=Cyan>)</font> <font color=Red>&lt;-</font> reverse_generic_endo controlled_not qx qy
<a name="line-44"></a>    return <font color=Cyan>(</font>qx<font color=Cyan>,</font>qy<font color=Cyan>,</font>test<font color=Cyan>)</font>
<a name="line-45"></a>  
<a name="line-46"></a>  <font color=Blue><i>-- | Test for inequality.</i></font>
<a name="line-47"></a>  q_is_not_equal <font color=Red>::</font> qc <font color=Red>-&gt;</font> qc <font color=Red>-&gt;</font> Circ <font color=Cyan>(</font>qc<font color=Cyan>,</font> qc<font color=Cyan>,</font> Qubit<font color=Cyan>)</font>
<a name="line-48"></a>  q_is_not_equal qx qy <font color=Red>=</font> <font color=Green><u>do</u></font>
<a name="line-49"></a>    <font color=Cyan>(</font>qx<font color=Cyan>,</font>qy<font color=Cyan>,</font>test<font color=Cyan>)</font> <font color=Red>&lt;-</font> q_is_equal qx qy
<a name="line-50"></a>    qnot_at test
<a name="line-51"></a>    return <font color=Cyan>(</font>qx<font color=Cyan>,</font>qy<font color=Cyan>,</font>test<font color=Cyan>)</font>
<a name="line-52"></a>
<a name="line-53"></a><a name="instance%20QEq%20qc"></a><font color=Blue><i>-- Right now we make all QCData an instance of 'QEq', and the equality</i></font>
<a name="line-54"></a><a name="instance%20QEq%20qc"></a><font color=Blue><i>-- is always physical equality. In the future we will probably want to</i></font>
<a name="line-55"></a><a name="instance%20QEq%20qc"></a><font color=Blue><i>-- replace this by instances for specific types. </i></font>
<a name="line-56"></a><a name="instance%20QEq%20qc"></a><font color=Green><u>instance</u></font> <font color=Cyan>(</font>QCData qc<font color=Cyan>)</font> <font color=Red>=&gt;</font> QEq qc
<a name="line-57"></a>
<a name="line-58"></a><font color=Blue><i>-- ----------------------------------------------------------------------</i></font>
<a name="line-59"></a><font color=Blue><i>-- * The type class QOrd</i></font>
<a name="line-60"></a>
<a name="line-61"></a><a name="QOrd"></a><font color=Blue><i>-- | This is a quantum analogue of Haskell's 'Ord' type class. Its</i></font>
<a name="line-62"></a><a name="QOrd"></a><font color=Blue><i>-- purpose is to define a total ordering on each of its instances. The</i></font>
<a name="line-63"></a><a name="QOrd"></a><font color=Blue><i>-- functions in this class are assumed dirty in the sense that they do</i></font>
<a name="line-64"></a><a name="QOrd"></a><font color=Blue><i>-- not uncompute ancillas, and some of the inputs may be returned as</i></font>
<a name="line-65"></a><a name="QOrd"></a><font color=Blue><i>-- outputs. The functions are also assumed to be non-linear safe,</i></font>
<a name="line-66"></a><a name="QOrd"></a><font color=Blue><i>-- i.e., they apply no gates to their inputs except as control</i></font>
<a name="line-67"></a><a name="QOrd"></a><font color=Blue><i>-- sources. Minimal complete definition: 'q_less' or 'q_greater'. The default</i></font>
<a name="line-68"></a><a name="QOrd"></a><font color=Blue><i>-- implementations of 'q_max' and 'q_min' assume that both arguments</i></font>
<a name="line-69"></a><a name="QOrd"></a><font color=Blue><i>-- are of the same shape (for example, numbers of the same length).</i></font>
<a name="line-70"></a><a name="QOrd"></a><font color=Green><u>class</u></font> <font color=Cyan>(</font>QEq qa<font color=Cyan>,</font> QData qa<font color=Cyan>)</font> <font color=Red>=&gt;</font> QOrd qa <font color=Green><u>where</u></font>
<a name="line-71"></a>  <font color=Blue><i>-- | Test for less than.  </i></font>
<a name="line-72"></a>  q_less <font color=Red>::</font> qa <font color=Red>-&gt;</font> qa <font color=Red>-&gt;</font> Circ Qubit
<a name="line-73"></a>  q_less x y <font color=Red>=</font> q_greater y x
<a name="line-74"></a>
<a name="line-75"></a>  <font color=Blue><i>-- | Test for greater than.</i></font>
<a name="line-76"></a>  q_greater <font color=Red>::</font> qa <font color=Red>-&gt;</font> qa <font color=Red>-&gt;</font> Circ Qubit
<a name="line-77"></a>  q_greater x y <font color=Red>=</font> q_less y x
<a name="line-78"></a>    
<a name="line-79"></a>  <font color=Blue><i>-- | Test for less than or equal.</i></font>
<a name="line-80"></a>  q_leq <font color=Red>::</font> qa <font color=Red>-&gt;</font> qa <font color=Red>-&gt;</font> Circ Qubit
<a name="line-81"></a>  q_leq x y <font color=Red>=</font> <font color=Green><u>do</u></font>
<a name="line-82"></a>    s <font color=Red>&lt;-</font> q_greater x y
<a name="line-83"></a>    r <font color=Red>&lt;-</font> qinit False   
<a name="line-84"></a>    qnot_at r <font color=Cyan>`controlled`</font> s <font color=Cyan>.==.</font> False
<a name="line-85"></a>    return r
<a name="line-86"></a>
<a name="line-87"></a>  <font color=Blue><i>-- | Test for greater than or equal.</i></font>
<a name="line-88"></a>  q_geq <font color=Red>::</font> qa <font color=Red>-&gt;</font> qa <font color=Red>-&gt;</font> Circ Qubit
<a name="line-89"></a>  q_geq x y <font color=Red>=</font> q_leq y x
<a name="line-90"></a>    
<a name="line-91"></a>  <font color=Blue><i>-- | Compute the maximum of two values.</i></font>
<a name="line-92"></a>  q_max <font color=Red>::</font> qa <font color=Red>-&gt;</font> qa <font color=Red>-&gt;</font> Circ qa
<a name="line-93"></a>  q_max x y <font color=Red>=</font> <font color=Green><u>do</u></font>
<a name="line-94"></a>    q <font color=Red>&lt;-</font> q_greater x y
<a name="line-95"></a>    z <font color=Red>&lt;-</font> qinit <font color=Cyan>$</font> qc_false x
<a name="line-96"></a>    <font color=Cyan>(</font>z<font color=Cyan>,</font>x<font color=Cyan>)</font> <font color=Red>&lt;-</font> controlled_not z x <font color=Cyan>`controlled`</font> q <font color=Cyan>.==.</font> True
<a name="line-97"></a>    <font color=Cyan>(</font>z<font color=Cyan>,</font>y<font color=Cyan>)</font> <font color=Red>&lt;-</font> controlled_not z y <font color=Cyan>`controlled`</font> q <font color=Cyan>.==.</font> False
<a name="line-98"></a>    return z
<a name="line-99"></a>    
<a name="line-100"></a>  <font color=Blue><i>-- | Compute the minimum of two values.</i></font>
<a name="line-101"></a>  q_min <font color=Red>::</font> qa <font color=Red>-&gt;</font> qa <font color=Red>-&gt;</font> Circ qa
<a name="line-102"></a>  q_min x y <font color=Red>=</font> <font color=Green><u>do</u></font>
<a name="line-103"></a>    q <font color=Red>&lt;-</font> q_less x y
<a name="line-104"></a>    z <font color=Red>&lt;-</font> qinit <font color=Cyan>$</font> qc_false x
<a name="line-105"></a>    <font color=Cyan>(</font>z<font color=Cyan>,</font>x<font color=Cyan>)</font> <font color=Red>&lt;-</font> controlled_not z x <font color=Cyan>`controlled`</font> q <font color=Cyan>.==.</font> True
<a name="line-106"></a>    <font color=Cyan>(</font>z<font color=Cyan>,</font>y<font color=Cyan>)</font> <font color=Red>&lt;-</font> controlled_not z y <font color=Cyan>`controlled`</font> q <font color=Cyan>.==.</font> False
<a name="line-107"></a>    return z
<a name="line-108"></a>
<a name="line-109"></a><font color=Blue><i>-- ===========================================</i></font>
<a name="line-110"></a><font color=Blue><i>-- * Functionally-typed wrappers for 'QOrd' methods</i></font>
<a name="line-111"></a>
<a name="line-112"></a><a name="q_lt"></a><font color=Blue><i>-- | @'q_lt' /qx/ /qy/@: test whether /qx/ &lt; /qy/.  A functionally typed wrapper for 'q_less'.</i></font>
<a name="line-113"></a><font color=Blue>q_lt</font> <font color=Red>::</font> <font color=Cyan>(</font>QOrd qa<font color=Cyan>)</font> <font color=Red>=&gt;</font> qa <font color=Red>-&gt;</font> qa <font color=Red>-&gt;</font> Circ <font color=Cyan>(</font>qa<font color=Cyan>,</font>qa<font color=Cyan>,</font>Qubit<font color=Cyan>)</font>
<a name="line-114"></a><font color=Blue>q_lt</font> qx qy <font color=Red>=</font> <font color=Green><u>do</u></font>
<a name="line-115"></a>  test <font color=Red>&lt;-</font> q_less qx qy
<a name="line-116"></a>  return <font color=Cyan>(</font>qx<font color=Cyan>,</font>qy<font color=Cyan>,</font>test<font color=Cyan>)</font>
<a name="line-117"></a> 
<a name="line-118"></a><a name="q_gt"></a><font color=Blue><i>-- | @'q_gt' /qx/ /qy/@: test whether /qx/ &gt; /qy/. A functionally typed wrapper for 'q_greater'.</i></font>
<a name="line-119"></a><font color=Blue>q_gt</font> <font color=Red>::</font> <font color=Cyan>(</font>QOrd qa<font color=Cyan>)</font> <font color=Red>=&gt;</font> qa <font color=Red>-&gt;</font> qa <font color=Red>-&gt;</font> Circ <font color=Cyan>(</font>qa<font color=Cyan>,</font>qa<font color=Cyan>,</font>Qubit<font color=Cyan>)</font>
<a name="line-120"></a><font color=Blue>q_gt</font> qx qy <font color=Red>=</font> <font color=Green><u>do</u></font>
<a name="line-121"></a>  test <font color=Red>&lt;-</font> q_greater qx qy
<a name="line-122"></a>  return <font color=Cyan>(</font>qx<font color=Cyan>,</font>qy<font color=Cyan>,</font>test<font color=Cyan>)</font>
<a name="line-123"></a>
<a name="line-124"></a><a name="q_le"></a><font color=Blue><i>-- | @'q_le' /qx/ /qy/@: test whether /qx/ &#8804; /qy/. A functionally typed wrapper for 'q_leq'.</i></font>
<a name="line-125"></a><font color=Blue>q_le</font> <font color=Red>::</font> <font color=Cyan>(</font>QOrd qa<font color=Cyan>)</font> <font color=Red>=&gt;</font> qa <font color=Red>-&gt;</font> qa <font color=Red>-&gt;</font> Circ <font color=Cyan>(</font>qa<font color=Cyan>,</font>qa<font color=Cyan>,</font>Qubit<font color=Cyan>)</font>
<a name="line-126"></a><font color=Blue>q_le</font> qx qy <font color=Red>=</font> <font color=Green><u>do</u></font>
<a name="line-127"></a>  test <font color=Red>&lt;-</font> q_leq qx qy
<a name="line-128"></a>  return <font color=Cyan>(</font>qx<font color=Cyan>,</font>qy<font color=Cyan>,</font>test<font color=Cyan>)</font>
<a name="line-129"></a>
<a name="line-130"></a><a name="q_ge"></a><font color=Blue><i>-- | @'q_ge' /qx/ /qy/@: test whether /qx/ &#8805; /qy/. A functionally typed wrapper for 'q_geq'.</i></font>
<a name="line-131"></a><font color=Blue>q_ge</font> <font color=Red>::</font> <font color=Cyan>(</font>QOrd qa<font color=Cyan>)</font> <font color=Red>=&gt;</font> qa <font color=Red>-&gt;</font> qa <font color=Red>-&gt;</font> Circ <font color=Cyan>(</font>qa<font color=Cyan>,</font>qa<font color=Cyan>,</font>Qubit<font color=Cyan>)</font>
<a name="line-132"></a><font color=Blue>q_ge</font> qx qy <font color=Red>=</font> <font color=Green><u>do</u></font>
<a name="line-133"></a>  test <font color=Red>&lt;-</font> q_geq qx qy
<a name="line-134"></a>  return <font color=Cyan>(</font>qx<font color=Cyan>,</font>qy<font color=Cyan>,</font>test<font color=Cyan>)</font>
</pre>
</body>
</html>