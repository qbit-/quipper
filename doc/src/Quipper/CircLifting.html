<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<!-- Generated by HsColour, http://code.haskell.org/~malcolm/hscolour/ -->
<title>Haskell code</title>
</head>
<body>
<pre><a name="line-1"></a><font color=Blue><i>{-# LANGUAGE ScopedTypeVariables #-}</i></font>
<a name="line-2"></a><font color=Blue><i>{-# LANGUAGE TypeSynonymInstances #-}</i></font>
<a name="line-3"></a><font color=Blue><i>{-# LANGUAGE MultiParamTypeClasses #-}</i></font>
<a name="line-4"></a><font color=Blue><i>{-# LANGUAGE FunctionalDependencies #-}</i></font>
<a name="line-5"></a><font color=Blue><i>{-# LANGUAGE FlexibleInstances #-}</i></font>
<a name="line-6"></a><font color=Blue><i>{-# LANGUAGE UndecidableInstances #-}</i></font>
<a name="line-7"></a>
<a name="line-8"></a><font color=Blue><i>-- | This module provides a user-friendly interface to building</i></font>
<a name="line-9"></a><font color=Blue><i>-- quantum circuits out of classical functions on booleans. It is</i></font>
<a name="line-10"></a><font color=Blue><i>-- based on lower-level functionality provided by</i></font>
<a name="line-11"></a><font color=Blue><i>-- "Libraries.Template".</i></font>
<a name="line-12"></a><font color=Blue><i>-- </i></font>
<a name="line-13"></a><font color=Blue><i>-- Technically, the only functions to be used in this module are</i></font>
<a name="line-14"></a><font color=Blue><i>-- @'decToCircMonad'@, a specialized version of @'decToMonad'@, and</i></font>
<a name="line-15"></a><font color=Blue><i>-- @'unpack'@. The only useful datatype here is @'BoolParam'@.</i></font>
<a name="line-16"></a><font color=Blue><i>-- </i></font>
<a name="line-17"></a><font color=Blue><i>-- One should not have to directly use the other things: they are only</i></font>
<a name="line-18"></a><font color=Blue><i>-- for the internal use of Template Haskell to build quantum circuits</i></font>
<a name="line-19"></a><font color=Blue><i>-- out of classical computation on booleans.</i></font>
<a name="line-20"></a><font color=Blue><i>-- </i></font>
<a name="line-21"></a><font color=Blue><i>-- Note: in the following, we write circuits in ASCII form. The</i></font>
<a name="line-22"></a><font color=Blue><i>-- following conventions are used. They are extended in obvious ways</i></font>
<a name="line-23"></a><font color=Blue><i>-- when applicable (e.g. when writing a ternary gate).</i></font>
<a name="line-24"></a><font color=Blue><i>-- </i></font>
<a name="line-25"></a><font color=Blue><i>-- &gt; ---- : wire</i></font>
<a name="line-26"></a><font color=Blue><i>-- &gt; </i></font>
<a name="line-27"></a><font color=Blue><i>-- &gt; 0 |-- : initialize an ancilla |0&gt;</i></font>
<a name="line-28"></a><font color=Blue><i>-- &gt; </i></font>
<a name="line-29"></a><font color=Blue><i>-- &gt; --| 0 : terminate an ancilla, asserting it was |0&gt;</i></font>
<a name="line-30"></a><font color=Blue><i>-- &gt; </i></font>
<a name="line-31"></a><font color=Blue><i>-- &gt;   +--+</i></font>
<a name="line-32"></a><font color=Blue><i>-- &gt;  -|  |- : a unary gate</i></font>
<a name="line-33"></a><font color=Blue><i>-- &gt;   +--+</i></font>
<a name="line-34"></a><font color=Blue><i>-- &gt; </i></font>
<a name="line-35"></a><font color=Blue><i>-- &gt;   +--+</i></font>
<a name="line-36"></a><font color=Blue><i>-- &gt;  -|  |- </i></font>
<a name="line-37"></a><font color=Blue><i>-- &gt;   |  |  : a binary gate</i></font>
<a name="line-38"></a><font color=Blue><i>-- &gt;  -|  |- </i></font>
<a name="line-39"></a><font color=Blue><i>-- &gt;   +--+</i></font>
<a name="line-40"></a><font color=Blue><i>-- &gt;</i></font>
<a name="line-41"></a><font color=Blue><i>-- &gt;  -- --</i></font>
<a name="line-42"></a><font color=Blue><i>-- &gt;    X   : swap gate</i></font>
<a name="line-43"></a><font color=Blue><i>-- &gt;  -- --</i></font>
<a name="line-44"></a><font color=Blue><i>-- &gt; </i></font>
<a name="line-45"></a><font color=Blue><i>-- &gt;  --x-- </i></font>
<a name="line-46"></a><font color=Blue><i>-- &gt;    |   : controlled-not, applying NOT on the bottom wire if the top one is |1&gt;</i></font>
<a name="line-47"></a><font color=Blue><i>-- &gt;  --N-- </i></font>
<a name="line-48"></a><font color=Blue><i>-- &gt;</i></font>
<a name="line-49"></a><font color=Blue><i>-- &gt;  --o-- </i></font>
<a name="line-50"></a><font color=Blue><i>-- &gt;    |   : controlled-not, applying NOT on the bottom wire if the top one is |0&gt;</i></font>
<a name="line-51"></a><font color=Blue><i>-- &gt;  --N-- </i></font>
<a name="line-52"></a>
<a name="line-53"></a><font color=Blue><i>-- NOTE: They are only available because Template Haskell requires</i></font>
<a name="line-54"></a><font color=Blue><i>-- them to be in a separate module and exported.</i></font>
<a name="line-55"></a>
<a name="line-56"></a><font color=Green><u>module</u></font> Quipper<font color=Cyan>.</font>CircLifting <font color=Cyan>(</font>
<a name="line-57"></a>  <font color=Blue><i>-- * Overview</i></font>
<a name="line-58"></a>  <font color=Blue><i>-- $ROLE </i></font>
<a name="line-59"></a>
<a name="line-60"></a>  <font color=Blue><i>-- * A type of boolean parameters</i></font>
<a name="line-61"></a>  <font color=Blue><i>-- $BOOLPARAM </i></font>
<a name="line-62"></a>  BoolParam<font color=Cyan>(</font>PTrue<font color=Cyan>,</font>PFalse<font color=Cyan>)</font><font color=Cyan>,</font>
<a name="line-63"></a>  newBool<font color=Cyan>,</font>
<a name="line-64"></a>  template_PFalse<font color=Cyan>,</font>
<a name="line-65"></a>  template_PTrue<font color=Cyan>,</font>
<a name="line-66"></a>    
<a name="line-67"></a>  <font color=Blue><i>-- * Lifting classical functions to circuits</i></font>
<a name="line-68"></a>  <font color=Blue><i>-- $TH</i></font>
<a name="line-69"></a>  decToCircMonad<font color=Cyan>,</font>
<a name="line-70"></a>  
<a name="line-71"></a><font color=Blue><i>-- $BUILDTEMPLATE_ANCHOR #build_circuit#</i></font>
<a name="line-72"></a>  
<a name="line-73"></a>  <font color=Blue><i>-- * Syntactic sugar</i></font>
<a name="line-74"></a>  <font color=Blue><i>-- $BUILDTEMPLATE</i></font>
<a name="line-75"></a>
<a name="line-76"></a>
<a name="line-77"></a>  <font color=Blue><i>-- * Circuits for specific operations</i></font>
<a name="line-78"></a>  <font color=Blue><i>-- ** Boolean parameters</i></font>
<a name="line-79"></a>  
<a name="line-80"></a>  template_newBool<font color=Cyan>,</font>
<a name="line-81"></a>
<a name="line-82"></a>  <font color=Blue><i>-- ** Boolean constants</i></font>
<a name="line-83"></a>  template_False<font color=Cyan>,</font>
<a name="line-84"></a>  template_True<font color=Cyan>,</font>
<a name="line-85"></a>  <font color=Blue><i>-- ** Unary boolean operations</i></font>
<a name="line-86"></a>  template_not<font color=Cyan>,</font>
<a name="line-87"></a>  <font color=Blue><i>-- ** Binary boolean operations</i></font>
<a name="line-88"></a>  template_symb_ampersand_symb_ampersand_<font color=Cyan>,</font>
<a name="line-89"></a>  template_symb_vbar_symb_vbar_<font color=Cyan>,</font>
<a name="line-90"></a>  template_bool_xor<font color=Cyan>,</font>
<a name="line-91"></a>  <font color=Blue><i>-- ** The if-then-else operation</i></font>
<a name="line-92"></a>  <font color=Blue><i>-- $IF</i></font>
<a name="line-93"></a>  template_if<font color=Cyan>,</font>
<a name="line-94"></a>  <font color=Blue><i>-- ** Equality test</i></font>
<a name="line-95"></a>  template_symb_equal_symb_equal_<font color=Cyan>,</font>
<a name="line-96"></a>
<a name="line-97"></a>  <font color=Blue><i>-- * Generic unpacking</i></font>
<a name="line-98"></a>  CircLiftingUnpack<font color=Cyan>(</font><font color=Red>..</font><font color=Cyan>)</font>
<a name="line-99"></a>  
<a name="line-100"></a><font color=Cyan>)</font> <font color=Green><u>where</u></font>
<a name="line-101"></a>
<a name="line-102"></a><font color=Green><u>import</u></font> Prelude
<a name="line-103"></a><font color=Green><u>import</u></font> Language<font color=Cyan>.</font>Haskell<font color=Cyan>.</font>TH <font color=Green><u>as</u></font> TH
<a name="line-104"></a><font color=Green><u>import</u></font> Data<font color=Cyan>.</font>Map <font color=Green><u>as</u></font> Map
<a name="line-105"></a><font color=Green><u>import</u></font> <font color=Green><u>qualified</u></font> Data<font color=Cyan>.</font>List
<a name="line-106"></a>
<a name="line-107"></a><font color=Green><u>import</u></font> Quipper<font color=Cyan>.</font>Monad
<a name="line-108"></a><font color=Green><u>import</u></font> <font color=Green><u>qualified</u></font> Quipper<font color=Cyan>.</font>Monad
<a name="line-109"></a><font color=Green><u>import</u></font> Quipper<font color=Cyan>.</font>Circuit
<a name="line-110"></a><font color=Green><u>import</u></font> Quipper<font color=Cyan>.</font>Generic
<a name="line-111"></a><font color=Green><u>import</u></font> Quipper<font color=Cyan>.</font>QData
<a name="line-112"></a><font color=Green><u>import</u></font> Libraries<font color=Cyan>.</font>Auxiliary <font color=Cyan>(</font>list_of_blist<font color=Cyan>,</font>blist_empty<font color=Cyan>)</font>
<a name="line-113"></a><font color=Green><u>import</u></font> Quipper<font color=Cyan>.</font>Control
<a name="line-114"></a><font color=Green><u>import</u></font> Quipper<font color=Cyan>.</font>QClasses
<a name="line-115"></a>
<a name="line-116"></a><font color=Green><u>import</u></font> Libraries<font color=Cyan>.</font>Template
<a name="line-117"></a>
<a name="line-118"></a>
<a name="line-119"></a>
<a name="line-120"></a><font color=Blue><i>----------------------------------------------------------------------</i></font>
<a name="line-121"></a><font color=Blue><i>-- * Overview</i></font>
<a name="line-122"></a>
<a name="line-123"></a><font color=Blue><i>-- $ROLE Using the tool @'decToMonad'@ designed in "Libraries.Template", we</i></font>
<a name="line-124"></a><font color=Blue><i>-- can easily generate quantum circuits. Indeed, suppose that we are given the classical oracle </i></font>
<a name="line-125"></a><font color=Blue><i>-- </i></font>
<a name="line-126"></a><font color=Blue><i>-- &gt; toyOracle :: Bool -&gt; Bool</i></font>
<a name="line-127"></a><font color=Blue><i>-- &gt; toyOracle a = f (g a) (h a)</i></font>
<a name="line-128"></a><font color=Blue><i>-- </i></font>
<a name="line-129"></a><font color=Blue><i>-- for some @g,h :: Bool -&gt; Bool@ and @f :: Bool -&gt; Bool -&gt; Bool@. If</i></font>
<a name="line-130"></a><font color=Blue><i>-- /g/ and /h/ are given by quantum circuits of the form</i></font>
<a name="line-131"></a><font color=Blue><i>--</i></font>
<a name="line-132"></a><font color=Blue><i>-- &gt;          +-----+</i></font>
<a name="line-133"></a><font color=Blue><i>-- &gt; input ---|     |-- input wire, assumed to be not modified by the box</i></font>
<a name="line-134"></a><font color=Blue><i>-- &gt;          |     |</i></font>
<a name="line-135"></a><font color=Blue><i>-- &gt;      0 |-|     |--- output (was ancilla wire)</i></font>
<a name="line-136"></a><font color=Blue><i>-- &gt;          +-----+</i></font>
<a name="line-137"></a><font color=Blue><i>--</i></font>
<a name="line-138"></a><font color=Blue><i>-- and if /f/ is given by</i></font>
<a name="line-139"></a><font color=Blue><i>--</i></font>
<a name="line-140"></a><font color=Blue><i>-- &gt;          +-----+</i></font>
<a name="line-141"></a><font color=Blue><i>-- &gt; input ---|     |-- was input 1, assumed to be not modified</i></font>
<a name="line-142"></a><font color=Blue><i>-- &gt;          |     | </i></font>
<a name="line-143"></a><font color=Blue><i>-- &gt; input ---|     |-- was input 2, assumed to be not modified</i></font>
<a name="line-144"></a><font color=Blue><i>-- &gt;          |     |</i></font>
<a name="line-145"></a><font color=Blue><i>-- &gt;     0 |--|     |-- output (was ancilla wire),</i></font>
<a name="line-146"></a><font color=Blue><i>-- &gt;          +-----+</i></font>
<a name="line-147"></a><font color=Blue><i>--</i></font>
<a name="line-148"></a><font color=Blue><i>-- we can compositionally generate a circuit @C@ for /toyOracle/ as follows.</i></font>
<a name="line-149"></a><font color=Blue><i>-- </i></font>
<a name="line-150"></a><font color=Blue><i>-- &gt;          +---+                    +---+</i></font>
<a name="line-151"></a><font color=Blue><i>-- &gt; input ---|   |-- -----------------|   |-- (output of g)</i></font>
<a name="line-152"></a><font color=Blue><i>-- &gt;          | g |  X  +---+          |   |</i></font>
<a name="line-153"></a><font color=Blue><i>-- &gt;     0 |--|   |-- --|   |--- ------| f |-- (output of h)</i></font>
<a name="line-154"></a><font color=Blue><i>-- &gt;          +---+     | h |   X      |   |                   (I)</i></font>
<a name="line-155"></a><font color=Blue><i>-- &gt;     0 |------------|   |--- - ----|   |-- (output of f)</i></font>
<a name="line-156"></a><font color=Blue><i>-- &gt;                    +---+     X    +---+</i></font>
<a name="line-157"></a><font color=Blue><i>-- &gt;                          0 |- ----------- (input of g)</i></font>
<a name="line-158"></a><font color=Blue><i>-- &gt;</i></font>
<a name="line-159"></a><font color=Blue><i>--</i></font>
<a name="line-160"></a><font color=Blue><i>-- Note that the resulting circuit is a classical, reversible circuit</i></font>
<a name="line-161"></a><font color=Blue><i>-- (more precisely, the circuit defines a one-to-one function). In</i></font>
<a name="line-162"></a><font color=Blue><i>-- order to obtain a reversible quantum circuit, one should then apply</i></font>
<a name="line-163"></a><font color=Blue><i>-- the function @'Quipper.Classical.classical_to_reversible'@ to get the following (we</i></font>
<a name="line-164"></a><font color=Blue><i>-- keep the same convention of wires as in the definition of @C@):</i></font>
<a name="line-165"></a><font color=Blue><i>--</i></font>
<a name="line-166"></a><font color=Blue><i>-- &gt;        +---+     +---+</i></font>
<a name="line-167"></a><font color=Blue><i>-- &gt; input--|   |-----|   |-- still the input</i></font>
<a name="line-168"></a><font color=Blue><i>-- &gt;        |   |     |   |</i></font>
<a name="line-169"></a><font color=Blue><i>-- &gt;   0 |--|   |-----|   |--| 0</i></font>
<a name="line-170"></a><font color=Blue><i>-- &gt;        | C |     | D |                                    (II)</i></font>
<a name="line-171"></a><font color=Blue><i>-- &gt;   0 |--|   |--x--|   |--| 0</i></font>
<a name="line-172"></a><font color=Blue><i>-- &gt;        |   |  |  |   |</i></font>
<a name="line-173"></a><font color=Blue><i>-- &gt;   0 |--|   |--|--|   |--| 0</i></font>
<a name="line-174"></a><font color=Blue><i>-- &gt;        +---+  |  +---+</i></font>
<a name="line-175"></a><font color=Blue><i>-- &gt;               |</i></font>
<a name="line-176"></a><font color=Blue><i>-- &gt; output wire---N--------------.</i></font>
<a name="line-177"></a><font color=Blue><i>--</i></font>
<a name="line-178"></a><font color=Blue><i>-- Here @D@ is the inverse of @C@. We now have a circuit of the</i></font>
<a name="line-179"></a><font color=Blue><i>-- canonical form, computing and then uncomputing its ancillas:</i></font>
<a name="line-180"></a><font color=Blue><i>--</i></font>
<a name="line-181"></a><font color=Blue><i>-- &gt;     +-----------+</i></font>
<a name="line-182"></a><font color=Blue><i>-- &gt; a --|           |- a</i></font>
<a name="line-183"></a><font color=Blue><i>-- &gt;     | toyOracle |</i></font>
<a name="line-184"></a><font color=Blue><i>-- &gt; z --|           |- z + (f (g a) (h a))</i></font>
<a name="line-185"></a><font color=Blue><i>-- &gt;     +-----------+</i></font>
<a name="line-186"></a><font color=Blue><i>--</i></font>
<a name="line-187"></a><font color=Blue><i>----------------------------------------------------------------------</i></font>
<a name="line-188"></a><font color=Blue><i>-- * A type of boolean parameters</i></font>
<a name="line-189"></a>
<a name="line-190"></a><font color=Blue><i>-- $BOOLPARAM During the construction of a quantum circuit from</i></font>
<a name="line-191"></a><font color=Blue><i>-- classical code, the type 'Bool' is mapped to the type</i></font>
<a name="line-192"></a><font color=Blue><i>-- 'Qubit'. However, it is also sometimes useful to specify boolean</i></font>
<a name="line-193"></a><font color=Blue><i>-- parameters to be used during circuit generation (for example, in</i></font>
<a name="line-194"></a><font color=Blue><i>-- the BWT algorithm, the color is a parameter). For this purpose, we</i></font>
<a name="line-195"></a><font color=Blue><i>-- provide a new type 'BoolParam', which is identical to 'Bool' in</i></font>
<a name="line-196"></a><font color=Blue><i>-- most respects, except that it is not mapped to 'Qubit' during</i></font>
<a name="line-197"></a><font color=Blue><i>-- circuit generation.</i></font>
<a name="line-198"></a>
<a name="line-199"></a><a name="BoolParam"></a><font color=Blue><i>-- | A custom-design boolean type, not modified by circuit generation.</i></font>
<a name="line-200"></a><a name="BoolParam"></a><font color=Green><u>data</u></font> BoolParam <font color=Red>=</font> PTrue <font color=Red>|</font> PFalse
<a name="line-201"></a>  <font color=Green><u>deriving</u></font> <font color=Cyan>(</font>Eq<font color=Cyan>,</font> Show<font color=Cyan>)</font>
<a name="line-202"></a>
<a name="line-203"></a><a name="newBool"></a><font color=Blue><i>-- | Type-cast from BoolParam to Bool</i></font>
<a name="line-204"></a><font color=Blue>newBool</font> <font color=Red>::</font> BoolParam <font color=Red>-&gt;</font> Bool
<a name="line-205"></a><font color=Blue>newBool</font> PTrue <font color=Red>=</font> True
<a name="line-206"></a><font color=Blue>newBool</font> PFalse <font color=Red>=</font> False
<a name="line-207"></a>
<a name="line-208"></a>
<a name="line-209"></a><a name="template_PFalse"></a><font color=Blue><i>-- | Lifted version of PFalse.</i></font>
<a name="line-210"></a><font color=Blue>template_PFalse</font> <font color=Red>::</font> Circ BoolParam
<a name="line-211"></a><font color=Blue>template_PFalse</font> <font color=Red>=</font> return PFalse
<a name="line-212"></a>
<a name="line-213"></a><a name="template_PTrue"></a><font color=Blue><i>-- | Lifted version of PTrue.</i></font>
<a name="line-214"></a><font color=Blue>template_PTrue</font> <font color=Red>::</font> Circ BoolParam
<a name="line-215"></a><font color=Blue>template_PTrue</font> <font color=Red>=</font> return PTrue
<a name="line-216"></a>
<a name="line-217"></a>
<a name="line-218"></a><font color=Blue><i>----------------------------------------------------------------------</i></font>
<a name="line-219"></a><font color=Blue><i>-- * Lifting classical functions to circuits</i></font>
<a name="line-220"></a>
<a name="line-221"></a><font color=Blue><i>-- $TH The main tool for transforming a classical computation into a</i></font>
<a name="line-222"></a><font color=Blue><i>-- quantum circuit is the function @'decToCircMonad'@. It inputs the</i></font>
<a name="line-223"></a><font color=Blue><i>-- syntax tree of a classical function, and outputs the syntax tree of</i></font>
<a name="line-224"></a><font color=Blue><i>-- a corresponding quantum circuit. The type 'Bool' is mapped to</i></font>
<a name="line-225"></a><font color=Blue><i>-- 'Qubit'; the type 'BoolParam' is unchanged; and each function /f/ :</i></font>
<a name="line-226"></a><font color=Blue><i>-- /a/ &#8594; /b/ is mapped to a function /f'/ : /a'/ &#8594; 'Circ' /b'/,</i></font>
<a name="line-227"></a><font color=Blue><i>-- where /a'/ and /b'/ are the translations of the types /a/ and /b/,</i></font>
<a name="line-228"></a><font color=Blue><i>-- respectively.</i></font>
<a name="line-229"></a><font color=Blue><i>-- </i></font>
<a name="line-230"></a><font color=Blue><i>-- Most of the work is done by the lower-level function </i></font>
<a name="line-231"></a><font color=Blue><i>-- @'decToMonad'@ from the module "Libraries.Template". </i></font>
<a name="line-232"></a><font color=Blue><i>-- This lower-level function knows how to deal with many usual</i></font>
<a name="line-233"></a><font color=Blue><i>-- constructs of the Haskell language, such as function applications,</i></font>
<a name="line-234"></a><font color=Blue><i>-- lambda-abstractions, let-assignments, case-distinctions, and so</i></font>
<a name="line-235"></a><font color=Blue><i>-- on. However, @'decToMonad'@ does not by default know how to deal</i></font>
<a name="line-236"></a><font color=Blue><i>-- with the base cases, i.e., how to extract quantum circuits from</i></font>
<a name="line-237"></a><font color=Blue><i>-- specific term constants such as @'&amp;&amp;'@, @'||'@, etc.</i></font>
<a name="line-238"></a><font color=Blue><i>-- </i></font>
<a name="line-239"></a><font color=Blue><i>-- The purpose of the remainder of this module is to do just that. For</i></font>
<a name="line-240"></a><font color=Blue><i>-- every constant or function @XXX@ that one may want to use in a</i></font>
<a name="line-241"></a><font color=Blue><i>-- classical program, we provide an implementation @template_XXX@ as a</i></font>
<a name="line-242"></a><font color=Blue><i>-- quantum circuit.  We refer to @template_XXX@ as the \"lifted\"</i></font>
<a name="line-243"></a><font color=Blue><i>-- version of @XXX@.  The function @'decToCircMonad'@ is a version of</i></font>
<a name="line-244"></a><font color=Blue><i>-- @'decToMonad'@ that knows about these liftings.</i></font>
<a name="line-245"></a>
<a name="line-246"></a>
<a name="line-247"></a>
<a name="line-248"></a><a name="decToCircMonad"></a><font color=Blue><i>-- | Input the syntax tree of a classical function, and output the</i></font>
<a name="line-249"></a><font color=Blue><i>-- syntax tree of a corresponding quantum function. The type 'Bool' is</i></font>
<a name="line-250"></a><font color=Blue><i>-- mapped to 'Qubit'; the type 'BoolParam' is unchanged; and and each</i></font>
<a name="line-251"></a><font color=Blue><i>-- function /f/ : /a/ &#8594; /b/ is mapped to a function /f'/ : /a'/ &#8594;</i></font>
<a name="line-252"></a><font color=Blue><i>-- 'Circ' /b'/, where /a'/ and /b'/ are the translations of the types</i></font>
<a name="line-253"></a><font color=Blue><i>-- /a/ and /b/, respectively. The function 'decToCircMonad' knows</i></font>
<a name="line-254"></a><font color=Blue><i>-- about many built-in operations such as @'&amp;&amp;'@ and @'||'@, whose</i></font>
<a name="line-255"></a><font color=Blue><i>-- circuit translations are defined below.</i></font>
<a name="line-256"></a><font color=Blue>decToCircMonad</font> <font color=Red>::</font> Q <font color=Red>[</font>Dec<font color=Red>]</font> <font color=Red>-&gt;</font> Q <font color=Red>[</font>Dec<font color=Red>]</font>
<a name="line-257"></a><font color=Blue>decToCircMonad</font> x <font color=Red>=</font> decToMonad <font color=Magenta>"Circ"</font> x
<a name="line-258"></a>
<a name="line-259"></a><font color=Blue><i>-- $BUILDTEMPLATE_ANCHOR #build_circuit#</i></font>
<a name="line-260"></a>
<a name="line-261"></a><font color=Blue><i>---------------------------------------------------------------------</i></font>
<a name="line-262"></a><font color=Blue><i>-- * Syntactic sugar</i></font>
<a name="line-263"></a>
<a name="line-264"></a><font color=Blue><i>-- $BUILDTEMPLATE Quipper comes equipped with syntactic sugar to ease</i></font>
<a name="line-265"></a><font color=Blue><i>-- the use of the @'decToCircMonad'@ function.</i></font>
<a name="line-266"></a><font color=Blue><i>-- </i></font>
<a name="line-267"></a><font color=Blue><i>-- Although the code</i></font>
<a name="line-268"></a><font color=Blue><i>-- </i></font>
<a name="line-269"></a><font color=Blue><i>-- &gt; $( decToCircMonad [d| f x = ... |] )</i></font>
<a name="line-270"></a><font color=Blue><i>-- </i></font>
<a name="line-271"></a><font color=Blue><i>-- is valid, it is possible to use the special keyword</i></font>
<a name="line-272"></a><font color=Blue><i>-- @build_circuit@, as follows:</i></font>
<a name="line-273"></a><font color=Blue><i>-- </i></font>
<a name="line-274"></a><font color=Blue><i>-- &gt; build_circuit</i></font>
<a name="line-275"></a><font color=Blue><i>-- &gt; f x = ...</i></font>
<a name="line-276"></a><font color=Blue><i>-- </i></font>
<a name="line-277"></a><font color=Blue><i>-- This code is equivalent to</i></font>
<a name="line-278"></a><font color=Blue><i>-- </i></font>
<a name="line-279"></a><font color=Blue><i>-- &gt; f x = ...</i></font>
<a name="line-280"></a><font color=Blue><i>-- &gt; $( decToCircMonad [d| f x = ... |] )</i></font>
<a name="line-281"></a><font color=Blue><i>-- </i></font>
<a name="line-282"></a><font color=Blue><i>-- In other words, it generates both a function @f@ of type @a -&gt; ...@</i></font>
<a name="line-283"></a><font color=Blue><i>-- and an object @template_f@ of type @Circ (a -&gt; Circ ...)@.</i></font>
<a name="line-284"></a><font color=Blue><i>-- </i></font>
<a name="line-285"></a><font color=Blue><i>-- The following spellings are recognized:</i></font>
<a name="line-286"></a><font color=Blue><i>--</i></font>
<a name="line-287"></a><font color=Blue><i>-- &gt; build_circuit f x y z = ...</i></font>
<a name="line-288"></a><font color=Blue><i>--</i></font>
<a name="line-289"></a><font color=Blue><i>-- &gt; build_circuit</i></font>
<a name="line-290"></a><font color=Blue><i>-- &gt; f x y z = ...</i></font>
<a name="line-291"></a><font color=Blue><i>--</i></font>
<a name="line-292"></a><font color=Blue><i>-- &gt; build_circuit</i></font>
<a name="line-293"></a><font color=Blue><i>-- &gt; f :: a -&gt; ...</i></font>
<a name="line-294"></a><font color=Blue><i>-- &gt; f x y z = ...</i></font>
<a name="line-295"></a>
<a name="line-296"></a><font color=Blue><i>-- ----------------------------------------------------------------------</i></font>
<a name="line-297"></a><font color=Blue><i>-- * Circuits for specific operations</i></font>
<a name="line-298"></a>
<a name="line-299"></a><font color=Blue><i>-- ** Boolean parameters</i></font>
<a name="line-300"></a>
<a name="line-301"></a><a name="template_newBool"></a><font color=Blue><i>-- | Lifted version of 'newBool':</i></font>
<a name="line-302"></a><font color=Blue><i>-- </i></font>
<a name="line-303"></a><font color=Blue><i>-- &gt; newBool :: BoolParam -&gt; Bool.</i></font>
<a name="line-304"></a><font color=Blue><i>--</i></font>
<a name="line-305"></a><font color=Blue><i>-- Depending on the boolean parameter, the circuit is either </i></font>
<a name="line-306"></a><font color=Blue><i>-- </i></font>
<a name="line-307"></a><font color=Blue><i>-- &gt; 0 |--</i></font>
<a name="line-308"></a><font color=Blue><i>-- </i></font>
<a name="line-309"></a><font color=Blue><i>-- or</i></font>
<a name="line-310"></a><font color=Blue><i>-- </i></font>
<a name="line-311"></a><font color=Blue><i>-- &gt; 1 |--</i></font>
<a name="line-312"></a><font color=Blue>template_newBool</font> <font color=Red>::</font>  Circ <font color=Cyan>(</font>BoolParam <font color=Red>-&gt;</font> Circ Qubit<font color=Cyan>)</font>
<a name="line-313"></a><font color=Blue>template_newBool</font> <font color=Red>=</font>  return <font color=Cyan>$</font> <font color=Red>\</font>b <font color=Red>-&gt;</font> <font color=Green><u>case</u></font> b <font color=Green><u>of</u></font> 
<a name="line-314"></a>                             PTrue  <font color=Red>-&gt;</font> qinit_qubit True
<a name="line-315"></a>                             PFalse <font color=Red>-&gt;</font> qinit_qubit False
<a name="line-316"></a>
<a name="line-317"></a><font color=Blue><i>----------------------------------------------------------------------</i></font>
<a name="line-318"></a><font color=Blue><i>-- ** Boolean constants</i></font>
<a name="line-319"></a>
<a name="line-320"></a><a name="template_False"></a><font color=Blue><i>-- | Lifted version of 'False':</i></font>
<a name="line-321"></a><font color=Blue><i>-- </i></font>
<a name="line-322"></a><font color=Blue><i>-- &gt; False :: Bool.</i></font>
<a name="line-323"></a><font color=Blue><i>-- </i></font>
<a name="line-324"></a><font color=Blue><i>-- The circuit is</i></font>
<a name="line-325"></a><font color=Blue><i>--</i></font>
<a name="line-326"></a><font color=Blue><i>-- &gt; 0 |--   output: quantum bit in state |0&gt;</i></font>
<a name="line-327"></a><font color=Blue>template_False</font> <font color=Red>::</font> Circ Qubit
<a name="line-328"></a><font color=Blue>template_False</font> <font color=Red>=</font> qinit_qubit False
<a name="line-329"></a>
<a name="line-330"></a><a name="template_True"></a><font color=Blue><i>-- | Lifted version of 'True':</i></font>
<a name="line-331"></a><font color=Blue><i>-- </i></font>
<a name="line-332"></a><font color=Blue><i>-- &gt; True :: Bool.</i></font>
<a name="line-333"></a><font color=Blue><i>-- </i></font>
<a name="line-334"></a><font color=Blue><i>-- The circuit is</i></font>
<a name="line-335"></a><font color=Blue><i>--</i></font>
<a name="line-336"></a><font color=Blue><i>-- &gt; 1 |--   output: quantum bit in state |1&gt;</i></font>
<a name="line-337"></a><font color=Blue>template_True</font> <font color=Red>::</font> Circ Qubit
<a name="line-338"></a><font color=Blue>template_True</font> <font color=Red>=</font> qinit_qubit True
<a name="line-339"></a>
<a name="line-340"></a>
<a name="line-341"></a>
<a name="line-342"></a><font color=Blue><i>----------------------------------------------------------------------</i></font>
<a name="line-343"></a><font color=Blue><i>-- ** Unary boolean operations</i></font>
<a name="line-344"></a>
<a name="line-345"></a><a name="template_not"></a><font color=Blue><i>-- | Lifted version of 'not':</i></font>
<a name="line-346"></a><font color=Blue><i>-- </i></font>
<a name="line-347"></a><font color=Blue><i>-- &gt; not :: Bool -&gt; Bool.</i></font>
<a name="line-348"></a><font color=Blue><i>-- </i></font>
<a name="line-349"></a><font color=Blue><i>-- The circuit is </i></font>
<a name="line-350"></a><font color=Blue><i>-- </i></font>
<a name="line-351"></a><font color=Blue><i>-- &gt; a -----x--</i></font>
<a name="line-352"></a><font color=Blue><i>-- &gt;        |</i></font>
<a name="line-353"></a><font color=Blue><i>-- &gt;   1 |--N------- output: not a.</i></font>
<a name="line-354"></a><font color=Blue>template_not</font> <font color=Red>::</font>  Circ <font color=Cyan>(</font>Qubit <font color=Red>-&gt;</font> Circ Qubit<font color=Cyan>)</font>
<a name="line-355"></a><font color=Blue>template_not</font>  <font color=Red>=</font> return <font color=Cyan>$</font> <font color=Red>\</font>b <font color=Red>-&gt;</font> <font color=Green><u>do</u></font>
<a name="line-356"></a>          r <font color=Red>&lt;-</font> qinit_qubit True<font color=Cyan>;</font>
<a name="line-357"></a>          qnot_at r <font color=Cyan>`controlled`</font> b
<a name="line-358"></a>          return r
<a name="line-359"></a>
<a name="line-360"></a>
<a name="line-361"></a><font color=Blue><i>----------------------------------------------------------------------</i></font>
<a name="line-362"></a><font color=Blue><i>-- ** Binary boolean operations</i></font>
<a name="line-363"></a>
<a name="line-364"></a><a name="template_symb_ampersand_symb_ampersand_"></a><font color=Blue><i>-- | Lifted version of '&amp;&amp;':</i></font>
<a name="line-365"></a><font color=Blue><i>-- </i></font>
<a name="line-366"></a><font color=Blue><i>-- &gt; (&amp;&amp;) :: Bool -&gt; Bool -&gt; Bool.</i></font>
<a name="line-367"></a><font color=Blue><i>-- </i></font>
<a name="line-368"></a><font color=Blue><i>-- The circuit is</i></font>
<a name="line-369"></a><font color=Blue><i>-- </i></font>
<a name="line-370"></a><font color=Blue><i>-- &gt; a -----x---</i></font>
<a name="line-371"></a><font color=Blue><i>-- &gt;        |</i></font>
<a name="line-372"></a><font color=Blue><i>-- &gt; b -----x---</i></font>
<a name="line-373"></a><font color=Blue><i>-- &gt;        |</i></font>
<a name="line-374"></a><font color=Blue><i>-- &gt;   0 |--N------- output: a and b.</i></font>
<a name="line-375"></a><font color=Blue>template_symb_ampersand_symb_ampersand_</font> <font color=Red>::</font>  Circ <font color=Cyan>(</font>Qubit <font color=Red>-&gt;</font> Circ <font color=Cyan>(</font>Qubit <font color=Red>-&gt;</font> Circ Qubit<font color=Cyan>)</font><font color=Cyan>)</font>
<a name="line-376"></a><font color=Blue>template_symb_ampersand_symb_ampersand_</font> <font color=Red>=</font>
<a name="line-377"></a>  return <font color=Cyan>$</font> <font color=Red>\</font>b1 <font color=Red>-&gt;</font> return <font color=Cyan>$</font> <font color=Red>\</font>b2 <font color=Red>-&gt;</font> <font color=Green><u>do</u></font> 
<a name="line-378"></a>         r <font color=Red>&lt;-</font> qinit_qubit False<font color=Cyan>;</font>
<a name="line-379"></a>         qnot_at r <font color=Cyan>`controlled`</font> <font color=Red>[</font>b1<font color=Cyan>,</font>b2<font color=Red>]</font><font color=Cyan>;</font>
<a name="line-380"></a>         return r
<a name="line-381"></a>
<a name="line-382"></a><a name="template_symb_vbar_symb_vbar_"></a><font color=Blue><i>-- | Lifted version of '||':</i></font>
<a name="line-383"></a><font color=Blue><i>-- </i></font>
<a name="line-384"></a><font color=Blue><i>-- &gt; (||) :: Bool -&gt; Bool -&gt; Bool.</i></font>
<a name="line-385"></a><font color=Blue><i>-- </i></font>
<a name="line-386"></a><font color=Blue><i>-- The circuit is</i></font>
<a name="line-387"></a><font color=Blue><i>-- </i></font>
<a name="line-388"></a><font color=Blue><i>-- &gt; a -----o---</i></font>
<a name="line-389"></a><font color=Blue><i>-- &gt;        |</i></font>
<a name="line-390"></a><font color=Blue><i>-- &gt; b -----o---</i></font>
<a name="line-391"></a><font color=Blue><i>-- &gt;        |</i></font>
<a name="line-392"></a><font color=Blue><i>-- &gt;   1 |--N------- output: a or b.</i></font>
<a name="line-393"></a><font color=Blue>template_symb_vbar_symb_vbar_</font> <font color=Red>::</font>  Circ <font color=Cyan>(</font>Qubit <font color=Red>-&gt;</font> Circ <font color=Cyan>(</font>Qubit <font color=Red>-&gt;</font> Circ Qubit<font color=Cyan>)</font><font color=Cyan>)</font>
<a name="line-394"></a><font color=Blue>template_symb_vbar_symb_vbar_</font> <font color=Red>=</font> return <font color=Cyan>$</font> <font color=Red>\</font>b1 <font color=Red>-&gt;</font> return <font color=Cyan>$</font> <font color=Red>\</font>b2 <font color=Red>-&gt;</font> <font color=Green><u>do</u></font> 
<a name="line-395"></a>         r <font color=Red>&lt;-</font> qinit_qubit True<font color=Cyan>;</font> 
<a name="line-396"></a>         qnot_at r <font color=Cyan>`controlled`</font> b1 <font color=Cyan>.==.</font> <font color=Magenta>0</font> <font color=Cyan>.&amp;&amp;.</font> b2 <font color=Cyan>.==.</font> <font color=Magenta>0</font><font color=Cyan>;</font>
<a name="line-397"></a>         return r
<a name="line-398"></a>
<a name="line-399"></a>
<a name="line-400"></a><a name="template_bool_xor"></a><font color=Blue><i>-- | Lifted version of 'bool_xor':</i></font>
<a name="line-401"></a><font color=Blue><i>-- </i></font>
<a name="line-402"></a><font color=Blue><i>-- &gt; bool_xor :: Bool -&gt; Bool -&gt; Bool.</i></font>
<a name="line-403"></a><font color=Blue><i>-- </i></font>
<a name="line-404"></a><font color=Blue><i>-- The circuit is</i></font>
<a name="line-405"></a><font color=Blue><i>-- </i></font>
<a name="line-406"></a><font color=Blue><i>-- &gt; a -----x-------</i></font>
<a name="line-407"></a><font color=Blue><i>-- &gt;        |</i></font>
<a name="line-408"></a><font color=Blue><i>-- &gt; b -----|---x---</i></font>
<a name="line-409"></a><font color=Blue><i>-- &gt;        |   |</i></font>
<a name="line-410"></a><font color=Blue><i>-- &gt;   0 |--N---N------ output: a xor b.</i></font>
<a name="line-411"></a><font color=Blue>template_bool_xor</font> <font color=Red>::</font>  Circ <font color=Cyan>(</font>Qubit <font color=Red>-&gt;</font> Circ <font color=Cyan>(</font>Qubit <font color=Red>-&gt;</font> Circ Qubit<font color=Cyan>)</font><font color=Cyan>)</font>
<a name="line-412"></a><font color=Blue>template_bool_xor</font> <font color=Red>=</font> return <font color=Cyan>$</font> <font color=Red>\</font>b1 <font color=Red>-&gt;</font> return <font color=Cyan>$</font> <font color=Red>\</font>b2 <font color=Red>-&gt;</font> <font color=Green><u>do</u></font> 
<a name="line-413"></a>         r <font color=Red>&lt;-</font> qinit_qubit False
<a name="line-414"></a>         qnot_at r <font color=Cyan>`controlled`</font> b1
<a name="line-415"></a>         qnot_at r <font color=Cyan>`controlled`</font> b2
<a name="line-416"></a>         return r
<a name="line-417"></a>
<a name="line-418"></a>
<a name="line-419"></a><font color=Blue><i>----------------------------------------------------------------------</i></font>
<a name="line-420"></a><font color=Blue><i>-- ** The if-then-else operation</i></font>
<a name="line-421"></a>
<a name="line-422"></a><font color=Blue><i>-- $IF The last term we need to build is @'template_if'@, a term</i></font>
<a name="line-423"></a><font color=Blue><i>-- describing the if-then-else construct as a circuit.</i></font>
<a name="line-424"></a>
<a name="line-425"></a><a name="template_if"></a><font color=Blue><i>-- | Lifted version of the @if-then-else@ construction: </i></font>
<a name="line-426"></a><font color=Blue><i>-- </i></font>
<a name="line-427"></a><font color=Blue><i>-- &gt; if-then-else :: Bool -&gt; b -&gt; b -&gt; b         </i></font>
<a name="line-428"></a><font color=Blue><i>-- </i></font>
<a name="line-429"></a><font color=Blue><i>-- We only allow first-order terms in the \"then\" and \"else\"</i></font>
<a name="line-430"></a><font color=Blue><i>-- clauses.  The circuit is:</i></font>
<a name="line-431"></a><font color=Blue><i>--</i></font>
<a name="line-432"></a><font color=Blue><i>-- &gt; q -----x---o---</i></font>
<a name="line-433"></a><font color=Blue><i>-- &gt;        |   |</i></font>
<a name="line-434"></a><font color=Blue><i>-- &gt; a -----x---|---</i></font>
<a name="line-435"></a><font color=Blue><i>-- &gt;        |   |</i></font>
<a name="line-436"></a><font color=Blue><i>-- &gt; b -----|---x---</i></font>
<a name="line-437"></a><font color=Blue><i>-- &gt;        |   |</i></font>
<a name="line-438"></a><font color=Blue><i>-- &gt;   0 |--N---N-------- wire output of the function.</i></font>
<a name="line-439"></a><font color=Blue>template_if</font> <font color=Red>::</font> <font color=Cyan>(</font>QData b<font color=Cyan>)</font> <font color=Red>=&gt;</font> Circ Qubit <font color=Red>-&gt;</font> Circ b <font color=Red>-&gt;</font> Circ b <font color=Red>-&gt;</font> Circ b
<a name="line-440"></a><font color=Blue>template_if</font> x a b <font color=Red>=</font> <font color=Green><u>do</u></font>
<a name="line-441"></a>   x' <font color=Red>&lt;-</font> x<font color=Cyan>;</font> a' <font color=Red>&lt;-</font> a<font color=Cyan>;</font> b' <font color=Red>&lt;-</font> b<font color=Cyan>;</font> map2Q <font color=Cyan>(</font>testOnQubit x'<font color=Cyan>)</font> <font color=Cyan>(</font>a'<font color=Cyan>,</font>b'<font color=Cyan>)</font>
<a name="line-442"></a>   <font color=Green><u>where</u></font>
<a name="line-443"></a>   testOnQubit <font color=Red>::</font> Qubit <font color=Red>-&gt;</font> <font color=Cyan>(</font>Qubit<font color=Cyan>,</font>Qubit<font color=Cyan>)</font> <font color=Red>-&gt;</font> Circ Qubit
<a name="line-444"></a>   testOnQubit x <font color=Cyan>(</font>a<font color=Cyan>,</font>b<font color=Cyan>)</font> <font color=Red>=</font> <font color=Green><u>do</u></font>
<a name="line-445"></a>       r <font color=Red>&lt;-</font> qinit_qubit False
<a name="line-446"></a>       qnot_at r <font color=Cyan>`controlled`</font> x <font color=Cyan>.==.</font> <font color=Magenta>1</font> <font color=Cyan>.&amp;&amp;.</font> a <font color=Cyan>.==.</font> <font color=Magenta>1</font>
<a name="line-447"></a>       qnot_at r <font color=Cyan>`controlled`</font> x <font color=Cyan>.==.</font> <font color=Magenta>0</font> <font color=Cyan>.&amp;&amp;.</font> b <font color=Cyan>.==.</font> <font color=Magenta>1</font>
<a name="line-448"></a>       return r
<a name="line-449"></a>
<a name="line-450"></a><font color=Blue><i>-- ----------------------------------------------------------------------</i></font>
<a name="line-451"></a><font color=Blue><i>-- * Operations of the Eq class</i></font>
<a name="line-452"></a>       
<a name="line-453"></a><a name="template_symb_equal_symb_equal_"></a><font color=Blue><i>-- | Lifted version of the '==' operator:</i></font>
<a name="line-454"></a><font color=Blue><i>-- </i></font>
<a name="line-455"></a><font color=Blue><i>-- &gt; (==) :: Eq a =&gt; a -&gt; a -&gt; Bool</i></font>
<a name="line-456"></a><font color=Blue>template_symb_equal_symb_equal_</font> <font color=Red>::</font> <font color=Cyan>(</font>QEq qa<font color=Cyan>)</font> <font color=Red>=&gt;</font> Circ <font color=Cyan>(</font>qa <font color=Red>-&gt;</font> Circ <font color=Cyan>(</font>qa <font color=Red>-&gt;</font> Circ Qubit<font color=Cyan>)</font><font color=Cyan>)</font>
<a name="line-457"></a><font color=Blue>template_symb_equal_symb_equal_</font> <font color=Red>=</font> return <font color=Cyan>$</font> <font color=Red>\</font>qx <font color=Red>-&gt;</font> return <font color=Cyan>$</font> <font color=Red>\</font>qy <font color=Red>-&gt;</font> <font color=Green><u>do</u></font> <font color=Cyan>(</font>qx<font color=Cyan>,</font>qy<font color=Cyan>,</font>test<font color=Cyan>)</font> <font color=Red>&lt;-</font> q_is_equal qx qy<font color=Cyan>;</font> return test
<a name="line-458"></a>
<a name="line-459"></a><font color=Blue><i>-- ----------------------------------------------------------------------</i></font>
<a name="line-460"></a><font color=Blue><i>-- * Generic unpacking</i></font>
<a name="line-461"></a>
<a name="line-462"></a><font color=Blue><i>-- $ The 'decToCircMonad' function produces (and also requires)</i></font>
<a name="line-463"></a><font color=Blue><i>-- functions with somewhat unwieldy types. We define generic functions</i></font>
<a name="line-464"></a><font color=Blue><i>-- for unpacking these types into a more useable format, and for</i></font>
<a name="line-465"></a><font color=Blue><i>-- packing them back.</i></font>
<a name="line-466"></a><font color=Blue><i>-- </i></font>
<a name="line-467"></a><font color=Blue><i>-- For example, @'Circ' (qa -&gt; 'Circ' (qb -&gt; 'Circ' qd))@ unpacks</i></font>
<a name="line-468"></a><font color=Blue><i>-- into the type @qa -&gt; qb -&gt; 'Circ' qd@.</i></font>
<a name="line-469"></a><font color=Blue><i>-- </i></font>
<a name="line-470"></a><font color=Blue><i>-- The class 'CircLiftingUnpack' keeps track of the unpacked and</i></font>
<a name="line-471"></a><font color=Blue><i>-- packed versions of types; so it will have an instance</i></font>
<a name="line-472"></a><font color=Blue><i>-- </i></font>
<a name="line-473"></a><font color=Blue><i>-- &gt; @'CircLiftingUnpack' ('Circ' (qa -&gt; 'Circ' (qb -&gt; 'Circ' qd))) (qa -&gt; qb -&gt; 'Circ' qd)@, </i></font>
<a name="line-474"></a><font color=Blue><i>-- </i></font>
<a name="line-475"></a><font color=Blue><i>-- and provide functions 'unpack', 'pack' going back and forth between</i></font>
<a name="line-476"></a><font color=Blue><i>-- these.</i></font>
<a name="line-477"></a><font color=Blue><i>-- </i></font>
<a name="line-478"></a><font color=Blue><i>-- Note that 'pack' and 'unpack' do not in general form an</i></font>
<a name="line-479"></a><font color=Blue><i>-- isomorphism, just a retraction of the packed type onto the unpacked</i></font>
<a name="line-480"></a><font color=Blue><i>-- type.</i></font>
<a name="line-481"></a><font color=Blue><i>-- </i></font>
<a name="line-482"></a><font color=Blue><i>-- Unfortunately the class cannot (in the current implementation) be</i></font>
<a name="line-483"></a><font color=Blue><i>-- defined in full generality once and for all: whenever a user wishes</i></font>
<a name="line-484"></a><font color=Blue><i>-- to use a new type @QFoo@ in circuit-building functions, she must</i></font>
<a name="line-485"></a><font color=Blue><i>-- define an additional base case @'CircLiftingUnpack' ('Circ' QFoo)</i></font>
<a name="line-486"></a><font color=Blue><i>-- ('Circ' QFoo)@ (with 'pack' and 'unpack' the identity) to use this</i></font>
<a name="line-487"></a><font color=Blue><i>-- class with types involving @QFoo@.</i></font>
<a name="line-488"></a><font color=Blue><i>-- </i></font>
<a name="line-489"></a><font color=Blue><i>-- The crucial case is </i></font>
<a name="line-490"></a><font color=Blue><i>-- </i></font>
<a name="line-491"></a><font color=Blue><i>-- &gt; instance ('CircLiftingUnpack' ('Circ' b) b') =&gt; 'CircLiftingUnpack' ('Circ' (a -&gt; 'Circ' b)) (a -&gt; b')@.</i></font>
<a name="line-492"></a><font color=Blue><i>-- </i></font>
<a name="line-493"></a><font color=Blue><i>-- Unfortunately, this requires @-XUndecidableInstances@, for somewhat</i></font>
<a name="line-494"></a><font color=Blue><i>-- subtle reasons (see</i></font>
<a name="line-495"></a><font color=Blue><i>-- &lt;<a href="http://hackage.haskell.org/trac/haskell-prime/wiki/FunctionalDependencies#Restrictionsoninstances">http://hackage.haskell.org/trac/haskell-prime/wiki/FunctionalDependencies#Restrictionsoninstances</a>&gt;,</i></font>
<a name="line-496"></a><font color=Blue><i>-- &lt;<a href="http://hackage.haskell.org/trac/haskell-prime/wiki/FunctionalDependencies#Modifiedcoveragecondition">http://hackage.haskell.org/trac/haskell-prime/wiki/FunctionalDependencies#Modifiedcoveragecondition</a>&gt;).</i></font>
<a name="line-497"></a><font color=Blue><i>-- </i></font>
<a name="line-498"></a><font color=Blue><i>-- The current implementation is fairly restricted, working</i></font>
<a name="line-499"></a><font color=Blue><i>-- essentially only for cases like the examples above.  One can define</i></font>
<a name="line-500"></a><font color=Blue><i>-- the unpacking more generally; but this restriction keeps the</i></font>
<a name="line-501"></a><font color=Blue><i>-- definition much simpler, and suffices for most (all?) of the</i></font>
<a name="line-502"></a><font color=Blue><i>-- circuit-generation functions we use.</i></font>
<a name="line-503"></a>
<a name="line-504"></a><a name="CircLiftingUnpack"></a><font color=Blue><i>-- | The 'decToCircMonad' function produces (and also requires)</i></font>
<a name="line-505"></a><a name="CircLiftingUnpack"></a><font color=Blue><i>-- functions with somewhat unwieldy types. The 'CircLiftingUnpack'</i></font>
<a name="line-506"></a><a name="CircLiftingUnpack"></a><font color=Blue><i>-- class defines generic functions for unpacking these types into a</i></font>
<a name="line-507"></a><a name="CircLiftingUnpack"></a><font color=Blue><i>-- more useable format, and for packing them back.</i></font>
<a name="line-508"></a><a name="CircLiftingUnpack"></a><font color=Blue><i>-- </i></font>
<a name="line-509"></a><a name="CircLiftingUnpack"></a><font color=Blue><i>-- For example, @'Circ' (qa -&gt; 'Circ' (qb -&gt; 'Circ' qd))@ unpacks into</i></font>
<a name="line-510"></a><a name="CircLiftingUnpack"></a><font color=Blue><i>-- the type @qa -&gt; qb -&gt; 'Circ' qd@.</i></font>
<a name="line-511"></a><a name="CircLiftingUnpack"></a><font color=Blue><i>-- </i></font>
<a name="line-512"></a><a name="CircLiftingUnpack"></a><font color=Blue><i>-- Note that 'pack' and 'unpack' do not in general form an</i></font>
<a name="line-513"></a><a name="CircLiftingUnpack"></a><font color=Blue><i>-- isomorphism, just a retraction of the packed type onto the unpacked</i></font>
<a name="line-514"></a><a name="CircLiftingUnpack"></a><font color=Blue><i>-- type.</i></font>
<a name="line-515"></a><a name="CircLiftingUnpack"></a><font color=Green><u>class</u></font> CircLiftingUnpack packed unpacked <font color=Red>|</font> packed <font color=Red>-&gt;</font> unpacked<font color=Cyan>,</font> unpacked <font color=Red>-&gt;</font> packed <font color=Green><u>where</u></font>
<a name="line-516"></a>  unpack <font color=Red>::</font> packed <font color=Red>-&gt;</font> unpacked
<a name="line-517"></a>  pack <font color=Red>::</font> unpacked <font color=Red>-&gt;</font> packed
<a name="line-518"></a>
<a name="line-519"></a><a name="instance%20CircLiftingUnpack%20(Circ%20(a%20-%3e%20Circ%20b))%20(a%20-%3e%20b')"></a><font color=Green><u>instance</u></font> <font color=Cyan>(</font>CircLiftingUnpack <font color=Cyan>(</font>Circ b<font color=Cyan>)</font> b'<font color=Cyan>)</font> <font color=Red>=&gt;</font> CircLiftingUnpack <font color=Cyan>(</font>Circ <font color=Cyan>(</font>a <font color=Red>-&gt;</font> Circ b<font color=Cyan>)</font><font color=Cyan>)</font> <font color=Cyan>(</font>a <font color=Red>-&gt;</font> b'<font color=Cyan>)</font> <font color=Green><u>where</u></font>
<a name="line-520"></a>  unpack cf x <font color=Red>=</font> unpack <font color=Cyan>$</font> <font color=Green><u>do</u></font> f <font color=Red>&lt;-</font> cf<font color=Cyan>;</font> f x
<a name="line-521"></a>  pack f <font color=Red>=</font> return <font color=Cyan>$</font> <font color=Red>\</font>x <font color=Red>-&gt;</font> pack <font color=Cyan>(</font>f x<font color=Cyan>)</font>
<a name="line-522"></a>
<a name="line-523"></a><a name="instance%20CircLiftingUnpack%20(Circ%20Qubit)%20(Circ%20Qubit)"></a><font color=Green><u>instance</u></font> CircLiftingUnpack <font color=Cyan>(</font>Circ Qubit<font color=Cyan>)</font> <font color=Cyan>(</font>Circ Qubit<font color=Cyan>)</font> <font color=Green><u>where</u></font>
<a name="line-524"></a>  pack x <font color=Red>=</font> x
<a name="line-525"></a>  unpack x <font color=Red>=</font> x
<a name="line-526"></a>
<a name="line-527"></a><a name="instance%20CircLiftingUnpack%20(Circ%20%5ba%5d)%20(Circ%20%5ba%5d)"></a><font color=Green><u>instance</u></font> CircLiftingUnpack <font color=Cyan>(</font>Circ <font color=Red>[</font>a<font color=Red>]</font><font color=Cyan>)</font> <font color=Cyan>(</font>Circ <font color=Red>[</font>a<font color=Red>]</font><font color=Cyan>)</font> <font color=Green><u>where</u></font>
<a name="line-528"></a>  pack x <font color=Red>=</font> x
<a name="line-529"></a>  unpack x <font color=Red>=</font> x
<a name="line-530"></a>
<a name="line-531"></a><a name="instance%20CircLiftingUnpack%20(Circ%20())%20(Circ%20())"></a><font color=Green><u>instance</u></font> CircLiftingUnpack <font color=Cyan>(</font>Circ ()<font color=Cyan>)</font> <font color=Cyan>(</font>Circ ()<font color=Cyan>)</font> <font color=Green><u>where</u></font>
<a name="line-532"></a>  pack x <font color=Red>=</font> x
<a name="line-533"></a>  unpack x <font color=Red>=</font> x
<a name="line-534"></a>
<a name="line-535"></a><a name="instance%20CircLiftingUnpack%20(Circ%20(a,b))%20(Circ%20(a,b))"></a><font color=Green><u>instance</u></font> CircLiftingUnpack <font color=Cyan>(</font>Circ <font color=Cyan>(</font>a<font color=Cyan>,</font>b<font color=Cyan>)</font><font color=Cyan>)</font> <font color=Cyan>(</font>Circ <font color=Cyan>(</font>a<font color=Cyan>,</font>b<font color=Cyan>)</font><font color=Cyan>)</font> <font color=Green><u>where</u></font>
<a name="line-536"></a>  pack x <font color=Red>=</font> x
<a name="line-537"></a>  unpack x <font color=Red>=</font> x
<a name="line-538"></a>
<a name="line-539"></a><a name="instance%20CircLiftingUnpack%20(Circ%20(a,b,c))%20(Circ%20(a,b,c))"></a><font color=Green><u>instance</u></font> CircLiftingUnpack <font color=Cyan>(</font>Circ <font color=Cyan>(</font>a<font color=Cyan>,</font>b<font color=Cyan>,</font>c<font color=Cyan>)</font><font color=Cyan>)</font> <font color=Cyan>(</font>Circ <font color=Cyan>(</font>a<font color=Cyan>,</font>b<font color=Cyan>,</font>c<font color=Cyan>)</font><font color=Cyan>)</font> <font color=Green><u>where</u></font>
<a name="line-540"></a>  pack x <font color=Red>=</font> x
<a name="line-541"></a>  unpack x <font color=Red>=</font> x
<a name="line-542"></a>
<a name="line-543"></a><a name="instance%20CircLiftingUnpack%20(Circ%20(a,b,c,d))%20(Circ%20(a,b,c,d))"></a><font color=Green><u>instance</u></font> CircLiftingUnpack <font color=Cyan>(</font>Circ <font color=Cyan>(</font>a<font color=Cyan>,</font>b<font color=Cyan>,</font>c<font color=Cyan>,</font>d<font color=Cyan>)</font><font color=Cyan>)</font> <font color=Cyan>(</font>Circ <font color=Cyan>(</font>a<font color=Cyan>,</font>b<font color=Cyan>,</font>c<font color=Cyan>,</font>d<font color=Cyan>)</font><font color=Cyan>)</font> <font color=Green><u>where</u></font>
<a name="line-544"></a>  pack x <font color=Red>=</font> x
<a name="line-545"></a>  unpack x <font color=Red>=</font> x
<a name="line-546"></a>
<a name="line-547"></a><a name="instance%20CircLiftingUnpack%20(Circ%20(a,b,c,d,e))%20(Circ%20(a,b,c,d,e))"></a><font color=Green><u>instance</u></font> CircLiftingUnpack <font color=Cyan>(</font>Circ <font color=Cyan>(</font>a<font color=Cyan>,</font>b<font color=Cyan>,</font>c<font color=Cyan>,</font>d<font color=Cyan>,</font>e<font color=Cyan>)</font><font color=Cyan>)</font> <font color=Cyan>(</font>Circ <font color=Cyan>(</font>a<font color=Cyan>,</font>b<font color=Cyan>,</font>c<font color=Cyan>,</font>d<font color=Cyan>,</font>e<font color=Cyan>)</font><font color=Cyan>)</font> <font color=Green><u>where</u></font>
<a name="line-548"></a>  pack x <font color=Red>=</font> x
<a name="line-549"></a>  unpack x <font color=Red>=</font> x
<a name="line-550"></a>
<a name="line-551"></a><a name="instance%20CircLiftingUnpack%20(Circ%20(a,b,c,d,e,f))%20(Circ%20(a,b,c,d,e,f))"></a><font color=Green><u>instance</u></font> CircLiftingUnpack <font color=Cyan>(</font>Circ <font color=Cyan>(</font>a<font color=Cyan>,</font>b<font color=Cyan>,</font>c<font color=Cyan>,</font>d<font color=Cyan>,</font>e<font color=Cyan>,</font>f<font color=Cyan>)</font><font color=Cyan>)</font> <font color=Cyan>(</font>Circ <font color=Cyan>(</font>a<font color=Cyan>,</font>b<font color=Cyan>,</font>c<font color=Cyan>,</font>d<font color=Cyan>,</font>e<font color=Cyan>,</font>f<font color=Cyan>)</font><font color=Cyan>)</font> <font color=Green><u>where</u></font>
<a name="line-552"></a>  pack x <font color=Red>=</font> x
<a name="line-553"></a>  unpack x <font color=Red>=</font> x
<a name="line-554"></a>
<a name="line-555"></a><a name="instance%20CircLiftingUnpack%20(Circ%20(a,b,c,d,e,f,g))%20(Circ%20(a,b,c,d,e,f,g))"></a><font color=Green><u>instance</u></font> CircLiftingUnpack <font color=Cyan>(</font>Circ <font color=Cyan>(</font>a<font color=Cyan>,</font>b<font color=Cyan>,</font>c<font color=Cyan>,</font>d<font color=Cyan>,</font>e<font color=Cyan>,</font>f<font color=Cyan>,</font>g<font color=Cyan>)</font><font color=Cyan>)</font> <font color=Cyan>(</font>Circ <font color=Cyan>(</font>a<font color=Cyan>,</font>b<font color=Cyan>,</font>c<font color=Cyan>,</font>d<font color=Cyan>,</font>e<font color=Cyan>,</font>f<font color=Cyan>,</font>g<font color=Cyan>)</font><font color=Cyan>)</font> <font color=Green><u>where</u></font>
<a name="line-556"></a>  pack x <font color=Red>=</font> x
<a name="line-557"></a>  unpack x <font color=Red>=</font> x
</pre>
</body>
</html>