<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<!-- Generated by HsColour, http://code.haskell.org/~malcolm/hscolour/ -->
<title>Haskell code</title>
</head>
<body>
<pre><a name="line-1"></a><font color=Blue><i>{-# LANGUAGE TypeFamilies #-}</i></font>
<a name="line-2"></a><font color=Blue><i>{-# LANGUAGE ScopedTypeVariables #-}</i></font>
<a name="line-3"></a><font color=Blue><i>{-# LANGUAGE MultiParamTypeClasses #-}</i></font>
<a name="line-4"></a><font color=Blue><i>{-# LANGUAGE FunctionalDependencies #-}</i></font>
<a name="line-5"></a><font color=Blue><i>{-# LANGUAGE FlexibleContexts #-}</i></font>
<a name="line-6"></a><font color=Blue><i>{-# LANGUAGE FlexibleInstances #-}</i></font>
<a name="line-7"></a><font color=Blue><i>{-# LANGUAGE UndecidableInstances #-}</i></font>
<a name="line-8"></a>
<a name="line-9"></a><font color=Blue><i>{-# OPTIONS -fcontext-stack=50 #-}</i></font>
<a name="line-10"></a>
<a name="line-11"></a><font color=Blue><i>-- -O0 is needed for this file, because -O1 triggers a compiler bug in</i></font>
<a name="line-12"></a><font color=Blue><i>-- ghc 7.2.2 (see <a href="http://hackage.haskell.org/trac/ghc/ticket/6168),">http://hackage.haskell.org/trac/ghc/ticket/6168),</a></i></font>
<a name="line-13"></a><font color=Blue><i>-- and -O2 triggers a different compiler bug in ghc 7.2.2</i></font>
<a name="line-14"></a>
<a name="line-15"></a><font color=Blue><i>{-# OPTIONS_GHC -O0 #-}</i></font>
<a name="line-16"></a>
<a name="line-17"></a><font color=Blue><i>-- | This module provides type classes for dealing with various</i></font>
<a name="line-18"></a><font color=Blue><i>-- \"shaped\" quantum and classical data structures. Examples of data</i></font>
<a name="line-19"></a><font color=Blue><i>-- structures are tuples, lists, records, registers, arrays, indexed</i></font>
<a name="line-20"></a><font color=Blue><i>-- arrays, etc. Is it convenient to extend certain operations to</i></font>
<a name="line-21"></a><font color=Blue><i>-- arbitrary quantum data structures; for example, instead of</i></font>
<a name="line-22"></a><font color=Blue><i>-- measuring a single qubit and obtaining a bit, one may measure an</i></font>
<a name="line-23"></a><font color=Blue><i>-- /n/-tuple of qubits and obtain an /n/-tuple of bits. We call an</i></font>
<a name="line-24"></a><font color=Blue><i>-- operation \"generic\" if it can act on arbitrary data structures. </i></font>
<a name="line-25"></a><font color=Blue><i>-- </i></font>
<a name="line-26"></a><font color=Blue><i>-- This module provides shaped types and low-level combinators, in</i></font>
<a name="line-27"></a><font color=Blue><i>-- terms of which higher-level generic quantum operations can be</i></font>
<a name="line-28"></a><font color=Blue><i>-- defined. </i></font>
<a name="line-29"></a><font color=Blue><i>-- </i></font>
<a name="line-30"></a><font color=Blue><i>-- The low-level combinators provided by this module (with names</i></font>
<a name="line-31"></a><font color=Blue><i>-- /qcdata_*/ and /qdata_*/) should never be used directly in user</i></font>
<a name="line-32"></a><font color=Blue><i>-- code (and for this reason, they are not re-exported by</i></font>
<a name="line-33"></a><font color=Blue><i>-- "Quipper"). Instead, they are intended as building blocks for</i></font>
<a name="line-34"></a><font color=Blue><i>-- user-level generic functions (in "Quipper.Generic" and related</i></font>
<a name="line-35"></a><font color=Blue><i>-- modules). The only exception is that the functions may be used in</i></font>
<a name="line-36"></a><font color=Blue><i>-- libraries or user-level code to define new quantum data</i></font>
<a name="line-37"></a><font color=Blue><i>-- constructors. Modules that contain such definitions should import</i></font>
<a name="line-38"></a><font color=Blue><i>-- 'Quipper.Internal'.</i></font>
<a name="line-39"></a>
<a name="line-40"></a><font color=Green><u>module</u></font> Quipper<font color=Cyan>.</font>QData <font color=Green><u>where</u></font>
<a name="line-41"></a>
<a name="line-42"></a><font color=Blue><i>-- import other Quipper stuff</i></font>
<a name="line-43"></a><font color=Green><u>import</u></font> Quipper<font color=Cyan>.</font>Monad
<a name="line-44"></a><font color=Green><u>import</u></font> Libraries<font color=Cyan>.</font>Auxiliary
<a name="line-45"></a><font color=Green><u>import</u></font> Libraries<font color=Cyan>.</font>Tuple
<a name="line-46"></a><font color=Green><u>import</u></font> Quipper<font color=Cyan>.</font>Labels
<a name="line-47"></a><font color=Green><u>import</u></font> Quipper<font color=Cyan>.</font>Transformer
<a name="line-48"></a><font color=Green><u>import</u></font> Quipper<font color=Cyan>.</font>Control
<a name="line-49"></a>
<a name="line-50"></a><font color=Green><u>import</u></font> Data<font color=Cyan>.</font>Typeable
<a name="line-51"></a><font color=Green><u>import</u></font> Libraries<font color=Cyan>.</font>Typeable
<a name="line-52"></a><font color=Green><u>import</u></font> Control<font color=Cyan>.</font>Monad<font color=Cyan>.</font>State
<a name="line-53"></a>
<a name="line-54"></a><font color=Blue><i>-- ======================================================================</i></font>
<a name="line-55"></a><font color=Blue><i>-- * Introduction</i></font>
<a name="line-56"></a>
<a name="line-57"></a><font color=Blue><i>-- $ The data types we consider here come in two varieties:</i></font>
<a name="line-58"></a><font color=Blue><i>-- /homogeneous/ and /heterogeneous/ types.</i></font>
<a name="line-59"></a><font color=Blue><i>-- </i></font>
<a name="line-60"></a><font color=Blue><i>-- A /homogeneous/ data type describes a data structure that is built</i></font>
<a name="line-61"></a><font color=Blue><i>-- up from only one kind of basic data (for example, only qubits, only</i></font>
<a name="line-62"></a><font color=Blue><i>-- classical bits, or only boolean parameters). The following are</i></font>
<a name="line-63"></a><font color=Blue><i>-- typical examples of homogeneous types:</i></font>
<a name="line-64"></a><font color=Blue><i>-- </i></font>
<a name="line-65"></a><font color=Blue><i>-- &gt; qa = (Qubit, Qubit, [Qubit])</i></font>
<a name="line-66"></a><font color=Blue><i>-- &gt; ca = (Bit, Bit, [Bit])</i></font>
<a name="line-67"></a><font color=Blue><i>-- &gt; ba = (Bool, Bool, [Bool]).</i></font>
<a name="line-68"></a><font color=Blue><i>-- </i></font>
<a name="line-69"></a><font color=Blue><i>-- An important feature of homogeneous types is that they can be</i></font>
<a name="line-70"></a><font color=Blue><i>-- related to each other by shape. For example, /ca/ above is the</i></font>
<a name="line-71"></a><font color=Blue><i>-- \"classical version\" of /qa/. We say that the above types /qa/,</i></font>
<a name="line-72"></a><font color=Blue><i>-- /ca/, and /ba/ all share the same /shape type/. On the other hand,</i></font>
<a name="line-73"></a><font color=Blue><i>-- they differ in their /leaf types/, which are 'Qubit', 'Bit', and</i></font>
<a name="line-74"></a><font color=Blue><i>-- 'Bool', respectively.</i></font>
<a name="line-75"></a><font color=Blue><i>-- </i></font>
<a name="line-76"></a><font color=Blue><i>-- When naming types, variables, and operations related to homogeneous</i></font>
<a name="line-77"></a><font color=Blue><i>-- data structures, we often use letters such as /q/, /c/, and /b/ to</i></font>
<a name="line-78"></a><font color=Blue><i>-- denote, respectively, the quantum, classical, and boolean versions</i></font>
<a name="line-79"></a><font color=Blue><i>-- of some concept.</i></font>
<a name="line-80"></a><font color=Blue><i>-- </i></font>
<a name="line-81"></a><font color=Blue><i>-- Homogeneous types are made available to Quipper programs via the</i></font>
<a name="line-82"></a><font color=Blue><i>-- 'QData' and 'QShape' type classes.</i></font>
<a name="line-83"></a><font color=Blue><i>-- </i></font>
<a name="line-84"></a><font color=Blue><i>-- A /heterogeneous/ data type describes a data structure that may</i></font>
<a name="line-85"></a><font color=Blue><i>-- contain both classical and quantum bits. A typical example of a</i></font>
<a name="line-86"></a><font color=Blue><i>-- heterogeneous type is:</i></font>
<a name="line-87"></a><font color=Blue><i>-- </i></font>
<a name="line-88"></a><font color=Blue><i>-- &gt; qc = (Qubit, Bit, [Qubit]).</i></font>
<a name="line-89"></a><font color=Blue><i>-- </i></font>
<a name="line-90"></a><font color=Blue><i>-- Heterogeneous types are often used to represent sets of</i></font>
<a name="line-91"></a><font color=Blue><i>-- endpoints of a circuit, or the inputs or outputs to some circuit</i></font>
<a name="line-92"></a><font color=Blue><i>-- building function. We often use the letters /qc/ in connection with</i></font>
<a name="line-93"></a><font color=Blue><i>-- heterogeneous types.</i></font>
<a name="line-94"></a><font color=Blue><i>-- </i></font>
<a name="line-95"></a><font color=Blue><i>-- Heterogeneous types are made available to Quipper programs via the</i></font>
<a name="line-96"></a><font color=Blue><i>-- 'QCData' and 'QCDataPlus' type classes.</i></font>
<a name="line-97"></a>
<a name="line-98"></a><font color=Blue><i>-- ======================================================================</i></font>
<a name="line-99"></a><font color=Blue><i>-- * Primitive definitions</i></font>
<a name="line-100"></a>
<a name="line-101"></a><font color=Blue><i>-- $ The type classes of this module are all derived from four</i></font>
<a name="line-102"></a><font color=Blue><i>-- primitive items, which must be defined by induction on types:</i></font>
<a name="line-103"></a><font color=Blue><i>-- </i></font>
<a name="line-104"></a><font color=Blue><i>-- * A type class 'QCData' /qc/, representing structured data types</i></font>
<a name="line-105"></a><font color=Blue><i>-- made up from classical and quantum leaves.</i></font>
<a name="line-106"></a><font color=Blue><i>-- </i></font>
<a name="line-107"></a><font color=Blue><i>-- * A type family 'QCType' /x/ /y/ /qc/, representing the type-level</i></font>
<a name="line-108"></a><font color=Blue><i>-- substitution operation [nobr /qc/ [/x/ \/ 'Qubit', /y/ \/ 'Bit']].</i></font>
<a name="line-109"></a><font color=Blue><i>-- </i></font>
<a name="line-110"></a><font color=Blue><i>-- * A type family 'QTypeB' /ba/, representing the type-level substitution</i></font>
<a name="line-111"></a><font color=Blue><i>-- [nobr /ba/ ['Qubit' \/ 'Bool']].</i></font>
<a name="line-112"></a><font color=Blue><i>-- </i></font>
<a name="line-113"></a><font color=Blue><i>-- * A type class 'SimpleType' /qc/, representing \"simple\" data</i></font>
<a name="line-114"></a><font color=Blue><i>-- types. We say that a data type /t/ is \"simple\" if any two</i></font>
<a name="line-115"></a><font color=Blue><i>-- elements of /t/ have the same number of leaves. For example, tuples</i></font>
<a name="line-116"></a><font color=Blue><i>-- are simple, but lists are not.</i></font>
<a name="line-117"></a><font color=Blue><i>-- </i></font>
<a name="line-118"></a><font color=Blue><i>-- An instance of 'QCData', 'QCType' and 'QTypeB' must be defined for</i></font>
<a name="line-119"></a><font color=Blue><i>-- each new kind of quantum data. If the quantum data is simple, an</i></font>
<a name="line-120"></a><font color=Blue><i>-- instance of 'SimpleType' must also be defined.</i></font>
<a name="line-121"></a><font color=Blue><i>-- </i></font>
<a name="line-122"></a><font color=Blue><i>-- All other notions in this module are defined in terms of the above</i></font>
<a name="line-123"></a><font color=Blue><i>-- four, and therefore need not be defined on a per-type basis.</i></font>
<a name="line-124"></a>
<a name="line-125"></a><font color=Blue><i>-- ----------------------------------------------------------------------</i></font>
<a name="line-126"></a><font color=Blue><i>-- ** The QCType operation</i></font>
<a name="line-127"></a>
<a name="line-128"></a><a name="QCType"></a><font color=Blue><i>-- | The type 'QCType' /x/ /y/ /a/ represents the substitution</i></font>
<a name="line-129"></a><a name="QCType"></a><font color=Blue><i>-- [nobr /a/ [/x/ \/ 'Qubit', /y/ \/ 'Bit']]. For example:</i></font>
<a name="line-130"></a><a name="QCType"></a><font color=Blue><i>-- </i></font>
<a name="line-131"></a><a name="QCType"></a><font color=Blue><i>-- &gt; QCType x y (Qubit, Bit, [Qubit]) = (x, y, [x]).</i></font>
<a name="line-132"></a><a name="QCType"></a><font color=Blue><i>-- </i></font>
<a name="line-133"></a><a name="QCType"></a><font color=Blue><i>-- An instance of this must be defined for each new kind of quantum</i></font>
<a name="line-134"></a><a name="QCType"></a><font color=Blue><i>-- data.</i></font>
<a name="line-135"></a><a name="QCType"></a><font color=Green><u>type</u></font> <font color=Green><u>family</u></font> QCType x y a
<a name="line-136"></a><font color=Green><u>type</u></font> <font color=Green><u>instance</u></font> QCType x y Qubit <font color=Red>=</font> x
<a name="line-137"></a><font color=Green><u>type</u></font> <font color=Green><u>instance</u></font> QCType x y Bit <font color=Red>=</font> y
<a name="line-138"></a>
<a name="line-139"></a><font color=Green><u>type</u></font> <font color=Green><u>instance</u></font> QCType x y () <font color=Red>=</font> ()
<a name="line-140"></a><font color=Green><u>type</u></font> <font color=Green><u>instance</u></font> QCType x y <font color=Cyan>(</font>a<font color=Cyan>,</font>b<font color=Cyan>)</font> <font color=Red>=</font> <font color=Cyan>(</font>QCType x y a<font color=Cyan>,</font> QCType x y b<font color=Cyan>)</font>
<a name="line-141"></a><font color=Green><u>type</u></font> <font color=Green><u>instance</u></font> QCType x y <font color=Cyan>(</font>a<font color=Cyan>,</font>b<font color=Cyan>,</font>c<font color=Cyan>)</font> <font color=Red>=</font> <font color=Cyan>(</font>QCType x y a<font color=Cyan>,</font> QCType x y b<font color=Cyan>,</font> QCType x y c<font color=Cyan>)</font>
<a name="line-142"></a><font color=Green><u>type</u></font> <font color=Green><u>instance</u></font> QCType x y <font color=Cyan>(</font>a<font color=Cyan>,</font>b<font color=Cyan>,</font>c<font color=Cyan>,</font>d<font color=Cyan>)</font> <font color=Red>=</font> <font color=Cyan>(</font>QCType x y a<font color=Cyan>,</font> QCType x y b<font color=Cyan>,</font> QCType x y c<font color=Cyan>,</font> QCType x y d<font color=Cyan>)</font>
<a name="line-143"></a><font color=Green><u>type</u></font> <font color=Green><u>instance</u></font> QCType x y <font color=Cyan>(</font>a<font color=Cyan>,</font>b<font color=Cyan>,</font>c<font color=Cyan>,</font>d<font color=Cyan>,</font>e<font color=Cyan>)</font> <font color=Red>=</font> <font color=Cyan>(</font>QCType x y a<font color=Cyan>,</font> QCType x y b<font color=Cyan>,</font> QCType x y c<font color=Cyan>,</font> QCType x y d<font color=Cyan>,</font> QCType x y e<font color=Cyan>)</font>
<a name="line-144"></a><font color=Green><u>type</u></font> <font color=Green><u>instance</u></font> QCType x y <font color=Cyan>(</font>a<font color=Cyan>,</font>b<font color=Cyan>,</font>c<font color=Cyan>,</font>d<font color=Cyan>,</font>e<font color=Cyan>,</font>f<font color=Cyan>)</font> <font color=Red>=</font> <font color=Cyan>(</font>QCType x y a<font color=Cyan>,</font> QCType x y b<font color=Cyan>,</font> QCType x y c<font color=Cyan>,</font> QCType x y d<font color=Cyan>,</font> QCType x y e<font color=Cyan>,</font> QCType x y f<font color=Cyan>)</font>
<a name="line-145"></a><font color=Green><u>type</u></font> <font color=Green><u>instance</u></font> QCType x y <font color=Cyan>(</font>a<font color=Cyan>,</font>b<font color=Cyan>,</font>c<font color=Cyan>,</font>d<font color=Cyan>,</font>e<font color=Cyan>,</font>f<font color=Cyan>,</font>g<font color=Cyan>)</font> <font color=Red>=</font> <font color=Cyan>(</font>QCType x y a<font color=Cyan>,</font> QCType x y b<font color=Cyan>,</font> QCType x y c<font color=Cyan>,</font> QCType x y d<font color=Cyan>,</font> QCType x y e<font color=Cyan>,</font> QCType x y f<font color=Cyan>,</font> QCType x y g<font color=Cyan>)</font>
<a name="line-146"></a><font color=Green><u>type</u></font> <font color=Green><u>instance</u></font> QCType x y <font color=Cyan>(</font>a<font color=Cyan>,</font>b<font color=Cyan>,</font>c<font color=Cyan>,</font>d<font color=Cyan>,</font>e<font color=Cyan>,</font>f<font color=Cyan>,</font>g<font color=Cyan>,</font>h<font color=Cyan>)</font> <font color=Red>=</font> <font color=Cyan>(</font>QCType x y a<font color=Cyan>,</font> QCType x y b<font color=Cyan>,</font> QCType x y c<font color=Cyan>,</font> QCType x y d<font color=Cyan>,</font> QCType x y e<font color=Cyan>,</font> QCType x y f<font color=Cyan>,</font> QCType x y g<font color=Cyan>,</font> QCType x y h<font color=Cyan>)</font>
<a name="line-147"></a><font color=Green><u>type</u></font> <font color=Green><u>instance</u></font> QCType x y <font color=Cyan>(</font>a<font color=Cyan>,</font>b<font color=Cyan>,</font>c<font color=Cyan>,</font>d<font color=Cyan>,</font>e<font color=Cyan>,</font>f<font color=Cyan>,</font>g<font color=Cyan>,</font>h<font color=Cyan>,</font>i<font color=Cyan>)</font> <font color=Red>=</font> <font color=Cyan>(</font>QCType x y a<font color=Cyan>,</font> QCType x y b<font color=Cyan>,</font> QCType x y c<font color=Cyan>,</font> QCType x y d<font color=Cyan>,</font> QCType x y e<font color=Cyan>,</font> QCType x y f<font color=Cyan>,</font> QCType x y g<font color=Cyan>,</font> QCType x y h<font color=Cyan>,</font> QCType x y i<font color=Cyan>)</font>
<a name="line-148"></a><font color=Green><u>type</u></font> <font color=Green><u>instance</u></font> QCType x y <font color=Cyan>(</font>a<font color=Cyan>,</font>b<font color=Cyan>,</font>c<font color=Cyan>,</font>d<font color=Cyan>,</font>e<font color=Cyan>,</font>f<font color=Cyan>,</font>g<font color=Cyan>,</font>h<font color=Cyan>,</font>i<font color=Cyan>,</font>j<font color=Cyan>)</font> <font color=Red>=</font> <font color=Cyan>(</font>QCType x y a<font color=Cyan>,</font> QCType x y b<font color=Cyan>,</font> QCType x y c<font color=Cyan>,</font> QCType x y d<font color=Cyan>,</font> QCType x y e<font color=Cyan>,</font> QCType x y f<font color=Cyan>,</font> QCType x y g<font color=Cyan>,</font> QCType x y h<font color=Cyan>,</font> QCType x y i<font color=Cyan>,</font> QCType x y j<font color=Cyan>)</font>
<a name="line-149"></a><font color=Green><u>type</u></font> <font color=Green><u>instance</u></font> QCType x y <font color=Red>[</font>a<font color=Red>]</font> <font color=Red>=</font> <font color=Red>[</font>QCType x y a<font color=Red>]</font>
<a name="line-150"></a><font color=Green><u>type</u></font> <font color=Green><u>instance</u></font> QCType x y <font color=Cyan>(</font>B_Endpoint a b<font color=Cyan>)</font> <font color=Red>=</font> B_Endpoint <font color=Cyan>(</font>QCType x y a<font color=Cyan>)</font> <font color=Cyan>(</font>QCType x y b<font color=Cyan>)</font>
<a name="line-151"></a><font color=Green><u>type</u></font> <font color=Green><u>instance</u></font> QCType x y <font color=Cyan>(</font>Signed a<font color=Cyan>)</font> <font color=Red>=</font> Signed <font color=Cyan>(</font>QCType x y a<font color=Cyan>)</font>
<a name="line-152"></a>
<a name="line-153"></a><font color=Blue><i>-- ----------------------------------------------------------------------</i></font>
<a name="line-154"></a><font color=Blue><i>-- ** The QTypeB operation</i></font>
<a name="line-155"></a>
<a name="line-156"></a><a name="QTypeB"></a><font color=Blue><i>-- | The type 'QTypeB' /ba/ represents the substitution</i></font>
<a name="line-157"></a><a name="QTypeB"></a><font color=Blue><i>-- [nobr /ba/ ['Qubit' \/ 'Bool']]. For example: </i></font>
<a name="line-158"></a><a name="QTypeB"></a><font color=Blue><i>-- </i></font>
<a name="line-159"></a><a name="QTypeB"></a><font color=Blue><i>-- &gt; QTypeB (Bool, Bool, [Bool]) = (Qubit, Qubit, [Qubit]).</i></font>
<a name="line-160"></a><a name="QTypeB"></a><font color=Blue><i>-- </i></font>
<a name="line-161"></a><a name="QTypeB"></a><font color=Blue><i>-- An instance of this must be defined for each new kind of quantum data.</i></font>
<a name="line-162"></a><a name="QTypeB"></a><font color=Green><u>type</u></font> <font color=Green><u>family</u></font> QTypeB a
<a name="line-163"></a><font color=Green><u>type</u></font> <font color=Green><u>instance</u></font> QTypeB Bool <font color=Red>=</font> Qubit
<a name="line-164"></a><font color=Green><u>type</u></font> <font color=Green><u>instance</u></font> QTypeB () <font color=Red>=</font> ()
<a name="line-165"></a><font color=Green><u>type</u></font> <font color=Green><u>instance</u></font> QTypeB <font color=Cyan>(</font>a<font color=Cyan>,</font>b<font color=Cyan>)</font> <font color=Red>=</font> <font color=Cyan>(</font>QTypeB a<font color=Cyan>,</font> QTypeB b<font color=Cyan>)</font>
<a name="line-166"></a><font color=Green><u>type</u></font> <font color=Green><u>instance</u></font> QTypeB <font color=Cyan>(</font>a<font color=Cyan>,</font>b<font color=Cyan>,</font>c<font color=Cyan>)</font> <font color=Red>=</font> <font color=Cyan>(</font>QTypeB a<font color=Cyan>,</font> QTypeB b<font color=Cyan>,</font> QTypeB c<font color=Cyan>)</font>
<a name="line-167"></a><font color=Green><u>type</u></font> <font color=Green><u>instance</u></font> QTypeB <font color=Cyan>(</font>a<font color=Cyan>,</font>b<font color=Cyan>,</font>c<font color=Cyan>,</font>d<font color=Cyan>)</font> <font color=Red>=</font> <font color=Cyan>(</font>QTypeB a<font color=Cyan>,</font> QTypeB b<font color=Cyan>,</font> QTypeB c<font color=Cyan>,</font> QTypeB d<font color=Cyan>)</font>
<a name="line-168"></a><font color=Green><u>type</u></font> <font color=Green><u>instance</u></font> QTypeB <font color=Cyan>(</font>a<font color=Cyan>,</font>b<font color=Cyan>,</font>c<font color=Cyan>,</font>d<font color=Cyan>,</font>e<font color=Cyan>)</font> <font color=Red>=</font> <font color=Cyan>(</font>QTypeB a<font color=Cyan>,</font> QTypeB b<font color=Cyan>,</font> QTypeB c<font color=Cyan>,</font> QTypeB d<font color=Cyan>,</font> QTypeB e<font color=Cyan>)</font>
<a name="line-169"></a><font color=Green><u>type</u></font> <font color=Green><u>instance</u></font> QTypeB <font color=Cyan>(</font>a<font color=Cyan>,</font>b<font color=Cyan>,</font>c<font color=Cyan>,</font>d<font color=Cyan>,</font>e<font color=Cyan>,</font>f<font color=Cyan>)</font> <font color=Red>=</font> <font color=Cyan>(</font>QTypeB a<font color=Cyan>,</font> QTypeB b<font color=Cyan>,</font> QTypeB c<font color=Cyan>,</font> QTypeB d<font color=Cyan>,</font> QTypeB e<font color=Cyan>,</font> QTypeB f<font color=Cyan>)</font>
<a name="line-170"></a><font color=Green><u>type</u></font> <font color=Green><u>instance</u></font> QTypeB <font color=Cyan>(</font>a<font color=Cyan>,</font>b<font color=Cyan>,</font>c<font color=Cyan>,</font>d<font color=Cyan>,</font>e<font color=Cyan>,</font>f<font color=Cyan>,</font>g<font color=Cyan>)</font> <font color=Red>=</font> <font color=Cyan>(</font>QTypeB a<font color=Cyan>,</font> QTypeB b<font color=Cyan>,</font> QTypeB c<font color=Cyan>,</font> QTypeB d<font color=Cyan>,</font> QTypeB e<font color=Cyan>,</font> QTypeB f<font color=Cyan>,</font> QTypeB g<font color=Cyan>)</font>
<a name="line-171"></a><font color=Green><u>type</u></font> <font color=Green><u>instance</u></font> QTypeB <font color=Cyan>(</font>a<font color=Cyan>,</font>b<font color=Cyan>,</font>c<font color=Cyan>,</font>d<font color=Cyan>,</font>e<font color=Cyan>,</font>f<font color=Cyan>,</font>g<font color=Cyan>,</font>h<font color=Cyan>)</font> <font color=Red>=</font> <font color=Cyan>(</font>QTypeB a<font color=Cyan>,</font> QTypeB b<font color=Cyan>,</font> QTypeB c<font color=Cyan>,</font> QTypeB d<font color=Cyan>,</font> QTypeB e<font color=Cyan>,</font> QTypeB f<font color=Cyan>,</font> QTypeB g<font color=Cyan>,</font> QTypeB h<font color=Cyan>)</font>
<a name="line-172"></a><font color=Green><u>type</u></font> <font color=Green><u>instance</u></font> QTypeB <font color=Cyan>(</font>a<font color=Cyan>,</font>b<font color=Cyan>,</font>c<font color=Cyan>,</font>d<font color=Cyan>,</font>e<font color=Cyan>,</font>f<font color=Cyan>,</font>g<font color=Cyan>,</font>h<font color=Cyan>,</font>i<font color=Cyan>)</font> <font color=Red>=</font> <font color=Cyan>(</font>QTypeB a<font color=Cyan>,</font> QTypeB b<font color=Cyan>,</font> QTypeB c<font color=Cyan>,</font> QTypeB d<font color=Cyan>,</font> QTypeB e<font color=Cyan>,</font> QTypeB f<font color=Cyan>,</font> QTypeB g<font color=Cyan>,</font> QTypeB h<font color=Cyan>,</font> QTypeB i<font color=Cyan>)</font>
<a name="line-173"></a><font color=Green><u>type</u></font> <font color=Green><u>instance</u></font> QTypeB <font color=Cyan>(</font>a<font color=Cyan>,</font>b<font color=Cyan>,</font>c<font color=Cyan>,</font>d<font color=Cyan>,</font>e<font color=Cyan>,</font>f<font color=Cyan>,</font>g<font color=Cyan>,</font>h<font color=Cyan>,</font>i<font color=Cyan>,</font>j<font color=Cyan>)</font> <font color=Red>=</font> <font color=Cyan>(</font>QTypeB a<font color=Cyan>,</font> QTypeB b<font color=Cyan>,</font> QTypeB c<font color=Cyan>,</font> QTypeB d<font color=Cyan>,</font> QTypeB e<font color=Cyan>,</font> QTypeB f<font color=Cyan>,</font> QTypeB g<font color=Cyan>,</font> QTypeB h<font color=Cyan>,</font> QTypeB i<font color=Cyan>,</font> QTypeB j<font color=Cyan>)</font>
<a name="line-174"></a><font color=Green><u>type</u></font> <font color=Green><u>instance</u></font> QTypeB <font color=Red>[</font>a<font color=Red>]</font> <font color=Red>=</font> <font color=Red>[</font>QTypeB a<font color=Red>]</font>
<a name="line-175"></a><font color=Green><u>type</u></font> <font color=Green><u>instance</u></font> QTypeB <font color=Cyan>(</font>B_Endpoint a b<font color=Cyan>)</font> <font color=Red>=</font> B_Endpoint <font color=Cyan>(</font>QTypeB a<font color=Cyan>)</font> <font color=Cyan>(</font>QTypeB b<font color=Cyan>)</font>
<a name="line-176"></a><font color=Green><u>type</u></font> <font color=Green><u>instance</u></font> QTypeB <font color=Cyan>(</font>Signed a<font color=Cyan>)</font> <font color=Red>=</font> Signed <font color=Cyan>(</font>QTypeB a<font color=Cyan>)</font>
<a name="line-177"></a>
<a name="line-178"></a><font color=Blue><i>-- ----------------------------------------------------------------------</i></font>
<a name="line-179"></a><font color=Blue><i>-- ** The QCData class</i></font>
<a name="line-180"></a>
<a name="line-181"></a><font color=Blue><i>-- $ The 'QCData' class provides only three primitive combinators:</i></font>
<a name="line-182"></a><font color=Blue><i>-- 'qcdata_mapM', 'qcdata_zip', and 'qcdata_promote'. These are</i></font>
<a name="line-183"></a><font color=Blue><i>-- sufficient to define all other shape-generic operations.</i></font>
<a name="line-184"></a><font color=Blue><i>-- </i></font>
<a name="line-185"></a><font color=Blue><i>-- An instance of this must be defined for each new kind of quantum data.</i></font>
<a name="line-186"></a><font color=Blue><i>-- </i></font>
<a name="line-187"></a><font color=Blue><i>-- The functions 'qcdata_mapM' and 'qcdata_zip' require \"shape type</i></font>
<a name="line-188"></a><font color=Blue><i>-- parameters\". These are dummy arguments whose /value/ is ignored,</i></font>
<a name="line-189"></a><font color=Blue><i>-- but whose /type/ is used to determine the shape of the data to map</i></font>
<a name="line-190"></a><font color=Blue><i>-- over. The dummy terms @'qubit' :: 'Qubit'@ and @'bit' :: 'Bit'@ may</i></font>
<a name="line-191"></a><font color=Blue><i>-- be used to represent leaves in shape type arguments.</i></font>
<a name="line-192"></a><font color=Blue><i>-- </i></font>
<a name="line-193"></a><font color=Blue><i>-- Note to programmers defining new 'QCData' instances: Instances</i></font>
<a name="line-194"></a><font color=Blue><i>-- /must/ ensure that the functions 'qcdata_mapM' and 'qcdata_zip'</i></font>
<a name="line-195"></a><font color=Blue><i>-- do not evaluate their dummy arguments. These arguments will often</i></font>
<a name="line-196"></a><font color=Blue><i>-- be 'undefined'. In particular, if using a pattern match on this</i></font>
<a name="line-197"></a><font color=Blue><i>-- argument, only a variable or a /lazy/ pattern can be used.</i></font>
<a name="line-198"></a>
<a name="line-199"></a><font color=Blue><i>-- | The 'QCData' type class contains heterogeneous data types built</i></font>
<a name="line-200"></a><font color=Blue><i>-- up from leaves of type 'Qubit' and 'Bit'. It is the basis for</i></font>
<a name="line-201"></a><font color=Blue><i>-- several generic operations that apply to classical and quantum</i></font>
<a name="line-202"></a><font color=Blue><i>-- data, such as copying, transformers, simulation, and heterogeneous</i></font>
<a name="line-203"></a><font color=Blue><i>-- versions of qterm and qdiscard.</i></font>
<a name="line-204"></a><font color=Blue><i>-- </i></font>
<a name="line-205"></a><font color=Blue><i>-- 'QCData' and 'QData' are interrelated, in the sense that the</i></font>
<a name="line-206"></a><font color=Blue><i>-- following implications hold:</i></font>
<a name="line-207"></a><font color=Blue><i>-- </i></font>
<a name="line-208"></a><font color=Blue><i>-- &gt; QData qa   implies   QCData qa</i></font>
<a name="line-209"></a><font color=Blue><i>-- &gt; CData ca   implies   QCData ca</i></font>
<a name="line-210"></a><font color=Blue><i>--  </i></font>
<a name="line-211"></a><font color=Blue><i>-- Implications in the converse direction also hold whenever /qc/ is a</i></font>
<a name="line-212"></a><font color=Blue><i>-- fixed known type:</i></font>
<a name="line-213"></a><font color=Blue><i>-- </i></font>
<a name="line-214"></a><font color=Blue><i>-- &gt; QCData qc   implies   QData (QType qc)</i></font>
<a name="line-215"></a><font color=Blue><i>-- &gt; QCData qc   implies   CData (CType qc)</i></font>
<a name="line-216"></a><font color=Blue><i>-- &gt; QCData qc   implies   BData (BType qc)</i></font>
<a name="line-217"></a><font color=Blue><i>-- </i></font>
<a name="line-218"></a><font color=Blue><i>-- However, the type checker cannot prove the above implication in the</i></font>
<a name="line-219"></a><font color=Blue><i>-- case where /qc/ is a type variable; for this, the more flexible</i></font>
<a name="line-220"></a><font color=Blue><i>-- (but more computationally expensive) 'QCDataPlus' class can be used.</i></font>
<a name="line-221"></a>
<a name="line-222"></a><a name="QCData"></a><font color=Green><u>class</u></font> <font color=Cyan>(</font>Labelable qc String<font color=Cyan>,</font> 
<a name="line-223"></a>       Typeable qc<font color=Cyan>,</font>
<a name="line-224"></a>       Show qc<font color=Cyan>,</font>
<a name="line-225"></a>       Show <font color=Cyan>(</font>LType qc<font color=Cyan>)</font><font color=Cyan>,</font>
<a name="line-226"></a>       qc <font color=Red>~</font> QCType Qubit Bit qc<font color=Cyan>,</font>
<a name="line-227"></a>       CType <font color=Cyan>(</font>QType qc<font color=Cyan>)</font> <font color=Red>~</font> CType qc<font color=Cyan>,</font>
<a name="line-228"></a>       BType <font color=Cyan>(</font>CType qc<font color=Cyan>)</font> <font color=Red>~</font> BType qc<font color=Cyan>,</font>
<a name="line-229"></a>       QCType Int Bool <font color=Cyan>(</font>CType qc<font color=Cyan>)</font> <font color=Red>~</font> BType qc
<a name="line-230"></a>      <font color=Cyan>)</font> <font color=Red>=&gt;</font> QCData qc <font color=Green><u>where</u></font>
<a name="line-231"></a>  <font color=Blue><i>-- | Map two functions /f/ and /g/ over all the leaves of a</i></font>
<a name="line-232"></a>  <font color=Blue><i>-- heterogeneous data structure. Apply /f/ to all the leaves at</i></font>
<a name="line-233"></a>  <font color=Blue><i>-- 'Qubit' positions, and 'g' to all the leaves at 'Bit' positions.</i></font>
<a name="line-234"></a>  <font color=Blue><i>-- The first argument is a shape type parameter.</i></font>
<a name="line-235"></a>  <font color=Blue><i>-- </i></font>
<a name="line-236"></a>  <font color=Blue><i>-- Example (ignoring the monad for the sake of simplicity):</i></font>
<a name="line-237"></a>  <font color=Blue><i>-- </i></font>
<a name="line-238"></a>  <font color=Blue><i>-- &gt; qcdata_mapM (qubit, bit, [qubit]) f g (x,y,[z,w]) = (f x, g y, [f z, f w]).</i></font>
<a name="line-239"></a>  <font color=Blue><i>-- </i></font>
<a name="line-240"></a>  <font color=Blue><i>-- For data types that have a sense of direction, the mapping should</i></font>
<a name="line-241"></a>  <font color=Blue><i>-- preferably be performed from left to right, but this property is</i></font>
<a name="line-242"></a>  <font color=Blue><i>-- not guaranteed and may change without notice. </i></font>
<a name="line-243"></a>  qcdata_mapM <font color=Red>::</font> <font color=Cyan>(</font>Monad m<font color=Cyan>)</font> <font color=Red>=&gt;</font> qc <font color=Red>-&gt;</font> <font color=Cyan>(</font>q <font color=Red>-&gt;</font> m q'<font color=Cyan>)</font> <font color=Red>-&gt;</font> <font color=Cyan>(</font>c <font color=Red>-&gt;</font> m c'<font color=Cyan>)</font> <font color=Red>-&gt;</font> QCType q c qc <font color=Red>-&gt;</font> m <font color=Cyan>(</font>QCType q' c' qc<font color=Cyan>)</font>
<a name="line-244"></a>  
<a name="line-245"></a>  <font color=Blue><i>-- | Zip two heterogeneous data structures together, to obtain a new</i></font>
<a name="line-246"></a>  <font color=Blue><i>-- data structure of the same shape, whose elements are pairs of the</i></font>
<a name="line-247"></a>  <font color=Blue><i>-- corresponding elements of the input data structures. The zipping</i></font>
<a name="line-248"></a>  <font color=Blue><i>-- is /strict/, meaning that both input data structure must have</i></font>
<a name="line-249"></a>  <font color=Blue><i>-- exactly the same shape (same length of lists, etc). The first</i></font>
<a name="line-250"></a>  <font color=Blue><i>-- five arguments are shape type parameters, representing the shape</i></font>
<a name="line-251"></a>  <font color=Blue><i>-- of the data structure, the two leaf types of the first data</i></font>
<a name="line-252"></a>  <font color=Blue><i>-- structure, and the two leaf types of the second data structure,</i></font>
<a name="line-253"></a>  <font color=Blue><i>-- respectively.</i></font>
<a name="line-254"></a>  <font color=Blue><i>-- </i></font>
<a name="line-255"></a>  <font color=Blue><i>-- Example:</i></font>
<a name="line-256"></a>  <font color=Blue><i>-- </i></font>
<a name="line-257"></a>  <font color=Blue><i>-- &gt; qcdata_zip (bit, [qubit]) int bool char string (True, [2,3]) ("b", ['c', 'd']) = ((True, "b"), [(2,'c'), (3,'d')])</i></font>
<a name="line-258"></a>  <font color=Blue><i>-- &gt; where the shape parameters are:</i></font>
<a name="line-259"></a>  <font color=Blue><i>-- &gt;   int = dummy :: Int</i></font>
<a name="line-260"></a>  <font color=Blue><i>-- &gt;   bool = dummy :: Bool</i></font>
<a name="line-261"></a>  <font color=Blue><i>-- &gt;   char = dummy :: Char</i></font>
<a name="line-262"></a>  <font color=Blue><i>-- &gt;   string = dummy :: String  </i></font>
<a name="line-263"></a>  <font color=Blue><i>-- </i></font>
<a name="line-264"></a>  <font color=Blue><i>-- The 'ErrMsg' argument is a stub error message to be used in</i></font>
<a name="line-265"></a>  <font color=Blue><i>-- case of failure.</i></font>
<a name="line-266"></a>  qcdata_zip <font color=Red>::</font> qc <font color=Red>-&gt;</font> q <font color=Red>-&gt;</font> c <font color=Red>-&gt;</font> q' <font color=Red>-&gt;</font> c' <font color=Red>-&gt;</font> QCType q c qc <font color=Red>-&gt;</font> QCType q' c' qc <font color=Red>-&gt;</font> ErrMsg <font color=Red>-&gt;</font> QCType <font color=Cyan>(</font>q<font color=Cyan>,</font> q'<font color=Cyan>)</font> <font color=Cyan>(</font>c<font color=Cyan>,</font> c'<font color=Cyan>)</font> qc
<a name="line-267"></a>  
<a name="line-268"></a>  <font color=Blue><i>-- | It is sometimes convenient to have a boolean parameter with</i></font>
<a name="line-269"></a>  <font color=Blue><i>-- some aspect of its shape indeterminate. The function</i></font>
<a name="line-270"></a>  <font color=Blue><i>-- 'qcdata_promote' takes such a boolean parameter, as well as a</i></font>
<a name="line-271"></a>  <font color=Blue><i>-- piece of 'QCData', and attempts to set the shape of the former to</i></font>
<a name="line-272"></a>  <font color=Blue><i>-- that of the latter.</i></font>
<a name="line-273"></a>  <font color=Blue><i>-- </i></font>
<a name="line-274"></a>  <font color=Blue><i>-- The kinds of promotions that are allowed depend on the data type.</i></font>
<a name="line-275"></a>  <font color=Blue><i>-- For example, for simple types, 'qcdata_promote' has no work to</i></font>
<a name="line-276"></a>  <font color=Blue><i>-- do and should just return the first argument. For types that are</i></font>
<a name="line-277"></a>  <font color=Blue><i>-- not simple, but where no promotion is desired (e.g. 'Qureg'),</i></font>
<a name="line-278"></a>  <font color=Blue><i>-- 'qcdata_promote' should check that the shapes of the first and</i></font>
<a name="line-279"></a>  <font color=Blue><i>-- second argument agree, and throw an error otherwise. For lists,</i></font>
<a name="line-280"></a>  <font color=Blue><i>-- we allow a longer list to be promoted to a shorter one, but not</i></font>
<a name="line-281"></a>  <font color=Blue><i>-- the other way around. For quantum integers, we allow an integer</i></font>
<a name="line-282"></a>  <font color=Blue><i>-- of indeterminate length to be promoted to a determinate length,</i></font>
<a name="line-283"></a>  <font color=Blue><i>-- but we do not allow a determinate length to be changed to another</i></font>
<a name="line-284"></a>  <font color=Blue><i>-- determinate length.</i></font>
<a name="line-285"></a>  <font color=Blue><i>-- </i></font>
<a name="line-286"></a>  <font color=Blue><i>-- The 'ErrMsg' argument is a stub error message to be used in</i></font>
<a name="line-287"></a>  <font color=Blue><i>-- case of failure.</i></font>
<a name="line-288"></a>  qcdata_promote <font color=Red>::</font> BType qc <font color=Red>-&gt;</font> qc <font color=Red>-&gt;</font> ErrMsg <font color=Red>-&gt;</font> BType qc
<a name="line-289"></a>
<a name="line-290"></a><a name="instance%20QCData%20Qubit"></a><font color=Green><u>instance</u></font> QCData Qubit <font color=Green><u>where</u></font>
<a name="line-291"></a>  qcdata_mapM shape f g <font color=Red>=</font> f
<a name="line-292"></a>  qcdata_zip shape q c q' c' x y e <font color=Red>=</font> <font color=Cyan>(</font>x<font color=Cyan>,</font> y<font color=Cyan>)</font>
<a name="line-293"></a>  qcdata_promote a x e <font color=Red>=</font> a
<a name="line-294"></a>
<a name="line-295"></a><a name="instance%20QCData%20Bit"></a><font color=Green><u>instance</u></font> QCData Bit <font color=Green><u>where</u></font>
<a name="line-296"></a>  qcdata_mapM shape f g <font color=Red>=</font> g
<a name="line-297"></a>  qcdata_zip shape q c q' c' x y e <font color=Red>=</font> <font color=Cyan>(</font>x<font color=Cyan>,</font> y<font color=Cyan>)</font>
<a name="line-298"></a>  qcdata_promote a x e <font color=Red>=</font> a
<a name="line-299"></a>
<a name="line-300"></a><a name="instance%20QCData%20()"></a><font color=Green><u>instance</u></font> QCData () <font color=Green><u>where</u></font>
<a name="line-301"></a>  qcdata_mapM shape f g x <font color=Red>=</font> return ()
<a name="line-302"></a>  qcdata_zip shape q c q' c' x y e <font color=Red>=</font> ()
<a name="line-303"></a>  qcdata_promote a x e <font color=Red>=</font> a
<a name="line-304"></a>  
<a name="line-305"></a><a name="instance%20QCData%20(a,b)"></a><font color=Green><u>instance</u></font> <font color=Cyan>(</font>QCData a<font color=Cyan>,</font> QCData b<font color=Cyan>)</font> <font color=Red>=&gt;</font> QCData <font color=Cyan>(</font>a<font color=Cyan>,</font>b<font color=Cyan>)</font> <font color=Green><u>where</u></font>
<a name="line-306"></a>  qcdata_mapM <font color=Red>~</font><font color=Cyan>(</font>a<font color=Cyan>,</font>b<font color=Cyan>)</font> f g <font color=Cyan>(</font>x<font color=Cyan>,</font>y<font color=Cyan>)</font> <font color=Red>=</font> <font color=Green><u>do</u></font>
<a name="line-307"></a>    x' <font color=Red>&lt;-</font> qcdata_mapM a f g x
<a name="line-308"></a>    y' <font color=Red>&lt;-</font> qcdata_mapM b f g y
<a name="line-309"></a>    return <font color=Cyan>(</font>x'<font color=Cyan>,</font> y'<font color=Cyan>)</font>
<a name="line-310"></a>  qcdata_zip <font color=Red>~</font><font color=Cyan>(</font>a<font color=Cyan>,</font>b<font color=Cyan>)</font> q c q' c' <font color=Cyan>(</font>x1<font color=Cyan>,</font> x2<font color=Cyan>)</font> <font color=Cyan>(</font>y1<font color=Cyan>,</font> y2<font color=Cyan>)</font> e <font color=Red>=</font> <font color=Cyan>(</font>z1<font color=Cyan>,</font> z2<font color=Cyan>)</font> <font color=Green><u>where</u></font>
<a name="line-311"></a>    z1 <font color=Red>=</font> qcdata_zip a q c q' c' x1 y1 e
<a name="line-312"></a>    z2 <font color=Red>=</font> qcdata_zip b q c q' c' x2 y2 e
<a name="line-313"></a>  qcdata_promote <font color=Cyan>(</font>a<font color=Cyan>,</font>b<font color=Cyan>)</font> <font color=Cyan>(</font>x<font color=Cyan>,</font>y<font color=Cyan>)</font> e <font color=Red>=</font> <font color=Cyan>(</font>qcdata_promote a x e<font color=Cyan>,</font> qcdata_promote b y e<font color=Cyan>)</font>
<a name="line-314"></a>
<a name="line-315"></a><a name="instance%20QCData%20(a,b,c)"></a><font color=Green><u>instance</u></font> <font color=Cyan>(</font>QCData a<font color=Cyan>,</font> QCData b<font color=Cyan>,</font> QCData c<font color=Cyan>)</font> <font color=Red>=&gt;</font> QCData <font color=Cyan>(</font>a<font color=Cyan>,</font>b<font color=Cyan>,</font>c<font color=Cyan>)</font> <font color=Green><u>where</u></font>
<a name="line-316"></a>  qcdata_mapM s f g xs <font color=Red>=</font> mmap tuple <font color=Cyan>$</font> qcdata_mapM <font color=Cyan>(</font>untuple s<font color=Cyan>)</font> f g <font color=Cyan>(</font>untuple xs<font color=Cyan>)</font>
<a name="line-317"></a>  qcdata_zip s q c q' c' xs ys e <font color=Red>=</font> tuple <font color=Cyan>$</font> qcdata_zip <font color=Cyan>(</font>untuple s<font color=Cyan>)</font> q c q' c' <font color=Cyan>(</font>untuple xs<font color=Cyan>)</font> <font color=Cyan>(</font>untuple ys<font color=Cyan>)</font> e
<a name="line-318"></a>  qcdata_promote a x s <font color=Red>=</font> tuple <font color=Cyan>$</font> qcdata_promote <font color=Cyan>(</font>untuple a<font color=Cyan>)</font> <font color=Cyan>(</font>untuple x<font color=Cyan>)</font> s
<a name="line-319"></a>  
<a name="line-320"></a><a name="instance%20QCData%20(a,b,c,d)"></a><font color=Green><u>instance</u></font> <font color=Cyan>(</font>QCData a<font color=Cyan>,</font> QCData b<font color=Cyan>,</font> QCData c<font color=Cyan>,</font> QCData d<font color=Cyan>)</font> <font color=Red>=&gt;</font> QCData <font color=Cyan>(</font>a<font color=Cyan>,</font>b<font color=Cyan>,</font>c<font color=Cyan>,</font>d<font color=Cyan>)</font> <font color=Green><u>where</u></font>
<a name="line-321"></a>  qcdata_mapM s f g xs <font color=Red>=</font> mmap tuple <font color=Cyan>$</font> qcdata_mapM <font color=Cyan>(</font>untuple s<font color=Cyan>)</font> f g <font color=Cyan>(</font>untuple xs<font color=Cyan>)</font>
<a name="line-322"></a>  qcdata_zip s q c q' c' xs ys e <font color=Red>=</font> tuple <font color=Cyan>$</font> qcdata_zip <font color=Cyan>(</font>untuple s<font color=Cyan>)</font> q c q' c' <font color=Cyan>(</font>untuple xs<font color=Cyan>)</font> <font color=Cyan>(</font>untuple ys<font color=Cyan>)</font> e
<a name="line-323"></a>  qcdata_promote a x s <font color=Red>=</font> tuple <font color=Cyan>$</font> qcdata_promote <font color=Cyan>(</font>untuple a<font color=Cyan>)</font> <font color=Cyan>(</font>untuple x<font color=Cyan>)</font> s
<a name="line-324"></a>  
<a name="line-325"></a><a name="instance%20QCData%20(a,b,c,d,e)"></a><font color=Green><u>instance</u></font> <font color=Cyan>(</font>QCData a<font color=Cyan>,</font> QCData b<font color=Cyan>,</font> QCData c<font color=Cyan>,</font> QCData d<font color=Cyan>,</font> QCData e<font color=Cyan>)</font> <font color=Red>=&gt;</font> QCData <font color=Cyan>(</font>a<font color=Cyan>,</font>b<font color=Cyan>,</font>c<font color=Cyan>,</font>d<font color=Cyan>,</font>e<font color=Cyan>)</font> <font color=Green><u>where</u></font>
<a name="line-326"></a>  qcdata_mapM s f g xs <font color=Red>=</font> mmap tuple <font color=Cyan>$</font> qcdata_mapM <font color=Cyan>(</font>untuple s<font color=Cyan>)</font> f g <font color=Cyan>(</font>untuple xs<font color=Cyan>)</font>
<a name="line-327"></a>  qcdata_zip s q c q' c' xs ys e <font color=Red>=</font> tuple <font color=Cyan>$</font> qcdata_zip <font color=Cyan>(</font>untuple s<font color=Cyan>)</font> q c q' c' <font color=Cyan>(</font>untuple xs<font color=Cyan>)</font> <font color=Cyan>(</font>untuple ys<font color=Cyan>)</font> e
<a name="line-328"></a>  qcdata_promote a x s <font color=Red>=</font> tuple <font color=Cyan>$</font> qcdata_promote <font color=Cyan>(</font>untuple a<font color=Cyan>)</font> <font color=Cyan>(</font>untuple x<font color=Cyan>)</font> s
<a name="line-329"></a>  
<a name="line-330"></a><a name="instance%20QCData%20(a,b,c,d,e,f)"></a><font color=Green><u>instance</u></font> <font color=Cyan>(</font>QCData a<font color=Cyan>,</font> QCData b<font color=Cyan>,</font> QCData c<font color=Cyan>,</font> QCData d<font color=Cyan>,</font> QCData e<font color=Cyan>,</font> QCData f<font color=Cyan>)</font> <font color=Red>=&gt;</font> QCData <font color=Cyan>(</font>a<font color=Cyan>,</font>b<font color=Cyan>,</font>c<font color=Cyan>,</font>d<font color=Cyan>,</font>e<font color=Cyan>,</font>f<font color=Cyan>)</font> <font color=Green><u>where</u></font>
<a name="line-331"></a>  qcdata_mapM s f g xs <font color=Red>=</font> mmap tuple <font color=Cyan>$</font> qcdata_mapM <font color=Cyan>(</font>untuple s<font color=Cyan>)</font> f g <font color=Cyan>(</font>untuple xs<font color=Cyan>)</font>
<a name="line-332"></a>  qcdata_zip s q c q' c' xs ys e <font color=Red>=</font> tuple <font color=Cyan>$</font> qcdata_zip <font color=Cyan>(</font>untuple s<font color=Cyan>)</font> q c q' c' <font color=Cyan>(</font>untuple xs<font color=Cyan>)</font> <font color=Cyan>(</font>untuple ys<font color=Cyan>)</font> e
<a name="line-333"></a>  qcdata_promote a x s <font color=Red>=</font> tuple <font color=Cyan>$</font> qcdata_promote <font color=Cyan>(</font>untuple a<font color=Cyan>)</font> <font color=Cyan>(</font>untuple x<font color=Cyan>)</font> s
<a name="line-334"></a>  
<a name="line-335"></a><a name="instance%20QCData%20(a,b,c,d,e,f,g)"></a><font color=Green><u>instance</u></font> <font color=Cyan>(</font>QCData a<font color=Cyan>,</font> QCData b<font color=Cyan>,</font> QCData c<font color=Cyan>,</font> QCData d<font color=Cyan>,</font> QCData e<font color=Cyan>,</font> QCData f<font color=Cyan>,</font> QCData g<font color=Cyan>)</font> <font color=Red>=&gt;</font> QCData <font color=Cyan>(</font>a<font color=Cyan>,</font>b<font color=Cyan>,</font>c<font color=Cyan>,</font>d<font color=Cyan>,</font>e<font color=Cyan>,</font>f<font color=Cyan>,</font>g<font color=Cyan>)</font> <font color=Green><u>where</u></font>
<a name="line-336"></a>  qcdata_mapM s f g xs <font color=Red>=</font> mmap tuple <font color=Cyan>$</font> qcdata_mapM <font color=Cyan>(</font>untuple s<font color=Cyan>)</font> f g <font color=Cyan>(</font>untuple xs<font color=Cyan>)</font>
<a name="line-337"></a>  qcdata_zip s q c q' c' xs ys e <font color=Red>=</font> tuple <font color=Cyan>$</font> qcdata_zip <font color=Cyan>(</font>untuple s<font color=Cyan>)</font> q c q' c' <font color=Cyan>(</font>untuple xs<font color=Cyan>)</font> <font color=Cyan>(</font>untuple ys<font color=Cyan>)</font> e
<a name="line-338"></a>  qcdata_promote a x s <font color=Red>=</font> tuple <font color=Cyan>$</font> qcdata_promote <font color=Cyan>(</font>untuple a<font color=Cyan>)</font> <font color=Cyan>(</font>untuple x<font color=Cyan>)</font> s
<a name="line-339"></a>  
<a name="line-340"></a><a name="instance%20QCData%20(a,b,c,d,e,f,g,h)"></a><font color=Green><u>instance</u></font> <font color=Cyan>(</font>QCData a<font color=Cyan>,</font> QCData b<font color=Cyan>,</font> QCData c<font color=Cyan>,</font> QCData d<font color=Cyan>,</font> QCData e<font color=Cyan>,</font> QCData f<font color=Cyan>,</font> QCData g<font color=Cyan>,</font> QCData h<font color=Cyan>)</font> <font color=Red>=&gt;</font> QCData <font color=Cyan>(</font>a<font color=Cyan>,</font>b<font color=Cyan>,</font>c<font color=Cyan>,</font>d<font color=Cyan>,</font>e<font color=Cyan>,</font>f<font color=Cyan>,</font>g<font color=Cyan>,</font>h<font color=Cyan>)</font> <font color=Green><u>where</u></font>
<a name="line-341"></a>  qcdata_mapM s f g xs <font color=Red>=</font> mmap tuple <font color=Cyan>$</font> qcdata_mapM <font color=Cyan>(</font>untuple s<font color=Cyan>)</font> f g <font color=Cyan>(</font>untuple xs<font color=Cyan>)</font>
<a name="line-342"></a>  qcdata_zip s q c q' c' xs ys e <font color=Red>=</font> tuple <font color=Cyan>$</font> qcdata_zip <font color=Cyan>(</font>untuple s<font color=Cyan>)</font> q c q' c' <font color=Cyan>(</font>untuple xs<font color=Cyan>)</font> <font color=Cyan>(</font>untuple ys<font color=Cyan>)</font> e
<a name="line-343"></a>  qcdata_promote a x s <font color=Red>=</font> tuple <font color=Cyan>$</font> qcdata_promote <font color=Cyan>(</font>untuple a<font color=Cyan>)</font> <font color=Cyan>(</font>untuple x<font color=Cyan>)</font> s
<a name="line-344"></a>  
<a name="line-345"></a><a name="instance%20QCData%20(a,b,c,d,e,f,g,h,i)"></a><font color=Green><u>instance</u></font> <font color=Cyan>(</font>QCData a<font color=Cyan>,</font> QCData b<font color=Cyan>,</font> QCData c<font color=Cyan>,</font> QCData d<font color=Cyan>,</font> QCData e<font color=Cyan>,</font> QCData f<font color=Cyan>,</font> QCData g<font color=Cyan>,</font> QCData h<font color=Cyan>,</font> QCData i<font color=Cyan>)</font> <font color=Red>=&gt;</font> QCData <font color=Cyan>(</font>a<font color=Cyan>,</font>b<font color=Cyan>,</font>c<font color=Cyan>,</font>d<font color=Cyan>,</font>e<font color=Cyan>,</font>f<font color=Cyan>,</font>g<font color=Cyan>,</font>h<font color=Cyan>,</font>i<font color=Cyan>)</font> <font color=Green><u>where</u></font>
<a name="line-346"></a>  qcdata_mapM s f g xs <font color=Red>=</font> mmap tuple <font color=Cyan>$</font> qcdata_mapM <font color=Cyan>(</font>untuple s<font color=Cyan>)</font> f g <font color=Cyan>(</font>untuple xs<font color=Cyan>)</font>
<a name="line-347"></a>  qcdata_zip s q c q' c' xs ys e <font color=Red>=</font> tuple <font color=Cyan>$</font> qcdata_zip <font color=Cyan>(</font>untuple s<font color=Cyan>)</font> q c q' c' <font color=Cyan>(</font>untuple xs<font color=Cyan>)</font> <font color=Cyan>(</font>untuple ys<font color=Cyan>)</font> e
<a name="line-348"></a>  qcdata_promote a x s <font color=Red>=</font> tuple <font color=Cyan>$</font> qcdata_promote <font color=Cyan>(</font>untuple a<font color=Cyan>)</font> <font color=Cyan>(</font>untuple x<font color=Cyan>)</font> s
<a name="line-349"></a>
<a name="line-350"></a><a name="instance%20QCData%20(a,b,c,d,e,f,g,h,i,j)"></a><font color=Green><u>instance</u></font> <font color=Cyan>(</font>QCData a<font color=Cyan>,</font> QCData b<font color=Cyan>,</font> QCData c<font color=Cyan>,</font> QCData d<font color=Cyan>,</font> QCData e<font color=Cyan>,</font> QCData f<font color=Cyan>,</font> QCData g<font color=Cyan>,</font> QCData h<font color=Cyan>,</font> QCData i<font color=Cyan>,</font> QCData j<font color=Cyan>)</font> <font color=Red>=&gt;</font> QCData <font color=Cyan>(</font>a<font color=Cyan>,</font>b<font color=Cyan>,</font>c<font color=Cyan>,</font>d<font color=Cyan>,</font>e<font color=Cyan>,</font>f<font color=Cyan>,</font>g<font color=Cyan>,</font>h<font color=Cyan>,</font>i<font color=Cyan>,</font>j<font color=Cyan>)</font> <font color=Green><u>where</u></font>
<a name="line-351"></a>  qcdata_mapM s f g xs <font color=Red>=</font> mmap tuple <font color=Cyan>$</font> qcdata_mapM <font color=Cyan>(</font>untuple s<font color=Cyan>)</font> f g <font color=Cyan>(</font>untuple xs<font color=Cyan>)</font>
<a name="line-352"></a>  qcdata_zip s q c q' c' xs ys e <font color=Red>=</font> tuple <font color=Cyan>$</font> qcdata_zip <font color=Cyan>(</font>untuple s<font color=Cyan>)</font> q c q' c' <font color=Cyan>(</font>untuple xs<font color=Cyan>)</font> <font color=Cyan>(</font>untuple ys<font color=Cyan>)</font> e
<a name="line-353"></a>  qcdata_promote a x s <font color=Red>=</font> tuple <font color=Cyan>$</font> qcdata_promote <font color=Cyan>(</font>untuple a<font color=Cyan>)</font> <font color=Cyan>(</font>untuple x<font color=Cyan>)</font> s
<a name="line-354"></a>
<a name="line-355"></a><a name="instance%20QCData%20%5ba%5d"></a><font color=Green><u>instance</u></font> <font color=Cyan>(</font>QCData a<font color=Cyan>)</font> <font color=Red>=&gt;</font> QCData <font color=Red>[</font>a<font color=Red>]</font> <font color=Green><u>where</u></font>
<a name="line-356"></a>  qcdata_mapM <font color=Red>~</font><font color=Red>[</font>a<font color=Red>]</font> f g xs <font color=Red>=</font> <font color=Green><u>do</u></font>
<a name="line-357"></a>    sequence <font color=Red>[</font> qcdata_mapM a f g x <font color=Red>|</font> x <font color=Red>&lt;-</font> xs<font color=Red>]</font>
<a name="line-358"></a>  qcdata_zip <font color=Red>~</font><font color=Red>[</font>a<font color=Red>]</font> q c q' c' xs ys e <font color=Red>=</font> zs <font color=Green><u>where</u></font>
<a name="line-359"></a>    zs <font color=Red>=</font> <font color=Red>[</font> qcdata_zip a q c q' c' x y e <font color=Red>|</font> <font color=Cyan>(</font>x<font color=Cyan>,</font> y<font color=Cyan>)</font> <font color=Red>&lt;-</font> zip_strict_errmsg xs ys errmsg<font color=Red>]</font>
<a name="line-360"></a>    errmsg <font color=Red>=</font> e <font color=Cyan>(</font><font color=Magenta>"lists differ in length: "</font> <font color=Cyan>++</font> show <font color=Cyan>(</font>length xs<font color=Cyan>)</font> <font color=Cyan>++</font> <font color=Magenta>" "</font> <font color=Cyan>++</font> show <font color=Cyan>(</font>length ys<font color=Cyan>)</font><font color=Cyan>)</font>
<a name="line-361"></a>  qcdata_promote <font color=Green><u>as</u></font> xs e <font color=Red>=</font> 
<a name="line-362"></a>    <font color=Red>[</font> qcdata_promote a x e <font color=Red>|</font> <font color=Cyan>(</font>a<font color=Cyan>,</font>x<font color=Cyan>)</font> <font color=Red>&lt;-</font> zip_rightstrict_errmsg <font color=Green><u>as</u></font> xs errmsg <font color=Red>]</font>
<a name="line-363"></a>    <font color=Green><u>where</u></font>
<a name="line-364"></a>      errmsg <font color=Red>=</font> e <font color=Magenta>"list too short"</font>
<a name="line-365"></a>
<a name="line-366"></a><a name="instance%20QCData%20(B_Endpoint%20a%20b)"></a><font color=Green><u>instance</u></font> <font color=Cyan>(</font>QCData a<font color=Cyan>,</font> QCData b<font color=Cyan>)</font> <font color=Red>=&gt;</font> QCData <font color=Cyan>(</font>B_Endpoint a b<font color=Cyan>)</font> <font color=Green><u>where</u></font>
<a name="line-367"></a>  qcdata_mapM <font color=Red>~</font><font color=Cyan>(</font>Endpoint_Qubit a<font color=Cyan>)</font> f g <font color=Cyan>(</font>Endpoint_Qubit x<font color=Cyan>)</font> <font color=Red>=</font> <font color=Green><u>do</u></font>
<a name="line-368"></a>    x' <font color=Red>&lt;-</font> qcdata_mapM a f g x
<a name="line-369"></a>    return <font color=Cyan>(</font>Endpoint_Qubit x'<font color=Cyan>)</font>
<a name="line-370"></a>  qcdata_mapM <font color=Red>~</font><font color=Cyan>(</font>Endpoint_Bit b<font color=Cyan>)</font> f g <font color=Cyan>(</font>Endpoint_Bit y<font color=Cyan>)</font> <font color=Red>=</font> <font color=Green><u>do</u></font>
<a name="line-371"></a>    y' <font color=Red>&lt;-</font> qcdata_mapM b f g y
<a name="line-372"></a>    return <font color=Cyan>(</font>Endpoint_Bit y'<font color=Cyan>)</font>
<a name="line-373"></a>  qcdata_zip <font color=Red>~</font><font color=Cyan>(</font>Endpoint_Qubit a<font color=Cyan>)</font> q c q' c' <font color=Cyan>(</font>Endpoint_Qubit x<font color=Cyan>)</font> <font color=Cyan>(</font>Endpoint_Qubit y<font color=Cyan>)</font> e <font color=Red>=</font> <font color=Cyan>(</font>Endpoint_Qubit z<font color=Cyan>)</font> <font color=Green><u>where</u></font>
<a name="line-374"></a>    z <font color=Red>=</font> qcdata_zip a q c q' c' x y e
<a name="line-375"></a>  qcdata_zip <font color=Red>~</font><font color=Cyan>(</font>Endpoint_Bit b<font color=Cyan>)</font> q c q' c' <font color=Cyan>(</font>Endpoint_Bit x<font color=Cyan>)</font> <font color=Cyan>(</font>Endpoint_Bit y<font color=Cyan>)</font> e <font color=Red>=</font> <font color=Cyan>(</font>Endpoint_Bit z<font color=Cyan>)</font> <font color=Green><u>where</u></font>
<a name="line-376"></a>    z <font color=Red>=</font> qcdata_zip b q c q' c' x y e
<a name="line-377"></a>  qcdata_zip shape q c q' c' x y e <font color=Red>=</font> error errmsg <font color=Green><u>where</u></font>
<a name="line-378"></a>    errmsg <font color=Red>=</font> e <font color=Magenta>"mismatching endpoint"</font>
<a name="line-379"></a>  qcdata_promote <font color=Red>~</font><font color=Cyan>(</font>Endpoint_Qubit a<font color=Cyan>)</font> <font color=Cyan>(</font>Endpoint_Qubit x<font color=Cyan>)</font> e <font color=Red>=</font> Endpoint_Qubit z <font color=Green><u>where</u></font>
<a name="line-380"></a>    z <font color=Red>=</font> qcdata_promote a x e
<a name="line-381"></a>  qcdata_promote <font color=Red>~</font><font color=Cyan>(</font>Endpoint_Bit b<font color=Cyan>)</font> <font color=Cyan>(</font>Endpoint_Bit y<font color=Cyan>)</font> e <font color=Red>=</font> Endpoint_Bit z <font color=Green><u>where</u></font>
<a name="line-382"></a>    z <font color=Red>=</font> qcdata_promote b y e
<a name="line-383"></a>
<a name="line-384"></a><a name="instance%20QCData%20(Signed%20a)"></a><font color=Green><u>instance</u></font> <font color=Cyan>(</font>QCData a<font color=Cyan>)</font> <font color=Red>=&gt;</font> QCData <font color=Cyan>(</font>Signed a<font color=Cyan>)</font> <font color=Green><u>where</u></font>
<a name="line-385"></a>  qcdata_mapM <font color=Red>~</font><font color=Cyan>(</font>Signed a <font color=Green><u>_</u></font><font color=Cyan>)</font> f g <font color=Red>~</font><font color=Cyan>(</font>Signed x b<font color=Cyan>)</font> <font color=Red>=</font> <font color=Green><u>do</u></font>
<a name="line-386"></a>    x' <font color=Red>&lt;-</font> qcdata_mapM a f g x
<a name="line-387"></a>    return <font color=Cyan>(</font>Signed x' b<font color=Cyan>)</font>
<a name="line-388"></a>  qcdata_zip <font color=Red>~</font><font color=Cyan>(</font>Signed a <font color=Green><u>_</u></font><font color=Cyan>)</font> q c q' c' <font color=Cyan>(</font>Signed x1 b1<font color=Cyan>)</font> <font color=Cyan>(</font>Signed x2 b2<font color=Cyan>)</font> e <font color=Red>=</font> <font color=Cyan>(</font>Signed z b<font color=Cyan>)</font> <font color=Green><u>where</u></font>
<a name="line-389"></a>    z <font color=Red>=</font> qcdata_zip a q c q' c' x1 x2 e
<a name="line-390"></a>    b <font color=Red>=</font> <font color=Green><u>if</u></font> b1 <font color=Cyan>==</font> b2 <font color=Green><u>then</u></font> b1 <font color=Green><u>else</u></font> error <font color=Cyan>(</font>e <font color=Magenta>"signs of controls do not match"</font><font color=Cyan>)</font>
<a name="line-391"></a>  qcdata_promote <font color=Red>~</font><font color=Cyan>(</font>Signed a <font color=Green><u>_</u></font><font color=Cyan>)</font> <font color=Cyan>(</font>Signed x b<font color=Cyan>)</font> e <font color=Red>=</font> <font color=Cyan>(</font>Signed x' b<font color=Cyan>)</font> <font color=Green><u>where</u></font>
<a name="line-392"></a>    x' <font color=Red>=</font> qcdata_promote a x e
<a name="line-393"></a>  
<a name="line-394"></a><font color=Blue><i>-- ----------------------------------------------------------------------</i></font>
<a name="line-395"></a><font color=Blue><i>-- Parameter types</i></font>
<a name="line-396"></a>    
<a name="line-397"></a><font color=Blue><i>-- Parameter types (such as Int) are also instances of QCData. </i></font>
<a name="line-398"></a><font color=Blue><i>-- These should be regarded as quantum types that are "all shape" and</i></font>
<a name="line-399"></a><font color=Blue><i>-- "no qubits".</i></font>
<a name="line-400"></a>  
<a name="line-401"></a><font color=Blue><i>-- Integers are parameters</i></font>
<a name="line-402"></a>
<a name="line-403"></a><font color=Green><u>type</u></font> <font color=Green><u>instance</u></font> QCType x y Integer <font color=Red>=</font> Integer 
<a name="line-404"></a>
<a name="line-405"></a><font color=Green><u>type</u></font> <font color=Green><u>instance</u></font> QTypeB Integer <font color=Red>=</font> Integer
<a name="line-406"></a>
<a name="line-407"></a><a name="instance%20QCData%20Integer"></a><font color=Green><u>instance</u></font> QCData Integer <font color=Green><u>where</u></font>
<a name="line-408"></a>  qcdata_mapM shape f g n <font color=Red>=</font> return n
<a name="line-409"></a>  qcdata_zip shape q c a' c' n m e 
<a name="line-410"></a>    <font color=Red>|</font> n <font color=Cyan>==</font> m <font color=Red>=</font> n 
<a name="line-411"></a>    <font color=Red>|</font> otherwise <font color=Red>=</font> error errmsg 
<a name="line-412"></a>    <font color=Green><u>where</u></font>
<a name="line-413"></a>      errmsg <font color=Red>=</font> e <font color=Magenta>"mismatching Integer parameter"</font>
<a name="line-414"></a>  qcdata_promote a x e
<a name="line-415"></a>    <font color=Red>|</font> a <font color=Cyan>==</font> x <font color=Red>=</font> a
<a name="line-416"></a>    <font color=Red>|</font> otherwise <font color=Red>=</font> error errmsg
<a name="line-417"></a>    <font color=Green><u>where</u></font>
<a name="line-418"></a>      errmsg <font color=Red>=</font> e <font color=Magenta>"mismatching Integer parameter"</font>
<a name="line-419"></a>
<a name="line-420"></a><font color=Blue><i>-- Ints are parameters</i></font>
<a name="line-421"></a>
<a name="line-422"></a><font color=Green><u>type</u></font> <font color=Green><u>instance</u></font> QCType x y Int <font color=Red>=</font> Int 
<a name="line-423"></a>
<a name="line-424"></a><font color=Green><u>type</u></font> <font color=Green><u>instance</u></font> QTypeB Int <font color=Red>=</font> Int
<a name="line-425"></a>
<a name="line-426"></a><a name="instance%20QCData%20Int"></a><font color=Green><u>instance</u></font> QCData Int <font color=Green><u>where</u></font>
<a name="line-427"></a>  qcdata_mapM shape f g n <font color=Red>=</font> return n
<a name="line-428"></a>  qcdata_zip shape q c a' c' n m e 
<a name="line-429"></a>    <font color=Red>|</font> n <font color=Cyan>==</font> m <font color=Red>=</font> n 
<a name="line-430"></a>    <font color=Red>|</font> otherwise <font color=Red>=</font> error errmsg 
<a name="line-431"></a>    <font color=Green><u>where</u></font>
<a name="line-432"></a>      errmsg <font color=Red>=</font> e <font color=Magenta>"mismatching Int parameter"</font>
<a name="line-433"></a>  qcdata_promote a x e
<a name="line-434"></a>    <font color=Red>|</font> a <font color=Cyan>==</font> x <font color=Red>=</font> a
<a name="line-435"></a>    <font color=Red>|</font> otherwise <font color=Red>=</font> error errmsg
<a name="line-436"></a>    <font color=Green><u>where</u></font>
<a name="line-437"></a>      errmsg <font color=Red>=</font> e <font color=Magenta>"mismatching Int parameter"</font>
<a name="line-438"></a>
<a name="line-439"></a><font color=Blue><i>-- Doubles are parameters</i></font>
<a name="line-440"></a>
<a name="line-441"></a><font color=Green><u>type</u></font> <font color=Green><u>instance</u></font> QCType x y Double <font color=Red>=</font> Double 
<a name="line-442"></a>
<a name="line-443"></a><font color=Green><u>type</u></font> <font color=Green><u>instance</u></font> QTypeB Double <font color=Red>=</font> Double
<a name="line-444"></a>
<a name="line-445"></a><a name="instance%20QCData%20Double"></a><font color=Green><u>instance</u></font> QCData Double <font color=Green><u>where</u></font>
<a name="line-446"></a>  qcdata_mapM shape f g n <font color=Red>=</font> return n
<a name="line-447"></a>  qcdata_zip shape q c a' c' n m e 
<a name="line-448"></a>    <font color=Red>|</font> n <font color=Cyan>==</font> m <font color=Red>=</font> n 
<a name="line-449"></a>    <font color=Red>|</font> otherwise <font color=Red>=</font> error errmsg 
<a name="line-450"></a>    <font color=Green><u>where</u></font>
<a name="line-451"></a>      errmsg <font color=Red>=</font> e <font color=Magenta>"mismatching Double parameter"</font>
<a name="line-452"></a>  qcdata_promote a x e
<a name="line-453"></a>    <font color=Red>|</font> a <font color=Cyan>==</font> x <font color=Red>=</font> a
<a name="line-454"></a>    <font color=Red>|</font> otherwise <font color=Red>=</font> error errmsg
<a name="line-455"></a>    <font color=Green><u>where</u></font>
<a name="line-456"></a>      errmsg <font color=Red>=</font> e <font color=Magenta>"mismatching Double parameter"</font>
<a name="line-457"></a>
<a name="line-458"></a><font color=Blue><i>-- Floats are parameters</i></font>
<a name="line-459"></a>
<a name="line-460"></a><font color=Green><u>type</u></font> <font color=Green><u>instance</u></font> QCType x y Float <font color=Red>=</font> Float 
<a name="line-461"></a>
<a name="line-462"></a><font color=Green><u>type</u></font> <font color=Green><u>instance</u></font> QTypeB Float <font color=Red>=</font> Float
<a name="line-463"></a>
<a name="line-464"></a><a name="instance%20QCData%20Float"></a><font color=Green><u>instance</u></font> QCData Float <font color=Green><u>where</u></font>
<a name="line-465"></a>  qcdata_mapM shape f g n <font color=Red>=</font> return n
<a name="line-466"></a>  qcdata_zip shape q c a' c' n m e 
<a name="line-467"></a>    <font color=Red>|</font> n <font color=Cyan>==</font> m <font color=Red>=</font> n 
<a name="line-468"></a>    <font color=Red>|</font> otherwise <font color=Red>=</font> error errmsg 
<a name="line-469"></a>    <font color=Green><u>where</u></font>
<a name="line-470"></a>      errmsg <font color=Red>=</font> e <font color=Magenta>"mismatching Float parameter"</font>
<a name="line-471"></a>  qcdata_promote a x e
<a name="line-472"></a>    <font color=Red>|</font> a <font color=Cyan>==</font> x <font color=Red>=</font> a
<a name="line-473"></a>    <font color=Red>|</font> otherwise <font color=Red>=</font> error errmsg
<a name="line-474"></a>    <font color=Green><u>where</u></font>
<a name="line-475"></a>      errmsg <font color=Red>=</font> e <font color=Magenta>"mismatching Float parameter"</font>
<a name="line-476"></a>
<a name="line-477"></a><font color=Blue><i>-- Chars are parameters</i></font>
<a name="line-478"></a>
<a name="line-479"></a><font color=Green><u>type</u></font> <font color=Green><u>instance</u></font> QCType x y Char <font color=Red>=</font> Char 
<a name="line-480"></a>
<a name="line-481"></a><font color=Green><u>type</u></font> <font color=Green><u>instance</u></font> QTypeB Char <font color=Red>=</font> Char
<a name="line-482"></a>
<a name="line-483"></a><a name="instance%20QCData%20Char"></a><font color=Green><u>instance</u></font> QCData Char <font color=Green><u>where</u></font>
<a name="line-484"></a>  qcdata_mapM shape f g n <font color=Red>=</font> return n
<a name="line-485"></a>  qcdata_zip shape q c a' c' n m e 
<a name="line-486"></a>    <font color=Red>|</font> n <font color=Cyan>==</font> m <font color=Red>=</font> n 
<a name="line-487"></a>    <font color=Red>|</font> otherwise <font color=Red>=</font> error errmsg 
<a name="line-488"></a>    <font color=Green><u>where</u></font>
<a name="line-489"></a>      errmsg <font color=Red>=</font> e <font color=Magenta>"mismatching Char parameter"</font>
<a name="line-490"></a>  qcdata_promote a x e
<a name="line-491"></a>    <font color=Red>|</font> a <font color=Cyan>==</font> x <font color=Red>=</font> a
<a name="line-492"></a>    <font color=Red>|</font> otherwise <font color=Red>=</font> error errmsg
<a name="line-493"></a>    <font color=Green><u>where</u></font>
<a name="line-494"></a>      errmsg <font color=Red>=</font> e <font color=Magenta>"mismatching Char parameter"</font>
<a name="line-495"></a>
<a name="line-496"></a>
<a name="line-497"></a><font color=Blue><i>-- ----------------------------------------------------------------------</i></font>
<a name="line-498"></a><font color=Blue><i>-- ** The SimpleType class</i></font>
<a name="line-499"></a>
<a name="line-500"></a><font color=Blue><i>-- | 'SimpleType' is a subclass of 'QCData' consisting of simple</i></font>
<a name="line-501"></a><font color=Blue><i>-- types. We say that a data type /t/ is \"simple\" if any two</i></font>
<a name="line-502"></a><font color=Blue><i>-- elements of /t/ have the same number of leaves. For example, tuples</i></font>
<a name="line-503"></a><font color=Blue><i>-- are simple, but lists are not.</i></font>
<a name="line-504"></a>
<a name="line-505"></a><a name="SimpleType"></a><font color=Green><u>class</u></font> QCData qc <font color=Red>=&gt;</font> SimpleType qc <font color=Green><u>where</u></font>
<a name="line-506"></a>  <font color=Blue><i>-- | Produce a term of the given shape. This term will contain</i></font>
<a name="line-507"></a>  <font color=Blue><i>-- well-defined data constructors, but may be 'undefined' at the</i></font>
<a name="line-508"></a>  <font color=Blue><i>-- leaves.</i></font>
<a name="line-509"></a>  fs_shape <font color=Red>::</font> qc
<a name="line-510"></a>  
<a name="line-511"></a><a name="instance%20SimpleType%20Qubit"></a><font color=Green><u>instance</u></font> SimpleType Qubit <font color=Green><u>where</u></font>
<a name="line-512"></a>  fs_shape <font color=Red>=</font> qubit
<a name="line-513"></a>  
<a name="line-514"></a><a name="instance%20SimpleType%20Bit"></a><font color=Green><u>instance</u></font> SimpleType Bit <font color=Green><u>where</u></font>
<a name="line-515"></a>  fs_shape <font color=Red>=</font> bit
<a name="line-516"></a>
<a name="line-517"></a><a name="instance%20SimpleType%20()"></a><font color=Green><u>instance</u></font> SimpleType () <font color=Green><u>where</u></font>
<a name="line-518"></a>  fs_shape <font color=Red>=</font> ()
<a name="line-519"></a>  
<a name="line-520"></a><a name="instance%20SimpleType%20(a,b)"></a><font color=Green><u>instance</u></font> <font color=Cyan>(</font>SimpleType a<font color=Cyan>,</font> SimpleType b<font color=Cyan>)</font> <font color=Red>=&gt;</font> SimpleType <font color=Cyan>(</font>a<font color=Cyan>,</font>b<font color=Cyan>)</font> <font color=Green><u>where</u></font>
<a name="line-521"></a>  fs_shape <font color=Red>=</font> <font color=Cyan>(</font>fs_shape<font color=Cyan>,</font> fs_shape<font color=Cyan>)</font>
<a name="line-522"></a>
<a name="line-523"></a><a name="instance%20SimpleType%20(a,b,c)"></a><font color=Green><u>instance</u></font> <font color=Cyan>(</font>SimpleType a<font color=Cyan>,</font> SimpleType b<font color=Cyan>,</font> SimpleType c<font color=Cyan>)</font> <font color=Red>=&gt;</font> SimpleType <font color=Cyan>(</font>a<font color=Cyan>,</font>b<font color=Cyan>,</font>c<font color=Cyan>)</font> <font color=Green><u>where</u></font>
<a name="line-524"></a>  fs_shape <font color=Red>=</font> tuple fs_shape
<a name="line-525"></a>
<a name="line-526"></a><a name="instance%20SimpleType%20(a,b,c,d)"></a><font color=Green><u>instance</u></font> <font color=Cyan>(</font>SimpleType a<font color=Cyan>,</font> SimpleType b<font color=Cyan>,</font> SimpleType c<font color=Cyan>,</font> SimpleType d<font color=Cyan>)</font> <font color=Red>=&gt;</font> SimpleType <font color=Cyan>(</font>a<font color=Cyan>,</font>b<font color=Cyan>,</font>c<font color=Cyan>,</font>d<font color=Cyan>)</font> <font color=Green><u>where</u></font>
<a name="line-527"></a>  fs_shape <font color=Red>=</font> tuple fs_shape
<a name="line-528"></a>
<a name="line-529"></a><a name="instance%20SimpleType%20(a,b,c,d,e)"></a><font color=Green><u>instance</u></font> <font color=Cyan>(</font>SimpleType a<font color=Cyan>,</font> SimpleType b<font color=Cyan>,</font> SimpleType c<font color=Cyan>,</font> SimpleType d<font color=Cyan>,</font> SimpleType e<font color=Cyan>)</font> <font color=Red>=&gt;</font> SimpleType <font color=Cyan>(</font>a<font color=Cyan>,</font>b<font color=Cyan>,</font>c<font color=Cyan>,</font>d<font color=Cyan>,</font>e<font color=Cyan>)</font> <font color=Green><u>where</u></font>
<a name="line-530"></a>  fs_shape <font color=Red>=</font> tuple fs_shape
<a name="line-531"></a>
<a name="line-532"></a><a name="instance%20SimpleType%20(a,b,c,d,e,f)"></a><font color=Green><u>instance</u></font> <font color=Cyan>(</font>SimpleType a<font color=Cyan>,</font> SimpleType b<font color=Cyan>,</font> SimpleType c<font color=Cyan>,</font> SimpleType d<font color=Cyan>,</font> SimpleType e<font color=Cyan>,</font> SimpleType f<font color=Cyan>)</font> <font color=Red>=&gt;</font> SimpleType <font color=Cyan>(</font>a<font color=Cyan>,</font>b<font color=Cyan>,</font>c<font color=Cyan>,</font>d<font color=Cyan>,</font>e<font color=Cyan>,</font>f<font color=Cyan>)</font> <font color=Green><u>where</u></font>
<a name="line-533"></a>  fs_shape <font color=Red>=</font> tuple fs_shape
<a name="line-534"></a>
<a name="line-535"></a><a name="instance%20SimpleType%20(a,b,c,d,e,f,g)"></a><font color=Green><u>instance</u></font> <font color=Cyan>(</font>SimpleType a<font color=Cyan>,</font> SimpleType b<font color=Cyan>,</font> SimpleType c<font color=Cyan>,</font> SimpleType d<font color=Cyan>,</font> SimpleType e<font color=Cyan>,</font> SimpleType f<font color=Cyan>,</font> SimpleType g<font color=Cyan>)</font> <font color=Red>=&gt;</font> SimpleType <font color=Cyan>(</font>a<font color=Cyan>,</font>b<font color=Cyan>,</font>c<font color=Cyan>,</font>d<font color=Cyan>,</font>e<font color=Cyan>,</font>f<font color=Cyan>,</font>g<font color=Cyan>)</font> <font color=Green><u>where</u></font>
<a name="line-536"></a>  fs_shape <font color=Red>=</font> tuple fs_shape
<a name="line-537"></a>
<a name="line-538"></a><a name="instance%20SimpleType%20(a,b,c,d,e,f,g,h)"></a><font color=Green><u>instance</u></font> <font color=Cyan>(</font>SimpleType a<font color=Cyan>,</font> SimpleType b<font color=Cyan>,</font> SimpleType c<font color=Cyan>,</font> SimpleType d<font color=Cyan>,</font> SimpleType e<font color=Cyan>,</font> SimpleType f<font color=Cyan>,</font> SimpleType g<font color=Cyan>,</font> SimpleType h<font color=Cyan>)</font> <font color=Red>=&gt;</font> SimpleType <font color=Cyan>(</font>a<font color=Cyan>,</font>b<font color=Cyan>,</font>c<font color=Cyan>,</font>d<font color=Cyan>,</font>e<font color=Cyan>,</font>f<font color=Cyan>,</font>g<font color=Cyan>,</font>h<font color=Cyan>)</font> <font color=Green><u>where</u></font>
<a name="line-539"></a>  fs_shape <font color=Red>=</font> tuple fs_shape
<a name="line-540"></a>
<a name="line-541"></a><a name="instance%20SimpleType%20(a,b,c,d,e,f,g,h,i)"></a><font color=Green><u>instance</u></font> <font color=Cyan>(</font>SimpleType a<font color=Cyan>,</font> SimpleType b<font color=Cyan>,</font> SimpleType c<font color=Cyan>,</font> SimpleType d<font color=Cyan>,</font> SimpleType e<font color=Cyan>,</font> SimpleType f<font color=Cyan>,</font> SimpleType g<font color=Cyan>,</font> SimpleType h<font color=Cyan>,</font> SimpleType i<font color=Cyan>)</font> <font color=Red>=&gt;</font> SimpleType <font color=Cyan>(</font>a<font color=Cyan>,</font>b<font color=Cyan>,</font>c<font color=Cyan>,</font>d<font color=Cyan>,</font>e<font color=Cyan>,</font>f<font color=Cyan>,</font>g<font color=Cyan>,</font>h<font color=Cyan>,</font>i<font color=Cyan>)</font> <font color=Green><u>where</u></font>
<a name="line-542"></a>  fs_shape <font color=Red>=</font> tuple fs_shape
<a name="line-543"></a>
<a name="line-544"></a><a name="instance%20SimpleType%20(a,b,c,d,e,f,g,h,i,j)"></a><font color=Green><u>instance</u></font> <font color=Cyan>(</font>SimpleType a<font color=Cyan>,</font> SimpleType b<font color=Cyan>,</font> SimpleType c<font color=Cyan>,</font> SimpleType d<font color=Cyan>,</font> SimpleType e<font color=Cyan>,</font> SimpleType f<font color=Cyan>,</font> SimpleType g<font color=Cyan>,</font> SimpleType h<font color=Cyan>,</font> SimpleType i<font color=Cyan>,</font> SimpleType j<font color=Cyan>)</font> <font color=Red>=&gt;</font> SimpleType <font color=Cyan>(</font>a<font color=Cyan>,</font>b<font color=Cyan>,</font>c<font color=Cyan>,</font>d<font color=Cyan>,</font>e<font color=Cyan>,</font>f<font color=Cyan>,</font>g<font color=Cyan>,</font>h<font color=Cyan>,</font>i<font color=Cyan>,</font>j<font color=Cyan>)</font> <font color=Green><u>where</u></font>
<a name="line-545"></a>  fs_shape <font color=Red>=</font> tuple fs_shape
<a name="line-546"></a>
<a name="line-547"></a><font color=Blue><i>-- ======================================================================</i></font>
<a name="line-548"></a><font color=Blue><i>-- * Type conversions</i></font>
<a name="line-549"></a>  
<a name="line-550"></a><font color=Blue><i>-- $ We define convenient abbreviations for conversions to, or</i></font>
<a name="line-551"></a><font color=Blue><i>-- between, homogeneous types.</i></font>
<a name="line-552"></a>
<a name="line-553"></a><a name="QType"></a><font color=Blue><i>-- | The type operator 'QType' converts a classical or heterogeneous</i></font>
<a name="line-554"></a><a name="QType"></a><font color=Blue><i>-- type to a homogeneous quantum type. More precisely, the type</i></font>
<a name="line-555"></a><a name="QType"></a><font color=Blue><i>-- 'QType' /a/ represents the substitution [nobr /a/ ['Qubit' \/ 'Bit']]. </i></font>
<a name="line-556"></a><a name="QType"></a><font color=Blue><i>-- It can be applied to both homogeneous and heterogeneous types, and</i></font>
<a name="line-557"></a><a name="QType"></a><font color=Blue><i>-- always yields a homogeneous type. For example:</i></font>
<a name="line-558"></a><a name="QType"></a><font color=Blue><i>-- </i></font>
<a name="line-559"></a><a name="QType"></a><font color=Blue><i>-- &gt; QType (Bit, [Bit]) = (Qubit, [Qubit])</i></font>
<a name="line-560"></a><a name="QType"></a><font color=Blue><i>-- &gt; QType (Qubit, Bit) = (Qubit, Qubit)</i></font>
<a name="line-561"></a><a name="QType"></a><font color=Green><u>type</u></font> QType a <font color=Red>=</font> QCType Qubit Qubit a
<a name="line-562"></a>
<a name="line-563"></a><a name="CType"></a><font color=Blue><i>-- | The type operator 'CType' converts a classical or heterogeneous</i></font>
<a name="line-564"></a><a name="CType"></a><font color=Blue><i>-- type to a homogeneous quantum type. More precisely, the type</i></font>
<a name="line-565"></a><a name="CType"></a><font color=Blue><i>-- 'CType' /a/ represents the substitution [nobr /a/ ['Bit' \/ 'Qubit']]. It</i></font>
<a name="line-566"></a><a name="CType"></a><font color=Blue><i>-- can be applied to both homogeneous and heterogeneous types, and</i></font>
<a name="line-567"></a><a name="CType"></a><font color=Blue><i>-- always yields a homogeneous type. For example:</i></font>
<a name="line-568"></a><a name="CType"></a><font color=Blue><i>-- </i></font>
<a name="line-569"></a><a name="CType"></a><font color=Blue><i>-- &gt; CType (Qubit, [Qubit]) = (Bit, [Bit])</i></font>
<a name="line-570"></a><a name="CType"></a><font color=Blue><i>-- &gt; CType (Qubit, Bit) = (Bit, Bit)</i></font>
<a name="line-571"></a><a name="CType"></a><font color=Green><u>type</u></font> CType a <font color=Red>=</font> QCType Bit Bit a
<a name="line-572"></a>
<a name="line-573"></a><a name="BType"></a><font color=Blue><i>-- | The type operator 'BType' converts a classical, quantum, or</i></font>
<a name="line-574"></a><a name="BType"></a><font color=Blue><i>-- heterogeneous type to a homogeneous boolean type. More precisely,</i></font>
<a name="line-575"></a><a name="BType"></a><font color=Blue><i>-- the type 'BType' /a/ represents the substitution</i></font>
<a name="line-576"></a><a name="BType"></a><font color=Blue><i>-- [nobr /a/ ['Bool' \/ 'Qubit', 'Bool' \/ 'Bit']]. It can be applied to</i></font>
<a name="line-577"></a><a name="BType"></a><font color=Blue><i>-- both homogeneous and heterogeneous types, and always yields a</i></font>
<a name="line-578"></a><a name="BType"></a><font color=Blue><i>-- homogeneous type. For example:</i></font>
<a name="line-579"></a><a name="BType"></a><font color=Blue><i>-- </i></font>
<a name="line-580"></a><a name="BType"></a><font color=Blue><i>-- &gt; BType (Qubit, [Qubit]) = (Bool, [Bool])</i></font>
<a name="line-581"></a><a name="BType"></a><font color=Blue><i>-- &gt; BType (Qubit, Bit) = (Bool, Bool)</i></font>
<a name="line-582"></a><a name="BType"></a><font color=Green><u>type</u></font> BType a <font color=Red>=</font> QCType Bool Bool a
<a name="line-583"></a>
<a name="line-584"></a><a name="HType"></a><font color=Blue><i>-- | The type operator 'HType' /x/ converts a classical, quantum, or</i></font>
<a name="line-585"></a><a name="HType"></a><font color=Blue><i>-- boolean type to a homogeneous type with leaves /x/. More precisely,</i></font>
<a name="line-586"></a><a name="HType"></a><font color=Blue><i>-- the type 'HType' /x/ /a/ represents the substitution</i></font>
<a name="line-587"></a><a name="HType"></a><font color=Blue><i>-- [nobr /a/ [/x/ \/ 'Qubit', /x/ \/ 'Bit']].</i></font>
<a name="line-588"></a><a name="HType"></a><font color=Blue><i>-- For example:</i></font>
<a name="line-589"></a><a name="HType"></a><font color=Blue><i>-- </i></font>
<a name="line-590"></a><a name="HType"></a><font color=Blue><i>-- &gt; HType x (Qubit, [Qubit]) = (x, [x])</i></font>
<a name="line-591"></a><a name="HType"></a><font color=Blue><i>-- &gt; HType x (Qubit, Bit) = (x, x)</i></font>
<a name="line-592"></a><a name="HType"></a><font color=Blue><i>-- </i></font>
<a name="line-593"></a><a name="HType"></a><font color=Blue><i>-- There is a very subtle difference between 'HType' /x/ /a/ and</i></font>
<a name="line-594"></a><a name="HType"></a><font color=Blue><i>-- 'QCType' /x/ /x/ /a/. Although these two types are equal for all</i></font>
<a name="line-595"></a><a name="HType"></a><font color=Blue><i>-- /x/ and /a/, the type checker cannot actually prove that 'QCType'</i></font>
<a name="line-596"></a><a name="HType"></a><font color=Blue><i>-- /x/ /x/ /a/ is homogeneous from the assumption 'QCData' /a/. It</i></font>
<a name="line-597"></a><a name="HType"></a><font color=Blue><i>-- can, however, prove that 'HType' /x/ /a/ is homogeneous. Therefore</i></font>
<a name="line-598"></a><a name="HType"></a><font color=Blue><i>-- 'HType' (or the slightly more efficient special cases 'QType',</i></font>
<a name="line-599"></a><a name="HType"></a><font color=Blue><i>-- 'CType', 'BType') should always be used to create a homogeneous</i></font>
<a name="line-600"></a><a name="HType"></a><font color=Blue><i>-- type from a heterogeneous one.</i></font>
<a name="line-601"></a><a name="HType"></a><font color=Green><u>type</u></font> HType leaf qa <font color=Red>=</font> QCType leaf leaf <font color=Cyan>(</font>QType qa<font color=Cyan>)</font>
<a name="line-602"></a>
<a name="line-603"></a><font color=Blue><i>-- | Construct the shape of a classical type.</i></font>
<a name="line-604"></a><font color=Blue><i>--type CShape ca = HShape Bit ca</i></font>
<a name="line-605"></a>
<a name="line-606"></a><font color=Blue><i>-- ======================================================================</i></font>
<a name="line-607"></a><font color=Blue><i>-- * Shape parameters</i></font>
<a name="line-608"></a>
<a name="line-609"></a><font color=Blue><i>-- $ Several operations, such as 'qcdata_mapM' and 'qcdata_zip',</i></font>
<a name="line-610"></a><font color=Blue><i>-- require a \"shape type parameter\". The purpose of such a parameter</i></font>
<a name="line-611"></a><font color=Blue><i>-- is only to fix a type; its value is completely unused. </i></font>
<a name="line-612"></a><font color=Blue><i>-- </i></font>
<a name="line-613"></a><font color=Blue><i>-- [Introduction to shape type parameters]</i></font>
<a name="line-614"></a><font color=Blue><i>-- </i></font>
<a name="line-615"></a><font color=Blue><i>-- $ The need for shape type parameters arises when dealing with a</i></font>
<a name="line-616"></a><font color=Blue><i>-- data structure whose leaves are of some arbitrary type, rather than</i></font>
<a name="line-617"></a><font color=Blue><i>-- 'Qubit', 'Bit', or 'Bool'. For example, consider the data structure</i></font>
<a name="line-618"></a><font color=Blue><i>-- </i></font>
<a name="line-619"></a><font color=Blue><i>-- &gt; [(1, 2), (3, 4)]</i></font>
<a name="line-620"></a><font color=Blue><i>-- </i></font>
<a name="line-621"></a><font color=Blue><i>-- This could be parsed in several different ways:</i></font>
<a name="line-622"></a><font color=Blue><i>-- </i></font>
<a name="line-623"></a><font color=Blue><i>-- * as a data structure [(/leaf/, /leaf/), (/leaf/, /leaf/)], where each leaf</i></font>
<a name="line-624"></a><font color=Blue><i>-- is an integer;</i></font>
<a name="line-625"></a><font color=Blue><i>--</i></font>
<a name="line-626"></a><font color=Blue><i>-- * as a data structure [/leaf/, /leaf/], where each leaf is a pair of</i></font>
<a name="line-627"></a><font color=Blue><i>-- integers;</i></font>
<a name="line-628"></a><font color=Blue><i>-- </i></font>
<a name="line-629"></a><font color=Blue><i>-- * as a data structure /leaf/, where each leaf is a list of pairs of</i></font>
<a name="line-630"></a><font color=Blue><i>-- integers.</i></font>
<a name="line-631"></a><font color=Blue><i>-- </i></font>
<a name="line-632"></a><font color=Blue><i>-- The purpose of a shape type is to disambiguate this situation. In</i></font>
<a name="line-633"></a><font color=Blue><i>-- shape types, the type 'Qubit' (and sometimes 'Bit', in the case of</i></font>
<a name="line-634"></a><font color=Blue><i>-- heterogeneous types) takes the place of a leaf. In the three</i></font>
<a name="line-635"></a><font color=Blue><i>-- situations of the above example, the shape type would be [('Qubit',</i></font>
<a name="line-636"></a><font color=Blue><i>-- 'Qubit')] in the first case; ['Qubit'] in the second case, the</i></font>
<a name="line-637"></a><font color=Blue><i>-- 'Qubit' in the third case.</i></font>
<a name="line-638"></a><font color=Blue><i>-- </i></font>
<a name="line-639"></a><font color=Blue><i>-- [Difference between shape type parameters and shape term parameters]</i></font>
<a name="line-640"></a><font color=Blue><i>-- </i></font>
<a name="line-641"></a><font color=Blue><i>-- A shape type parameter exists only to describe a type; its value is</i></font>
<a name="line-642"></a><font color=Blue><i>-- irrelevant and often undefined. A shape type parameter describes</i></font>
<a name="line-643"></a><font color=Blue><i>-- the location of leaves in a type. On the other hand, the purpose of</i></font>
<a name="line-644"></a><font color=Blue><i>-- a shape term parameter is used to fix the number and locations of</i></font>
<a name="line-645"></a><font color=Blue><i>-- leaves in a data structure (for example, to fix the length of a</i></font>
<a name="line-646"></a><font color=Blue><i>-- list). Shape term parameters are also often just called \"shape</i></font>
<a name="line-647"></a><font color=Blue><i>-- parameters\" in Quipper.</i></font>
<a name="line-648"></a><font color=Blue><i>--</i></font>
<a name="line-649"></a><font color=Blue><i>-- The distinction is perhaps best illustrated in an example.</i></font>
<a name="line-650"></a><font color=Blue><i>-- A typical shape type parameter is</i></font>
<a name="line-651"></a><font color=Blue><i>-- </i></font>
<a name="line-652"></a><font color=Blue><i>-- &gt; undefined :: (Qubit, [Qubit], [[Bit]])</i></font>
<a name="line-653"></a><font color=Blue><i>-- </i></font>
<a name="line-654"></a><font color=Blue><i>-- A typical shape term parameter is</i></font>
<a name="line-655"></a><font color=Blue><i>-- </i></font>
<a name="line-656"></a><font color=Blue><i>-- &gt; (qubit, [qubit, qubit, qubit], [[bit, bit], []]) :: (Qubit, [Qubit], [[Bit]])</i></font>
<a name="line-657"></a><font color=Blue><i>-- </i></font>
<a name="line-658"></a><font color=Blue><i>-- Both of them have the same type. The shape type parameter specifies</i></font>
<a name="line-659"></a><font color=Blue><i>-- that the data structure is a triple consisting of a qubit, a list</i></font>
<a name="line-660"></a><font color=Blue><i>-- of qubits, and a list of lists of bits.  The shape term parameter</i></font>
<a name="line-661"></a><font color=Blue><i>-- moreover specifies that the first list consists of exactly three</i></font>
<a name="line-662"></a><font color=Blue><i>-- qubits, and the second lists consists of a list of two bits and a</i></font>
<a name="line-663"></a><font color=Blue><i>-- list of zero bits.</i></font>
<a name="line-664"></a><font color=Blue><i>-- </i></font>
<a name="line-665"></a><font color=Blue><i>-- Note that the value of the shape type parameter is undefined (we</i></font>
<a name="line-666"></a><font color=Blue><i>-- often use the term 'dummy' instead of 'undefined', to get more</i></font>
<a name="line-667"></a><font color=Blue><i>-- meaningful error messages). On the other hand, the value of the</i></font>
<a name="line-668"></a><font color=Blue><i>-- shape term parameter is partially defined; only the /leaves/ are</i></font>
<a name="line-669"></a><font color=Blue><i>-- of undefined value.</i></font>
<a name="line-670"></a><font color=Blue><i>-- </i></font>
<a name="line-671"></a><font color=Blue><i>-- [Functions for specifying shape type parameters]</i></font>
<a name="line-672"></a><font color=Blue><i>-- </i></font>
<a name="line-673"></a><font color=Blue><i>-- Since it is not possible, in Haskell, to pass a type as an argument</i></font>
<a name="line-674"></a><font color=Blue><i>-- to a function, we provide some terms whose only purpose is to</i></font>
<a name="line-675"></a><font color=Blue><i>-- represent types. All of them have value 'undefined'.  Effectively,</i></font>
<a name="line-676"></a><font color=Blue><i>-- a shape type parameter is a type \"written as a term\".</i></font>
<a name="line-677"></a><font color=Blue><i>-- </i></font>
<a name="line-678"></a><font color=Blue><i>-- The following terms can also be combined in data structures to</i></font>
<a name="line-679"></a><font color=Blue><i>-- represent composite types. For example:</i></font>
<a name="line-680"></a><font color=Blue><i>-- </i></font>
<a name="line-681"></a><font color=Blue><i>-- &gt; (qubit, [bit]) :: (Qubit, [Bit])</i></font>
<a name="line-682"></a>
<a name="line-683"></a><a name="dummy"></a><font color=Blue><i>-- | A dummy term of any type. This term is 'undefined' and must never</i></font>
<a name="line-684"></a><font color=Blue><i>-- be evaluated. Its only purpose is to hold a type.</i></font>
<a name="line-685"></a><font color=Blue>dummy</font> <font color=Red>::</font> a
<a name="line-686"></a><font color=Blue>dummy</font> <font color=Red>=</font> error <font color=Magenta>"attempted evaluation of dummy term"</font>
<a name="line-687"></a>
<a name="line-688"></a><a name="qubit"></a><font color=Blue><i>-- | A dummy term of type 'Qubit'. It can be used in shape parameters</i></font>
<a name="line-689"></a><font color=Blue><i>-- (e.g., 'qc_init'), as well as shape type parameters (e.g.,</i></font>
<a name="line-690"></a><font color=Blue><i>-- 'qcdata_mapM').</i></font>
<a name="line-691"></a><font color=Blue>qubit</font> <font color=Red>::</font> Qubit
<a name="line-692"></a><font color=Blue>qubit</font> <font color=Red>=</font> dummy
<a name="line-693"></a>
<a name="line-694"></a><a name="bit"></a><font color=Blue><i>-- | A dummy term of type 'Bit'. It can be used in shape parameters</i></font>
<a name="line-695"></a><font color=Blue><i>-- (e.g., 'qc_init'), as well as shape type parameters (e.g.,</i></font>
<a name="line-696"></a><font color=Blue><i>-- 'qcdata_mapM').</i></font>
<a name="line-697"></a><font color=Blue>bit</font> <font color=Red>::</font> Bit
<a name="line-698"></a><font color=Blue>bit</font> <font color=Red>=</font> dummy
<a name="line-699"></a>
<a name="line-700"></a><a name="bool"></a><font color=Blue><i>-- | A dummy term of type 'Bool'.</i></font>
<a name="line-701"></a><font color=Blue>bool</font> <font color=Red>::</font> Bool
<a name="line-702"></a><font color=Blue>bool</font> <font color=Red>=</font> dummy
<a name="line-703"></a>
<a name="line-704"></a><a name="shapetype_q"></a><font color=Blue><i>-- | Convert a piece of homogeneous quantum data to a shape type</i></font>
<a name="line-705"></a><font color=Blue><i>-- parameter. This is guaranteed to never evaluate /x/, and returns an</i></font>
<a name="line-706"></a><font color=Blue><i>-- undefined value.</i></font>
<a name="line-707"></a><font color=Blue>shapetype_q</font> <font color=Red>::</font> <font color=Cyan>(</font>QData qa<font color=Cyan>)</font> <font color=Red>=&gt;</font> QType qa <font color=Red>-&gt;</font> qa
<a name="line-708"></a><font color=Blue>shapetype_q</font> x <font color=Red>=</font> dummy
<a name="line-709"></a>
<a name="line-710"></a><a name="shapetype_c"></a><font color=Blue><i>-- | Convert a piece of homogeneous classical data to a shape type</i></font>
<a name="line-711"></a><font color=Blue><i>-- parameter. This is guaranteed to never evaluate /x/, and returns an</i></font>
<a name="line-712"></a><font color=Blue><i>-- undefined value.</i></font>
<a name="line-713"></a><font color=Blue>shapetype_c</font> <font color=Red>::</font> <font color=Cyan>(</font>QData qa<font color=Cyan>)</font> <font color=Red>=&gt;</font> CType qa <font color=Red>-&gt;</font> qa
<a name="line-714"></a><font color=Blue>shapetype_c</font> x <font color=Red>=</font> dummy
<a name="line-715"></a>
<a name="line-716"></a><a name="shapetype_b"></a><font color=Blue><i>-- | Convert a piece of homogeneous boolean data to a shape type</i></font>
<a name="line-717"></a><font color=Blue><i>-- parameter. This is guaranteed to never evaluate /x/, and returns an</i></font>
<a name="line-718"></a><font color=Blue><i>-- undefined value. Do not confuse this with the function 'qshape',</i></font>
<a name="line-719"></a><font color=Blue><i>-- which creates a shape value.</i></font>
<a name="line-720"></a><font color=Blue>shapetype_b</font> <font color=Red>::</font> <font color=Cyan>(</font>QData qa<font color=Cyan>)</font> <font color=Red>=&gt;</font> BType qa <font color=Red>-&gt;</font> qa
<a name="line-721"></a><font color=Blue>shapetype_b</font> x <font color=Red>=</font> dummy
<a name="line-722"></a>
<a name="line-723"></a><a name="shape"></a><font color=Blue><i>-- | A dummy term of the same type as the given term. If /x/ :: /a/,</i></font>
<a name="line-724"></a><font color=Blue><i>-- then 'dummy' /x/ :: /a/. This is guaranteed not to evaluate /x/,</i></font>
<a name="line-725"></a><font color=Blue><i>-- and returns an undefined value.</i></font>
<a name="line-726"></a><font color=Blue>shape</font> <font color=Red>::</font> a <font color=Red>-&gt;</font> a
<a name="line-727"></a><font color=Blue>shape</font> x <font color=Red>=</font> dummy
<a name="line-728"></a>
<a name="line-729"></a><font color=Blue><i>-- ======================================================================</i></font>
<a name="line-730"></a><font color=Blue><i>-- * Homogeneous types</i></font>
<a name="line-731"></a>
<a name="line-732"></a><font color=Blue><i>-- ----------------------------------------------------------------------</i></font>
<a name="line-733"></a><font color=Blue><i>-- ** The QData class</i></font>
<a name="line-734"></a>
<a name="line-735"></a><font color=Blue><i>-- $ The 'QData' type class contains homogeneous data types built up</i></font>
<a name="line-736"></a><font color=Blue><i>-- from leaves of type 'Qubit'. It contains no methods; all of its</i></font>
<a name="line-737"></a><font color=Blue><i>-- functionality is derived from 'QCData'. It does, however, contain</i></font>
<a name="line-738"></a><font color=Blue><i>-- a number of equations that help the type checker figure out how to</i></font>
<a name="line-739"></a><font color=Blue><i>-- convert heterogeneous type to homogeneous ones and vice versa.</i></font>
<a name="line-740"></a>
<a name="line-741"></a><a name="QData"></a><font color=Blue><i>-- | The 'QData' type class contains homogeneous data types built up</i></font>
<a name="line-742"></a><a name="QData"></a><font color=Blue><i>-- from leaves of type 'Qubit'.</i></font>
<a name="line-743"></a><a name="QData"></a><font color=Green><u>class</u></font> <font color=Cyan>(</font>qa <font color=Red>~</font> QType <font color=Cyan>(</font>CType qa<font color=Cyan>)</font><font color=Cyan>,</font>
<a name="line-744"></a>       qa <font color=Red>~</font> QTypeB <font color=Cyan>(</font>BType qa<font color=Cyan>)</font><font color=Cyan>,</font> 
<a name="line-745"></a>       qa <font color=Red>~</font> QCType Qubit Bool qa<font color=Cyan>,</font>
<a name="line-746"></a>       qa <font color=Red>~</font> QType qa<font color=Cyan>,</font>
<a name="line-747"></a>       QCData qa<font color=Cyan>,</font>
<a name="line-748"></a>       QCData <font color=Cyan>(</font>CType qa<font color=Cyan>)</font>
<a name="line-749"></a>      <font color=Cyan>)</font> <font color=Red>=&gt;</font> QData qa
<a name="line-750"></a>  
<a name="line-751"></a><a name="instance%20QData%20qa"></a><font color=Green><u>instance</u></font> <font color=Cyan>(</font>qa <font color=Red>~</font> QType <font color=Cyan>(</font>CType qa<font color=Cyan>)</font><font color=Cyan>,</font>
<a name="line-752"></a>       qa <font color=Red>~</font> QTypeB <font color=Cyan>(</font>BType qa<font color=Cyan>)</font><font color=Cyan>,</font> 
<a name="line-753"></a>       qa <font color=Red>~</font> QCType Qubit Bool qa<font color=Cyan>,</font>
<a name="line-754"></a>       qa <font color=Red>~</font> QType qa<font color=Cyan>,</font>       
<a name="line-755"></a>       QCData qa<font color=Cyan>,</font>
<a name="line-756"></a>       QCData <font color=Cyan>(</font>CType qa<font color=Cyan>)</font>
<a name="line-757"></a>      <font color=Cyan>)</font> <font color=Red>=&gt;</font> QData qa
<a name="line-758"></a>
<a name="line-759"></a><font color=Blue><i>-- ----------------------------------------------------------------------</i></font>
<a name="line-760"></a><font color=Blue><i>-- ** Derived combinators on QData</i></font>
<a name="line-761"></a>
<a name="line-762"></a><font color=Blue><i>-- $ This section provides several convenient combinators for the</i></font>
<a name="line-763"></a><font color=Blue><i>-- 'QData' class. All of them are definable from those of</i></font>
<a name="line-764"></a><font color=Blue><i>-- 'QCData'.</i></font>
<a name="line-765"></a>
<a name="line-766"></a><a name="qdata_mapM"></a><font color=Blue><i>-- | Map a function /f/ over all the leaves of a data structure.  The</i></font>
<a name="line-767"></a><font color=Blue><i>-- first argument is a dummy shape parameter: its value is ignored, but</i></font>
<a name="line-768"></a><font color=Blue><i>-- its /type/ is used to determine the shape of the data to map over.</i></font>
<a name="line-769"></a><font color=Blue><i>-- </i></font>
<a name="line-770"></a><font color=Blue><i>-- Example (ignoring the monad for the sake of simplicity):</i></font>
<a name="line-771"></a><font color=Blue><i>-- </i></font>
<a name="line-772"></a><font color=Blue><i>-- &gt; qdata_mapM (leaf, [leaf]) f (x,[y,z,w]) = (f x, [f y, f z, f w]).</i></font>
<a name="line-773"></a><font color=Blue><i>-- </i></font>
<a name="line-774"></a><font color=Blue><i>-- For data types that have a sense of direction, the mapping should</i></font>
<a name="line-775"></a><font color=Blue><i>-- preferably be performed from left to right, but this property is</i></font>
<a name="line-776"></a><font color=Blue><i>-- not guaranteed and may change without notice.</i></font>
<a name="line-777"></a><font color=Blue>qdata_mapM</font> <font color=Red>::</font> <font color=Cyan>(</font>QData qa<font color=Cyan>,</font> Monad m<font color=Cyan>)</font> <font color=Red>=&gt;</font> qa <font color=Red>-&gt;</font> <font color=Cyan>(</font>x <font color=Red>-&gt;</font> m y<font color=Cyan>)</font> <font color=Red>-&gt;</font> HType x qa <font color=Red>-&gt;</font> m <font color=Cyan>(</font>HType y qa<font color=Cyan>)</font>
<a name="line-778"></a><font color=Blue>qdata_mapM</font> qa f xa <font color=Red>=</font> qcdata_mapM qa f f xa <font color=Green><u>where</u></font>
<a name="line-779"></a>
<a name="line-780"></a><a name="qdata_zip"></a><font color=Blue><i>-- | Zip two data structures with leaf types /x/ and /y/ together, to</i></font>
<a name="line-781"></a><font color=Blue><i>-- obtain a new data structure of the same shape with leaf type (/x/,</i></font>
<a name="line-782"></a><font color=Blue><i>-- /y/).  The first three arguments are dummy shape type parameters, representing</i></font>
<a name="line-783"></a><font color=Blue><i>-- the shape type and the two leaf types, respectively.</i></font>
<a name="line-784"></a><font color=Blue><i>-- </i></font>
<a name="line-785"></a><font color=Blue><i>-- The 'ErrMsg' argument is a stub error message to be used in case</i></font>
<a name="line-786"></a><font color=Blue><i>-- of failure.</i></font>
<a name="line-787"></a><font color=Blue>qdata_zip</font> <font color=Red>::</font> <font color=Cyan>(</font>QData qa<font color=Cyan>)</font> <font color=Red>=&gt;</font> qa <font color=Red>-&gt;</font> x <font color=Red>-&gt;</font> y <font color=Red>-&gt;</font> HType x qa <font color=Red>-&gt;</font> HType y qa <font color=Red>-&gt;</font> ErrMsg <font color=Red>-&gt;</font> HType <font color=Cyan>(</font>x<font color=Cyan>,</font> y<font color=Cyan>)</font> qa
<a name="line-788"></a><font color=Blue>qdata_zip</font> qa x y xs ys errmsg <font color=Red>=</font> qcdata_zip qa x x y y xs ys errmsg
<a name="line-789"></a>
<a name="line-790"></a><font color=Blue><i>-- | Sometimes, it is possible to have a boolean parameter with some</i></font>
<a name="line-791"></a><font color=Blue><i>-- aspect of its shape indeterminate. The function 'qdata_promote'</i></font>
<a name="line-792"></a><font color=Blue><i>-- takes such a boolean parameter, as well as a piece of quantum data,</i></font>
<a name="line-793"></a><font color=Blue><i>-- and sets the shape of the former to that of the latter.</i></font>
<a name="line-794"></a><font color=Blue><i>-- </i></font>
<a name="line-795"></a><font color=Blue><i>-- Indeterminate shapes can be used with certain operations, such as</i></font>
<a name="line-796"></a><font color=Blue><i>-- controlling and terminating, where some aspect of the shape of the</i></font>
<a name="line-797"></a><font color=Blue><i>-- parameter can be determined from the context in which it is</i></font>
<a name="line-798"></a><font color=Blue><i>-- used. This is useful, e.g., for quantum integers, where one may</i></font>
<a name="line-799"></a><font color=Blue><i>-- want to specify a control condition by an integer literal such as</i></font>
<a name="line-800"></a><font color=Blue><i>-- 17, without having to specify the number of bits. Thus, we can</i></font>
<a name="line-801"></a><font color=Blue><i>-- write, e.g.,</i></font>
<a name="line-802"></a><font color=Blue><i>-- </i></font>
<a name="line-803"></a><font color=Blue><i>-- &gt; gate `controlled` qi .==. 17</i></font>
<a name="line-804"></a><font color=Blue><i>-- </i></font>
<a name="line-805"></a><font color=Blue><i>-- instead of the more cumbersome</i></font>
<a name="line-806"></a><font color=Blue><i>-- </i></font>
<a name="line-807"></a><font color=Blue><i>-- &gt; gate `controlled` qi .==. (intm (qdint_length qi) 17).</i></font>
<a name="line-808"></a><font color=Blue><i>-- </i></font>
<a name="line-809"></a><font color=Blue><i>-- Another useful application of this arises in the use of infinite</i></font>
<a name="line-810"></a><font color=Blue><i>-- lists of booleans (such as @['False'..]@), to specify a control</i></font>
<a name="line-811"></a><font color=Blue><i>-- condition for a finite list of qubits.</i></font>
<a name="line-812"></a><font color=Blue><i>-- </i></font>
<a name="line-813"></a><font color=Blue><i>-- Because this function is used as a building block, we also pass</i></font>
<a name="line-814"></a><font color=Blue><i>-- an error message to be used in case of failure. This will</i></font>
<a name="line-815"></a><font color=Blue><i>-- hopefully make it clearer to the user which operation caused the</i></font>
<a name="line-816"></a><font color=Blue><i>-- error.</i></font>
<a name="line-817"></a>
<a name="line-818"></a><a name="qdata_promote"></a><font color=Blue>qdata_promote</font> <font color=Red>::</font> <font color=Cyan>(</font>QData qa<font color=Cyan>)</font> <font color=Red>=&gt;</font> BType qa <font color=Red>-&gt;</font> qa <font color=Red>-&gt;</font> ErrMsg <font color=Red>-&gt;</font> BType qa
<a name="line-819"></a><font color=Blue>qdata_promote</font> ba qa errmsg <font color=Red>=</font> qcdata_promote ba qa errmsg
<a name="line-820"></a>
<a name="line-821"></a><a name="qdata_unzip"></a><font color=Blue><i>-- | The inverse of 'qdata_zip': Take a data structure with leaf type</i></font>
<a name="line-822"></a><font color=Blue><i>-- (/x/, /y/), and return two data structures of the same shape with</i></font>
<a name="line-823"></a><font color=Blue><i>-- leaf types /x/ and /y/, respectively. The first three arguments are</i></font>
<a name="line-824"></a><font color=Blue><i>-- dummy shape type parameters, analogous to those of 'qdata_zip'.</i></font>
<a name="line-825"></a><font color=Blue>qdata_unzip</font> <font color=Red>::</font> <font color=Cyan>(</font>QData s<font color=Cyan>)</font> <font color=Red>=&gt;</font> s <font color=Red>-&gt;</font> x <font color=Red>-&gt;</font> y <font color=Red>-&gt;</font> HType <font color=Cyan>(</font>x<font color=Cyan>,</font> y<font color=Cyan>)</font> s <font color=Red>-&gt;</font> <font color=Cyan>(</font>HType x s<font color=Cyan>,</font> HType y s<font color=Cyan>)</font>
<a name="line-826"></a><font color=Blue>qdata_unzip</font> s <font color=Cyan>(</font>sx <font color=Red>::</font> x<font color=Cyan>)</font> <font color=Cyan>(</font>c <font color=Red>::</font> y<font color=Cyan>)</font> z <font color=Red>=</font> <font color=Cyan>(</font>x<font color=Cyan>,</font> y<font color=Cyan>)</font> <font color=Green><u>where</u></font>
<a name="line-827"></a>  x <font color=Red>=</font> qdata_map s <font color=Cyan>(</font>fst <font color=Red>::</font> <font color=Cyan>(</font>x<font color=Cyan>,</font> y<font color=Cyan>)</font> <font color=Red>-&gt;</font> x<font color=Cyan>)</font> z
<a name="line-828"></a>  y <font color=Red>=</font> qdata_map s <font color=Cyan>(</font>snd <font color=Red>::</font> <font color=Cyan>(</font>x<font color=Cyan>,</font> y<font color=Cyan>)</font> <font color=Red>-&gt;</font> y<font color=Cyan>)</font> z
<a name="line-829"></a>
<a name="line-830"></a><a name="qdata_map"></a><font color=Blue><i>-- | Map a function over every leaf in a data structure. Non-monadic</i></font>
<a name="line-831"></a><font color=Blue><i>-- version of 'qdata_mapM'.</i></font>
<a name="line-832"></a><font color=Blue>qdata_map</font> <font color=Red>::</font> <font color=Cyan>(</font>QData s<font color=Cyan>)</font> <font color=Red>=&gt;</font> s <font color=Red>-&gt;</font> <font color=Cyan>(</font>x <font color=Red>-&gt;</font> y<font color=Cyan>)</font> <font color=Red>-&gt;</font> HType x s <font color=Red>-&gt;</font> HType y s
<a name="line-833"></a><font color=Blue>qdata_map</font> shape f xs <font color=Red>=</font>
<a name="line-834"></a>  getId <font color=Cyan>$</font> qdata_mapM shape <font color=Cyan>(</font>return <font color=Cyan>.</font> f<font color=Cyan>)</font> xs
<a name="line-835"></a>  
<a name="line-836"></a><a name="qdata_fold"></a><font color=Blue><i>-- | Visit every leaf in a data structure, updating an accumulator.</i></font>
<a name="line-837"></a><font color=Blue>qdata_fold</font> <font color=Red>::</font> <font color=Cyan>(</font>QData s<font color=Cyan>)</font> <font color=Red>=&gt;</font> s <font color=Red>-&gt;</font> <font color=Cyan>(</font>x <font color=Red>-&gt;</font> w <font color=Red>-&gt;</font> w<font color=Cyan>)</font> <font color=Red>-&gt;</font> HType x s <font color=Red>-&gt;</font> w <font color=Red>-&gt;</font> w
<a name="line-838"></a><font color=Blue>qdata_fold</font> shape f xs w <font color=Red>=</font>
<a name="line-839"></a>  getId <font color=Cyan>$</font> qdata_foldM shape <font color=Cyan>(</font><font color=Red>\</font>x w <font color=Red>-&gt;</font> return <font color=Cyan>$</font> f x w<font color=Cyan>)</font> xs w
<a name="line-840"></a>
<a name="line-841"></a><a name="qdata_fold_map"></a><font color=Blue><i>-- | Map a function over every leaf in a data structure, while also</i></font>
<a name="line-842"></a><font color=Blue><i>-- updating an accumulator. This combines the functionality of</i></font>
<a name="line-843"></a><font color=Blue><i>-- 'qdata_fold' and 'qdata_map'.</i></font>
<a name="line-844"></a><font color=Blue>qdata_fold_map</font> <font color=Red>::</font> <font color=Cyan>(</font>QData s<font color=Cyan>)</font> <font color=Red>=&gt;</font> s <font color=Red>-&gt;</font> <font color=Cyan>(</font>x <font color=Red>-&gt;</font> w <font color=Red>-&gt;</font> <font color=Cyan>(</font>y<font color=Cyan>,</font> w<font color=Cyan>)</font><font color=Cyan>)</font> <font color=Red>-&gt;</font> HType x s <font color=Red>-&gt;</font> w <font color=Red>-&gt;</font> <font color=Cyan>(</font>HType y s<font color=Cyan>,</font> w<font color=Cyan>)</font>
<a name="line-845"></a><font color=Blue>qdata_fold_map</font> shape f xs w <font color=Red>=</font>
<a name="line-846"></a>  getId <font color=Cyan>$</font> qdata_fold_mapM shape <font color=Cyan>(</font><font color=Red>\</font>x w <font color=Red>-&gt;</font> return <font color=Cyan>$</font> f x w<font color=Cyan>)</font> xs w
<a name="line-847"></a>
<a name="line-848"></a><a name="qdata_foldM"></a><font color=Blue><i>-- | Monadic version of 'qdata_fold': Visit every leaf in a data</i></font>
<a name="line-849"></a><font color=Blue><i>-- structure, updating an accumulator.</i></font>
<a name="line-850"></a><font color=Blue>qdata_foldM</font> <font color=Red>::</font> <font color=Cyan>(</font>QData s<font color=Cyan>,</font> Monad m<font color=Cyan>)</font> <font color=Red>=&gt;</font> s <font color=Red>-&gt;</font> <font color=Cyan>(</font>x <font color=Red>-&gt;</font> w <font color=Red>-&gt;</font> m w<font color=Cyan>)</font> <font color=Red>-&gt;</font> HType x s <font color=Red>-&gt;</font> w <font color=Red>-&gt;</font> m w
<a name="line-851"></a><font color=Blue>qdata_foldM</font> shape f xs w <font color=Red>=</font> <font color=Green><u>do</u></font>
<a name="line-852"></a>  <font color=Cyan>(</font>ys<font color=Cyan>,</font> w<font color=Cyan>)</font> <font color=Red>&lt;-</font> qdata_fold_mapM shape f' xs w
<a name="line-853"></a>  return w
<a name="line-854"></a>    <font color=Green><u>where</u></font>
<a name="line-855"></a>      f' x w <font color=Red>=</font> <font color=Green><u>do</u></font>
<a name="line-856"></a>        w <font color=Red>&lt;-</font> f x w
<a name="line-857"></a>        return <font color=Cyan>(</font>()<font color=Cyan>,</font> w<font color=Cyan>)</font>
<a name="line-858"></a>
<a name="line-859"></a><a name="qdata_fold_mapM"></a><font color=Blue><i>-- | Monadic version of 'qdata_fold_map': Map a function over every</i></font>
<a name="line-860"></a><font color=Blue><i>-- leaf in a data structure, while also updating an accumulator. This</i></font>
<a name="line-861"></a><font color=Blue><i>-- combines the functionality of 'qdata_foldM' and 'qdata_mapM'.</i></font>
<a name="line-862"></a><font color=Blue>qdata_fold_mapM</font> <font color=Red>::</font> <font color=Cyan>(</font>QData s<font color=Cyan>,</font> Monad m<font color=Cyan>)</font> <font color=Red>=&gt;</font> s <font color=Red>-&gt;</font> <font color=Cyan>(</font>x <font color=Red>-&gt;</font> w <font color=Red>-&gt;</font> m <font color=Cyan>(</font>y<font color=Cyan>,</font> w<font color=Cyan>)</font><font color=Cyan>)</font> <font color=Red>-&gt;</font> HType x s <font color=Red>-&gt;</font> w <font color=Red>-&gt;</font> m <font color=Cyan>(</font>HType y s<font color=Cyan>,</font> w<font color=Cyan>)</font>
<a name="line-863"></a><font color=Blue>qdata_fold_mapM</font> shape f xs w <font color=Red>=</font> <font color=Green><u>do</u></font>
<a name="line-864"></a>  <font color=Cyan>(</font>ys<font color=Cyan>,</font> w<font color=Cyan>)</font> <font color=Red>&lt;-</font> runStateT computation w
<a name="line-865"></a>  return <font color=Cyan>(</font>ys<font color=Cyan>,</font> w<font color=Cyan>)</font>
<a name="line-866"></a>  <font color=Green><u>where</u></font>
<a name="line-867"></a>    <font color=Blue><i>-- m' = StateT w m</i></font>
<a name="line-868"></a>    computation <font color=Red>=</font> qdata_mapM shape map_leaf xs
<a name="line-869"></a>    map_leaf x <font color=Red>=</font> <font color=Green><u>do</u></font>
<a name="line-870"></a>              w <font color=Red>&lt;-</font> get
<a name="line-871"></a>              <font color=Cyan>(</font>y<font color=Cyan>,</font> w'<font color=Cyan>)</font> <font color=Red>&lt;-</font> lift <font color=Cyan>$</font> f x w
<a name="line-872"></a>              put w'
<a name="line-873"></a>              return y
<a name="line-874"></a>
<a name="line-875"></a><a name="qdata_sequentialize"></a><font color=Blue><i>-- | Return a list of leaves of the given homogeneous data structure.</i></font>
<a name="line-876"></a><font color=Blue><i>-- The first argument is a dummy shape type parameter, and is only used</i></font>
<a name="line-877"></a><font color=Blue><i>-- for its type.</i></font>
<a name="line-878"></a><font color=Blue><i>-- </i></font>
<a name="line-879"></a><font color=Blue><i>-- The leaves are ordered in some deterministic, but arbitrary way. It</i></font>
<a name="line-880"></a><font color=Blue><i>-- is guaranteed that when two data structures of the same shape type</i></font>
<a name="line-881"></a><font color=Blue><i>-- and shape (same length of lists etc) are sequentialized, the leaves</i></font>
<a name="line-882"></a><font color=Blue><i>-- will be ordered the same way. No other property of the order is</i></font>
<a name="line-883"></a><font color=Blue><i>-- guaranteed, In particular, it might change without notice. </i></font>
<a name="line-884"></a><font color=Blue>qdata_sequentialize</font> <font color=Red>::</font> <font color=Cyan>(</font>QData s<font color=Cyan>)</font> <font color=Red>=&gt;</font> s <font color=Red>-&gt;</font> HType x s <font color=Red>-&gt;</font> <font color=Red>[</font>x<font color=Red>]</font>
<a name="line-885"></a><font color=Blue>qdata_sequentialize</font> shape xs <font color=Red>=</font> xlist <font color=Green><u>where</u></font>
<a name="line-886"></a>  blist <font color=Red>=</font> qdata_fold shape do_leaf xs blist_empty
<a name="line-887"></a>  xlist <font color=Red>=</font> list_of_blist blist
<a name="line-888"></a>  
<a name="line-889"></a>  do_leaf <font color=Red>::</font> x <font color=Red>-&gt;</font> BList x <font color=Red>-&gt;</font> BList x
<a name="line-890"></a>  do_leaf x blist <font color=Red>=</font> blist <font color=Cyan>+++</font> blist_of_list <font color=Red>[</font>x<font color=Red>]</font>
<a name="line-891"></a>
<a name="line-892"></a><a name="qdata_unsequentialize"></a><font color=Blue><i>-- | Take a specimen homogeneous data structure to specify the \"shape\"</i></font>
<a name="line-893"></a><font color=Blue><i>-- desired (length of lists, etc); then reads the given list of leaves</i></font>
<a name="line-894"></a><font color=Blue><i>-- in as a piece of homogeneous data of the same shape. The ordering</i></font>
<a name="line-895"></a><font color=Blue><i>-- of the leaves is assumed to be the same as that which</i></font>
<a name="line-896"></a><font color=Blue><i>-- 'qdata_sequentialize' produces for the given shape.</i></font>
<a name="line-897"></a><font color=Blue><i>-- </i></font>
<a name="line-898"></a><font color=Blue><i>-- A \"length mismatch\" error occurs if the list does not have</i></font>
<a name="line-899"></a><font color=Blue><i>-- exactly the required length.</i></font>
<a name="line-900"></a><font color=Blue><i>--           </i></font>
<a name="line-901"></a><font color=Blue><i>-- Please note that, by contrast with the function</i></font>
<a name="line-902"></a><font color=Blue><i>-- 'qdata_sequentialize', the first argument is a shape term</i></font>
<a name="line-903"></a><font color=Blue><i>-- parameter, not a shape type parameter. It is used to decide where</i></font>
<a name="line-904"></a><font color=Blue><i>-- the qubits should go in the data structure.</i></font>
<a name="line-905"></a><font color=Blue>qdata_unsequentialize</font> <font color=Red>::</font> <font color=Cyan>(</font>QData s<font color=Cyan>)</font> <font color=Red>=&gt;</font> s <font color=Red>-&gt;</font> <font color=Red>[</font>x<font color=Red>]</font> <font color=Red>-&gt;</font> HType x s
<a name="line-906"></a><font color=Blue>qdata_unsequentialize</font> shape xlist <font color=Red>=</font> xs <font color=Green><u>where</u></font>
<a name="line-907"></a>  xs <font color=Red>=</font> <font color=Green><u>case</u></font> qdata_fold_map shape do_leaf shape xlist <font color=Green><u>of</u></font>
<a name="line-908"></a>    <font color=Cyan>(</font>xs<font color=Cyan>,</font> []<font color=Cyan>)</font> <font color=Red>-&gt;</font> xs
<a name="line-909"></a>    <font color=Cyan>(</font>xs<font color=Cyan>,</font> <font color=Green><u>_</u></font><font color=Cyan>)</font> <font color=Red>-&gt;</font> error <font color=Magenta>"qdata_unsequentialize: length mismatch"</font>
<a name="line-910"></a>    
<a name="line-911"></a>  <font color=Blue><i>-- first argument of do_leaf is dummy</i></font>
<a name="line-912"></a>  do_leaf <font color=Red>::</font> Qubit <font color=Red>-&gt;</font> <font color=Red>[</font>x<font color=Red>]</font> <font color=Red>-&gt;</font> <font color=Cyan>(</font>x<font color=Cyan>,</font> <font color=Red>[</font>x<font color=Red>]</font><font color=Cyan>)</font>
<a name="line-913"></a>  do_leaf x <font color=Cyan>(</font>h<font color=Red><b>:</b></font>t<font color=Cyan>)</font> <font color=Red>=</font> <font color=Cyan>(</font>h<font color=Cyan>,</font> t<font color=Cyan>)</font>
<a name="line-914"></a>  do_leaf x [] <font color=Red>=</font> error <font color=Magenta>"qdata_unsequentialize: length mismatch"</font>
<a name="line-915"></a>
<a name="line-916"></a><a name="qdata_makeshape"></a><font color=Blue><i>-- | Combine a shape type argument /q/, a leaf type argument /a/, and</i></font>
<a name="line-917"></a><font color=Blue><i>-- a shape size argument /x/ into a single shape argument /qx/. Note:</i></font>
<a name="line-918"></a><font color=Blue><i>-- </i></font>
<a name="line-919"></a><font color=Blue><i>-- * /q/ captures only the type, but not the size of the data. Only</i></font>
<a name="line-920"></a><font color=Blue><i>-- the type of /q/ is used; its value can be undefined. This is</i></font>
<a name="line-921"></a><font color=Blue><i>-- sufficient to determine the depth of leaves in a data structure,</i></font>
<a name="line-922"></a><font color=Blue><i>-- but not their number.</i></font>
<a name="line-923"></a><font color=Blue><i>-- </i></font>
<a name="line-924"></a><font color=Blue><i>-- * /x/ captures only the size of the data, but not its type. In</i></font>
<a name="line-925"></a><font color=Blue><i>-- particular, /x/ may have leaves of non-atomic types. /x/ must</i></font>
<a name="line-926"></a><font color=Blue><i>-- consist of well-defined constructors up to the depth of leaves of</i></font>
<a name="line-927"></a><font color=Blue><i>-- /q/, but the values at the actual leaves of /x/ may be undefined. </i></font>
<a name="line-928"></a><font color=Blue><i>-- </i></font>
<a name="line-929"></a><font color=Blue><i>-- * The output /qx/ combines the type of /q/ with the size of /x/,</i></font>
<a name="line-930"></a><font color=Blue><i>-- and can therefore be used both as a shape type and a shape value.</i></font>
<a name="line-931"></a><font color=Blue><i>-- Note that the actual leaves of /qx/ will be 'qubit' and 'bit',</i></font>
<a name="line-932"></a><font color=Blue><i>-- which are synonyms for 'undefined'. </i></font>
<a name="line-933"></a><font color=Blue><i>-- </i></font>
<a name="line-934"></a><font color=Blue><i>-- Example:</i></font>
<a name="line-935"></a><font color=Blue><i>-- </i></font>
<a name="line-936"></a><font color=Blue><i>-- &gt; q = undefined :: ([Qubit], [[Qubit]])</i></font>
<a name="line-937"></a><font color=Blue><i>-- &gt; x = ([undefined, 0], [[undefined], [0, 1]])</i></font>
<a name="line-938"></a><font color=Blue><i>-- &gt; qdata_makeshape qc a x = ([qubit, qubit], [[qubit], [qubit, qubit]])</i></font>
<a name="line-939"></a><font color=Blue><i>-- </i></font>
<a name="line-940"></a><font color=Blue><i>-- where /a/ :: @Int@.</i></font>
<a name="line-941"></a><font color=Blue>qdata_makeshape</font> <font color=Red>::</font> <font color=Cyan>(</font>QData qa<font color=Cyan>)</font> <font color=Red>=&gt;</font> qa <font color=Red>-&gt;</font> a <font color=Red>-&gt;</font> HType a qa <font color=Red>-&gt;</font> qa
<a name="line-942"></a><font color=Blue>qdata_makeshape</font> q <font color=Cyan>(</font>a<font color=Red>::</font>a<font color=Cyan>)</font> x <font color=Red>=</font> qdata_map q map_qubit x <font color=Green><u>where</u></font>
<a name="line-943"></a>  map_qubit <font color=Red>=</font> const qubit <font color=Red>::</font> a <font color=Red>-&gt;</font> Qubit
<a name="line-944"></a>
<a name="line-945"></a><a name="qdata_mapM_op"></a><font color=Blue><i>-- | Like 'qdata_mapM', except the leaves are visited in exactly the</i></font>
<a name="line-946"></a><font color=Blue><i>-- opposite order. This is used primarily for cosmetic reasons: For</i></font>
<a name="line-947"></a><font color=Blue><i>-- example, when initializing a bunch of ancillas, and then</i></font>
<a name="line-948"></a><font color=Blue><i>-- terminating them, the circuit will look more symmetric if they are</i></font>
<a name="line-949"></a><font color=Blue><i>-- terminated in the opposite order.</i></font>
<a name="line-950"></a><font color=Blue>qdata_mapM_op</font> <font color=Red>::</font> <font color=Cyan>(</font>QData s<font color=Cyan>,</font> Monad m<font color=Cyan>)</font> <font color=Red>=&gt;</font> s <font color=Red>-&gt;</font> <font color=Cyan>(</font>x <font color=Red>-&gt;</font> m y<font color=Cyan>)</font> <font color=Red>-&gt;</font> HType x s <font color=Red>-&gt;</font> m <font color=Cyan>(</font>HType y s<font color=Cyan>)</font>
<a name="line-951"></a><font color=Blue>qdata_mapM_op</font> shapetype <font color=Cyan>(</font>f <font color=Red>::</font> x <font color=Red>-&gt;</font> m y<font color=Cyan>)</font> xs <font color=Red>=</font> <font color=Green><u>do</u></font>
<a name="line-952"></a>  <font color=Green><u>let</u></font> shapeterm <font color=Red>=</font> qdata_makeshape shapetype <font color=Cyan>(</font>dummy <font color=Red>::</font> x<font color=Cyan>)</font> xs
<a name="line-953"></a>  <font color=Green><u>let</u></font> xlist <font color=Red>=</font> qdata_sequentialize shapeterm xs
<a name="line-954"></a>  ylist <font color=Red>&lt;-</font> sequence_right <font color=Red>[</font> f x <font color=Red>|</font> x <font color=Red>&lt;-</font> xlist <font color=Red>]</font>
<a name="line-955"></a>  <font color=Green><u>let</u></font> ys <font color=Red>=</font> qdata_unsequentialize shapeterm ylist
<a name="line-956"></a>  return ys
<a name="line-957"></a>
<a name="line-958"></a><a name="qdata_promote_c"></a><font color=Blue><i>-- | Like 'qdata_promote', except take a piece of classical data.</i></font>
<a name="line-959"></a><font color=Blue>qdata_promote_c</font> <font color=Red>::</font> <font color=Cyan>(</font>QData s<font color=Cyan>)</font> <font color=Red>=&gt;</font> BType s <font color=Red>-&gt;</font> CType s <font color=Red>-&gt;</font> ErrMsg <font color=Red>-&gt;</font> BType s
<a name="line-960"></a><font color=Blue>qdata_promote_c</font> b c s <font color=Red>=</font> qdata_promote b q s <font color=Green><u>where</u></font>
<a name="line-961"></a>  q <font color=Red>=</font> qdata_map <font color=Cyan>(</font>shapetype_c c<font color=Cyan>)</font> map_qubit c
<a name="line-962"></a>      
<a name="line-963"></a>  map_qubit <font color=Red>::</font> Bit <font color=Red>-&gt;</font> Qubit
<a name="line-964"></a>  map_qubit <font color=Red>=</font> const qubit
<a name="line-965"></a>
<a name="line-966"></a><font color=Blue><i>-- ----------------------------------------------------------------------</i></font>
<a name="line-967"></a><font color=Blue><i>-- ** The CData and BData classes</i></font>
<a name="line-968"></a>  
<a name="line-969"></a><a name="CData"></a><font color=Blue><i>-- | The 'CData' type class contains homogeneous data types built up</i></font>
<a name="line-970"></a><a name="CData"></a><font color=Blue><i>-- from leaves of type 'Bit'.</i></font>
<a name="line-971"></a><a name="CData"></a><font color=Green><u>class</u></font> <font color=Cyan>(</font>QData <font color=Cyan>(</font>QType ca<font color=Cyan>)</font><font color=Cyan>,</font> CType <font color=Cyan>(</font>QType ca<font color=Cyan>)</font> <font color=Red>~</font> ca<font color=Cyan>)</font> <font color=Red>=&gt;</font> CData ca
<a name="line-972"></a><a name="instance%20CData%20ca"></a><font color=Green><u>instance</u></font> <font color=Cyan>(</font>QData <font color=Cyan>(</font>QType ca<font color=Cyan>)</font><font color=Cyan>,</font> CType <font color=Cyan>(</font>QType ca<font color=Cyan>)</font> <font color=Red>~</font> ca<font color=Cyan>)</font> <font color=Red>=&gt;</font> CData ca
<a name="line-973"></a>
<a name="line-974"></a><a name="BData"></a><font color=Blue><i>-- | The 'BData' type class contains homogeneous data types built up</i></font>
<a name="line-975"></a><a name="BData"></a><font color=Blue><i>-- from leaves of type 'Bool'.</i></font>
<a name="line-976"></a><a name="BData"></a><font color=Green><u>class</u></font> <font color=Cyan>(</font>QData <font color=Cyan>(</font>QTypeB ba<font color=Cyan>)</font><font color=Cyan>,</font> BType <font color=Cyan>(</font>QTypeB ba<font color=Cyan>)</font> <font color=Red>~</font> ba<font color=Cyan>)</font> <font color=Red>=&gt;</font> BData ba
<a name="line-977"></a><a name="instance%20BData%20ba"></a><font color=Green><u>instance</u></font> <font color=Cyan>(</font>QData <font color=Cyan>(</font>QTypeB ba<font color=Cyan>)</font><font color=Cyan>,</font> BType <font color=Cyan>(</font>QTypeB ba<font color=Cyan>)</font> <font color=Red>~</font> ba<font color=Cyan>)</font> <font color=Red>=&gt;</font> BData ba
<a name="line-978"></a>
<a name="line-979"></a><font color=Blue><i>-- ----------------------------------------------------------------------</i></font>
<a name="line-980"></a><font color=Blue><i>-- ** The QShape class</i></font>
<a name="line-981"></a>              
<a name="line-982"></a><font color=Blue><i>-- $ By definition, 'QShape' /ba/ /qa/ /ca/ means that /ba/, /qa/, and</i></font>
<a name="line-983"></a><font color=Blue><i>-- /ca/ are, respectively, boolean, quantum, and classical homogeneous</i></font>
<a name="line-984"></a><font color=Blue><i>-- data types of the same common shape. The 'QShape' class directly</i></font>
<a name="line-985"></a><font color=Blue><i>-- defined in terms of the 'QData' class. In fact, the two classes are</i></font>
<a name="line-986"></a><font color=Blue><i>-- interchangeable in the following sense:</i></font>
<a name="line-987"></a><font color=Blue><i>-- </i></font>
<a name="line-988"></a><font color=Blue><i>-- &gt; QShape ba qa ca   implies   QData qa, </i></font>
<a name="line-989"></a><font color=Blue><i>-- </i></font>
<a name="line-990"></a><font color=Blue><i>-- and conversely,</i></font>
<a name="line-991"></a><font color=Blue><i>-- </i></font>
<a name="line-992"></a><font color=Blue><i>-- &gt; QData qa        implies   QShape (BType qa) qa (CType qa).</i></font>
<a name="line-993"></a><font color=Blue><i>-- </i></font>
<a name="line-994"></a><font color=Blue><i>-- Moreover, the functional dependencies @/ba/ -&gt; /qa/, /qa/ -&gt; /ca/,</i></font>
<a name="line-995"></a><font color=Blue><i>-- /ca/ -&gt; /ba/@ ensure that each of the three types determines the</i></font>
<a name="line-996"></a><font color=Blue><i>-- other two. Therefore, in many ways, 'QShape' is just a convenient</i></font>
<a name="line-997"></a><font color=Blue><i>-- notation for functionality already present in 'QData'.</i></font>
<a name="line-998"></a>  
<a name="line-999"></a><font color=Blue><i>-- | The 'QShape' class allows the definition of generic functions that</i></font>
<a name="line-1000"></a><font color=Blue><i>-- can operate on quantum data of any \"shape\", for example, nested</i></font>
<a name="line-1001"></a><font color=Blue><i>-- tuples or lists of qubits.</i></font>
<a name="line-1002"></a><font color=Blue><i>-- </i></font>
<a name="line-1003"></a><font color=Blue><i>-- In general, there are three kinds of data: quantum inputs (such as</i></font>
<a name="line-1004"></a><font color=Blue><i>-- 'Qubit'), classical inputs (such as 'Bit'), and classical</i></font>
<a name="line-1005"></a><font color=Blue><i>-- parameters (such as 'Bool'). For example, a 'Qubit' can be</i></font>
<a name="line-1006"></a><font color=Blue><i>-- initialized from a 'Bool'; a 'Qubit' can be measured, resulting in</i></font>
<a name="line-1007"></a><font color=Blue><i>-- a 'Bit', etc. For this reason, the type class 'QShape' establishes a</i></font>
<a name="line-1008"></a><font color=Blue><i>-- relation between three types:</i></font>
<a name="line-1009"></a><font color=Blue><i>--      </i></font>
<a name="line-1010"></a><font color=Blue><i>-- [@qa@] A data structure having 'Qubit' at the leaves.</i></font>
<a name="line-1011"></a><font color=Blue><i>-- </i></font>
<a name="line-1012"></a><font color=Blue><i>-- [@ca@] A data structure of the same shape as @qa@, having 'Bit' at</i></font>
<a name="line-1013"></a><font color=Blue><i>-- the leaves.</i></font>
<a name="line-1014"></a><font color=Blue><i>-- </i></font>
<a name="line-1015"></a><font color=Blue><i>-- [@ba@] A data structure of the same shape as @qa@, having 'Bool' at</i></font>
<a name="line-1016"></a><font color=Blue><i>-- the leaves.</i></font>
<a name="line-1017"></a><font color=Blue><i>-- </i></font>
<a name="line-1018"></a><font color=Blue><i>-- Some functions input a classical parameter for the sole purpose of</i></font>
<a name="line-1019"></a><font color=Blue><i>-- establishing the \"shape\" of a piece of data. The shape refers to</i></font>
<a name="line-1020"></a><font color=Blue><i>-- qualities of a data structure, such as the length of a list, which</i></font>
<a name="line-1021"></a><font color=Blue><i>-- are not uniquely determined by the type. For example, two different</i></font>
<a name="line-1022"></a><font color=Blue><i>-- lists of length 5 have the same shape. When performing a generic</i></font>
<a name="line-1023"></a><font color=Blue><i>-- operation, such as reversing a circuit, it is often necessary to</i></font>
<a name="line-1024"></a><font color=Blue><i>-- specify the shape of the inputs, but not the actual inputs.</i></font>
<a name="line-1025"></a><font color=Blue><i>-- </i></font>
<a name="line-1026"></a><font color=Blue><i>-- In the common case where one only needs to declare one of the types</i></font>
<a name="line-1027"></a><font color=Blue><i>-- /qa/, /ca/, or /ba/, one of the simpler type classes 'QData',</i></font>
<a name="line-1028"></a><font color=Blue><i>-- 'CData', or 'BData' can be used.</i></font>
<a name="line-1029"></a>
<a name="line-1030"></a><a name="QShape"></a><font color=Green><u>class</u></font> <font color=Cyan>(</font>QData qa<font color=Cyan>,</font> 
<a name="line-1031"></a>       CType qa <font color=Red>~</font> ca<font color=Cyan>,</font>
<a name="line-1032"></a>       BType qa <font color=Red>~</font> ba
<a name="line-1033"></a>      <font color=Cyan>)</font> <font color=Red>=&gt;</font> QShape ba qa ca <font color=Red>|</font> ba <font color=Red>-&gt;</font> qa<font color=Cyan>,</font> qa <font color=Red>-&gt;</font> ca<font color=Cyan>,</font> ca <font color=Red>-&gt;</font> ba
<a name="line-1034"></a>
<a name="line-1035"></a><a name="instance%20QShape%20ba%20qa%20ca"></a><font color=Green><u>instance</u></font> <font color=Cyan>(</font>QData qa<font color=Cyan>,</font> BType qa <font color=Red>~</font> ba<font color=Cyan>,</font> CType qa <font color=Red>~</font> ca<font color=Cyan>)</font> <font color=Red>=&gt;</font> QShape ba qa ca
<a name="line-1036"></a>
<a name="line-1037"></a><font color=Blue><i>-- ======================================================================</i></font>
<a name="line-1038"></a><font color=Blue><i>-- * Heterogeneous types</i></font>
<a name="line-1039"></a>           
<a name="line-1040"></a><font color=Blue><i>-- $ A heterogeneous type describes a data structure built up from</i></font>
<a name="line-1041"></a><font color=Blue><i>-- leaves of type 'Qubit' and 'Bit'. Such types are used, for example,</i></font>
<a name="line-1042"></a><font color=Blue><i>-- to represent sets of endpoints in circuits, parameters to</i></font>
<a name="line-1043"></a><font color=Blue><i>-- subroutines and circuit building functions. A typical example is:</i></font>
<a name="line-1044"></a><font color=Blue><i>-- </i></font>
<a name="line-1045"></a><font color=Blue><i>-- &gt; (Bit, Qubit, [Qubit]).</i></font>
<a name="line-1046"></a>
<a name="line-1047"></a><font color=Blue><i>-- ----------------------------------------------------------------------</i></font>
<a name="line-1048"></a><font color=Blue><i>-- ** Derived combinators on QCData</i></font>
<a name="line-1049"></a>
<a name="line-1050"></a><font color=Blue><i>-- $ The 'QCData' type class only contains the three primitive</i></font>
<a name="line-1051"></a><font color=Blue><i>-- combinators 'qcdata_mapM', 'qcdata_zip', and 'qcdata_promote'.</i></font>
<a name="line-1052"></a><font color=Blue><i>-- Many other useful combinators are definable in terms of these, and</i></font>
<a name="line-1053"></a><font color=Blue><i>-- we provide several of them here.</i></font>
<a name="line-1054"></a>
<a name="line-1055"></a><a name="qcdata_unzip"></a><font color=Blue><i>-- | The inverse of 'qcdata_zip': Take a data structure whose leaves</i></font>
<a name="line-1056"></a><font color=Blue><i>-- are pairs, and return two data structures of the same shape,</i></font>
<a name="line-1057"></a><font color=Blue><i>-- collecting all the left components and all the right components,</i></font>
<a name="line-1058"></a><font color=Blue><i>-- respectively. The first five arguments are shape type parameters,</i></font>
<a name="line-1059"></a><font color=Blue><i>-- analogous to those of 'qcdata_zip'.</i></font>
<a name="line-1060"></a><font color=Blue>qcdata_unzip</font> <font color=Red>::</font> <font color=Cyan>(</font>QCData qc<font color=Cyan>)</font> <font color=Red>=&gt;</font> qc <font color=Red>-&gt;</font> q <font color=Red>-&gt;</font> c <font color=Red>-&gt;</font> q' <font color=Red>-&gt;</font> c' <font color=Red>-&gt;</font> QCType <font color=Cyan>(</font>q<font color=Cyan>,</font> q'<font color=Cyan>)</font> <font color=Cyan>(</font>c<font color=Cyan>,</font> c'<font color=Cyan>)</font> qc <font color=Red>-&gt;</font> <font color=Cyan>(</font>QCType q c qc<font color=Cyan>,</font> QCType q' c' qc<font color=Cyan>)</font>
<a name="line-1061"></a><font color=Blue>qcdata_unzip</font> s <font color=Cyan>(</font>q <font color=Red>::</font> q<font color=Cyan>)</font> <font color=Cyan>(</font>c <font color=Red>::</font> c<font color=Cyan>)</font> <font color=Cyan>(</font>q' <font color=Red>::</font> q'<font color=Cyan>)</font> <font color=Cyan>(</font>c' <font color=Red>::</font> c'<font color=Cyan>)</font> z <font color=Red>=</font> <font color=Cyan>(</font>x<font color=Cyan>,</font> y<font color=Cyan>)</font> <font color=Green><u>where</u></font>
<a name="line-1062"></a>  x <font color=Red>=</font> qcdata_map s <font color=Cyan>(</font>fst <font color=Red>::</font> <font color=Cyan>(</font>q<font color=Cyan>,</font> q'<font color=Cyan>)</font> <font color=Red>-&gt;</font> q<font color=Cyan>)</font> <font color=Cyan>(</font>fst <font color=Red>::</font> <font color=Cyan>(</font>c<font color=Cyan>,</font> c'<font color=Cyan>)</font> <font color=Red>-&gt;</font> c<font color=Cyan>)</font> z
<a name="line-1063"></a>  y <font color=Red>=</font> qcdata_map s <font color=Cyan>(</font>snd <font color=Red>::</font> <font color=Cyan>(</font>q<font color=Cyan>,</font> q'<font color=Cyan>)</font> <font color=Red>-&gt;</font> q'<font color=Cyan>)</font> <font color=Cyan>(</font>snd <font color=Red>::</font> <font color=Cyan>(</font>c<font color=Cyan>,</font> c'<font color=Cyan>)</font> <font color=Red>-&gt;</font> c'<font color=Cyan>)</font> z
<a name="line-1064"></a>
<a name="line-1065"></a><a name="qcdata_map"></a><font color=Blue><i>-- | Map two functions /f/ and /g/ over the leaves of a heterogeneous</i></font>
<a name="line-1066"></a><font color=Blue><i>-- data structure. Apply /f/ to all the leaves at 'Qubit' positions,</i></font>
<a name="line-1067"></a><font color=Blue><i>-- and 'g' to all the leaves at 'Bit' positions. Non-monadic version</i></font>
<a name="line-1068"></a><font color=Blue><i>-- of 'qcdata_mapM'.</i></font>
<a name="line-1069"></a><font color=Blue>qcdata_map</font> <font color=Red>::</font> <font color=Cyan>(</font>QCData qc<font color=Cyan>)</font> <font color=Red>=&gt;</font> qc <font color=Red>-&gt;</font> <font color=Cyan>(</font>q <font color=Red>-&gt;</font> q'<font color=Cyan>)</font> <font color=Red>-&gt;</font> <font color=Cyan>(</font>c <font color=Red>-&gt;</font> c'<font color=Cyan>)</font> <font color=Red>-&gt;</font> QCType q c qc <font color=Red>-&gt;</font> QCType q' c' qc
<a name="line-1070"></a><font color=Blue>qcdata_map</font> shape f g xs <font color=Red>=</font>
<a name="line-1071"></a>  getId <font color=Cyan>$</font> qcdata_mapM shape <font color=Cyan>(</font>return <font color=Cyan>.</font> f<font color=Cyan>)</font> <font color=Cyan>(</font>return <font color=Cyan>.</font> g<font color=Cyan>)</font> xs
<a name="line-1072"></a>
<a name="line-1073"></a><a name="qcdata_fold"></a><font color=Blue><i>-- | Visit every leaf in a data structure, updating an</i></font>
<a name="line-1074"></a><font color=Blue><i>-- accumulator. This function requires two accumulator functions /f/</i></font>
<a name="line-1075"></a><font color=Blue><i>-- and /g/, to be used at 'Qubit' positions and 'Bit' positions,</i></font>
<a name="line-1076"></a><font color=Blue><i>-- respectively.</i></font>
<a name="line-1077"></a><font color=Blue>qcdata_fold</font> <font color=Red>::</font> <font color=Cyan>(</font>QCData qc<font color=Cyan>)</font> <font color=Red>=&gt;</font> qc <font color=Red>-&gt;</font> <font color=Cyan>(</font>q <font color=Red>-&gt;</font> w <font color=Red>-&gt;</font> w<font color=Cyan>)</font> <font color=Red>-&gt;</font> <font color=Cyan>(</font>c <font color=Red>-&gt;</font> w <font color=Red>-&gt;</font> w<font color=Cyan>)</font> <font color=Red>-&gt;</font> QCType q c qc <font color=Red>-&gt;</font> w <font color=Red>-&gt;</font> w
<a name="line-1078"></a><font color=Blue>qcdata_fold</font> shape f g xs w <font color=Red>=</font>
<a name="line-1079"></a>  getId <font color=Cyan>$</font> qcdata_foldM shape <font color=Cyan>(</font><font color=Red>\</font>x w <font color=Red>-&gt;</font> return <font color=Cyan>$</font> f x w<font color=Cyan>)</font> <font color=Cyan>(</font><font color=Red>\</font>y w <font color=Red>-&gt;</font> return <font color=Cyan>$</font> g y w<font color=Cyan>)</font> xs w
<a name="line-1080"></a>
<a name="line-1081"></a><a name="qcdata_fold_map"></a><font color=Blue><i>-- | Map a function over every leaf in a data structure, while also</i></font>
<a name="line-1082"></a><font color=Blue><i>-- updating an accumulator. This combines the functionality of</i></font>
<a name="line-1083"></a><font color=Blue><i>-- 'qcdata_fold' and 'qcdata_map'.</i></font>
<a name="line-1084"></a><font color=Blue>qcdata_fold_map</font> <font color=Red>::</font> <font color=Cyan>(</font>QCData qc<font color=Cyan>)</font> <font color=Red>=&gt;</font> qc <font color=Red>-&gt;</font> <font color=Cyan>(</font>q <font color=Red>-&gt;</font> w <font color=Red>-&gt;</font> <font color=Cyan>(</font>q'<font color=Cyan>,</font> w<font color=Cyan>)</font><font color=Cyan>)</font> <font color=Red>-&gt;</font> <font color=Cyan>(</font>c <font color=Red>-&gt;</font> w <font color=Red>-&gt;</font> <font color=Cyan>(</font>c'<font color=Cyan>,</font> w<font color=Cyan>)</font><font color=Cyan>)</font> <font color=Red>-&gt;</font> QCType q c qc <font color=Red>-&gt;</font> w <font color=Red>-&gt;</font> <font color=Cyan>(</font>QCType q' c' qc<font color=Cyan>,</font> w<font color=Cyan>)</font>
<a name="line-1085"></a><font color=Blue>qcdata_fold_map</font> shape f g xs w <font color=Red>=</font>
<a name="line-1086"></a>  getId <font color=Cyan>$</font> qcdata_fold_mapM shape <font color=Cyan>(</font><font color=Red>\</font>x w <font color=Red>-&gt;</font> return <font color=Cyan>$</font> f x w<font color=Cyan>)</font> <font color=Cyan>(</font><font color=Red>\</font>x w <font color=Red>-&gt;</font> return <font color=Cyan>$</font> g x w<font color=Cyan>)</font> xs w
<a name="line-1087"></a>  
<a name="line-1088"></a><a name="qcdata_foldM"></a><font color=Blue><i>-- | Monadic version of 'qcdata_fold': Visit every leaf in a data</i></font>
<a name="line-1089"></a><font color=Blue><i>-- structure, updating an accumulator. This function requires two</i></font>
<a name="line-1090"></a><font color=Blue><i>-- accumulator functions /f/ and /g/, to be used at 'Qubit' positions</i></font>
<a name="line-1091"></a><font color=Blue><i>-- and 'Bit' positions, respectively.</i></font>
<a name="line-1092"></a><font color=Blue>qcdata_foldM</font> <font color=Red>::</font> <font color=Cyan>(</font>QCData qc<font color=Cyan>,</font> Monad m<font color=Cyan>)</font> <font color=Red>=&gt;</font> qc <font color=Red>-&gt;</font> <font color=Cyan>(</font>q <font color=Red>-&gt;</font> w <font color=Red>-&gt;</font> m w<font color=Cyan>)</font> <font color=Red>-&gt;</font> <font color=Cyan>(</font>c <font color=Red>-&gt;</font> w <font color=Red>-&gt;</font> m w<font color=Cyan>)</font> <font color=Red>-&gt;</font> QCType q c qc <font color=Red>-&gt;</font> w <font color=Red>-&gt;</font> m w
<a name="line-1093"></a><font color=Blue>qcdata_foldM</font> shape f g xs w <font color=Red>=</font> <font color=Green><u>do</u></font>
<a name="line-1094"></a>  <font color=Cyan>(</font>ys<font color=Cyan>,</font> w<font color=Cyan>)</font> <font color=Red>&lt;-</font> qcdata_fold_mapM shape <font color=Cyan>(</font>map_leaf f<font color=Cyan>)</font> <font color=Cyan>(</font>map_leaf g<font color=Cyan>)</font> xs w
<a name="line-1095"></a>  return w
<a name="line-1096"></a>  <font color=Green><u>where</u></font>
<a name="line-1097"></a>    map_leaf <font color=Red>::</font> <font color=Cyan>(</font>Monad m<font color=Cyan>)</font> <font color=Red>=&gt;</font> <font color=Cyan>(</font>x <font color=Red>-&gt;</font> w <font color=Red>-&gt;</font> m w<font color=Cyan>)</font> <font color=Red>-&gt;</font> <font color=Cyan>(</font>x <font color=Red>-&gt;</font> w <font color=Red>-&gt;</font> m <font color=Cyan>(</font>()<font color=Cyan>,</font> w<font color=Cyan>)</font><font color=Cyan>)</font>
<a name="line-1098"></a>    map_leaf f x w <font color=Red>=</font> <font color=Green><u>do</u></font>
<a name="line-1099"></a>              w <font color=Red>&lt;-</font> f x w
<a name="line-1100"></a>              return <font color=Cyan>(</font>()<font color=Cyan>,</font> w<font color=Cyan>)</font>
<a name="line-1101"></a>
<a name="line-1102"></a><a name="qcdata_fold_mapM"></a><font color=Blue><i>-- | Monadic version of 'qcdata_fold_map': Map a function over every</i></font>
<a name="line-1103"></a><font color=Blue><i>-- leaf in a data structure, while also updating an accumulator. This</i></font>
<a name="line-1104"></a><font color=Blue><i>-- combines the functionality of 'qcdata_foldM' and 'qcdata_mapM'.</i></font>
<a name="line-1105"></a><font color=Blue>qcdata_fold_mapM</font> <font color=Red>::</font> <font color=Cyan>(</font>QCData qc<font color=Cyan>,</font> Monad m<font color=Cyan>)</font> <font color=Red>=&gt;</font> qc <font color=Red>-&gt;</font> <font color=Cyan>(</font>q <font color=Red>-&gt;</font> w <font color=Red>-&gt;</font> m <font color=Cyan>(</font>q'<font color=Cyan>,</font> w<font color=Cyan>)</font><font color=Cyan>)</font> <font color=Red>-&gt;</font> <font color=Cyan>(</font>c <font color=Red>-&gt;</font> w <font color=Red>-&gt;</font> m <font color=Cyan>(</font>c'<font color=Cyan>,</font> w<font color=Cyan>)</font><font color=Cyan>)</font> <font color=Red>-&gt;</font> QCType q c qc <font color=Red>-&gt;</font> w <font color=Red>-&gt;</font> m <font color=Cyan>(</font>QCType q' c' qc<font color=Cyan>,</font> w<font color=Cyan>)</font>
<a name="line-1106"></a><font color=Blue>qcdata_fold_mapM</font> shape f g xs w <font color=Red>=</font> <font color=Green><u>do</u></font>
<a name="line-1107"></a>  <font color=Cyan>(</font>ys<font color=Cyan>,</font> w<font color=Cyan>)</font> <font color=Red>&lt;-</font> runStateT computation w
<a name="line-1108"></a>  return <font color=Cyan>(</font>ys<font color=Cyan>,</font> w<font color=Cyan>)</font>
<a name="line-1109"></a>  <font color=Green><u>where</u></font>
<a name="line-1110"></a>    <font color=Blue><i>-- m' = StateT w m</i></font>
<a name="line-1111"></a>    computation <font color=Red>=</font> qcdata_mapM shape <font color=Cyan>(</font>map_leaf f<font color=Cyan>)</font> <font color=Cyan>(</font>map_leaf g<font color=Cyan>)</font> xs
<a name="line-1112"></a>
<a name="line-1113"></a>    map_leaf <font color=Red>::</font> <font color=Cyan>(</font>Monad m<font color=Cyan>)</font> <font color=Red>=&gt;</font> <font color=Cyan>(</font>a <font color=Red>-&gt;</font> s <font color=Red>-&gt;</font> m <font color=Cyan>(</font>b<font color=Cyan>,</font> s<font color=Cyan>)</font><font color=Cyan>)</font> <font color=Red>-&gt;</font> a <font color=Red>-&gt;</font> StateT s m b
<a name="line-1114"></a>    map_leaf f a <font color=Red>=</font> StateT <font color=Cyan>(</font>f a<font color=Cyan>)</font>
<a name="line-1115"></a>
<a name="line-1116"></a><a name="qcdata_sequentialize"></a><font color=Blue><i>-- | Return a list of leaves of the given heterogeneous data</i></font>
<a name="line-1117"></a><font color=Blue><i>-- structure. The first argument is a dummy shape type parameter, and</i></font>
<a name="line-1118"></a><font color=Blue><i>-- is only used for its type. Leaves in qubit positions and bit</i></font>
<a name="line-1119"></a><font color=Blue><i>-- positions are returned, respectively, as the left or right</i></font>
<a name="line-1120"></a><font color=Blue><i>-- components of a disjoint union.</i></font>
<a name="line-1121"></a><font color=Blue><i>-- </i></font>
<a name="line-1122"></a><font color=Blue><i>-- The leaves are ordered in some deterministic, but arbitrary way. It</i></font>
<a name="line-1123"></a><font color=Blue><i>-- is guaranteed that when two data structures of the same shape type</i></font>
<a name="line-1124"></a><font color=Blue><i>-- and shape (same length of lists etc) are sequentialized, the leaves</i></font>
<a name="line-1125"></a><font color=Blue><i>-- will be ordered the same way. No other property of the order is</i></font>
<a name="line-1126"></a><font color=Blue><i>-- guaranteed, In particular, it might change without notice.</i></font>
<a name="line-1127"></a><font color=Blue>qcdata_sequentialize</font> <font color=Red>::</font> <font color=Cyan>(</font>QCData qc<font color=Cyan>)</font> <font color=Red>=&gt;</font> qc <font color=Red>-&gt;</font> QCType q c qc <font color=Red>-&gt;</font> <font color=Red>[</font>B_Endpoint q c<font color=Red>]</font>
<a name="line-1128"></a><font color=Blue>qcdata_sequentialize</font> shape xs <font color=Red>=</font> xlist <font color=Green><u>where</u></font>
<a name="line-1129"></a>  blist <font color=Red>=</font> qcdata_fold shape do_qubit do_bit xs blist_empty
<a name="line-1130"></a>  xlist <font color=Red>=</font> list_of_blist blist
<a name="line-1131"></a>  
<a name="line-1132"></a>  do_qubit <font color=Red>::</font> q <font color=Red>-&gt;</font> BList <font color=Cyan>(</font>B_Endpoint q c<font color=Cyan>)</font> <font color=Red>-&gt;</font> BList <font color=Cyan>(</font>B_Endpoint q c<font color=Cyan>)</font>
<a name="line-1133"></a>  do_qubit q blist <font color=Red>=</font> blist <font color=Cyan>+++</font> blist_of_list <font color=Red>[</font>Endpoint_Qubit q<font color=Red>]</font>
<a name="line-1134"></a>
<a name="line-1135"></a>  do_bit <font color=Red>::</font> c <font color=Red>-&gt;</font> BList <font color=Cyan>(</font>B_Endpoint q c<font color=Cyan>)</font> <font color=Red>-&gt;</font> BList <font color=Cyan>(</font>B_Endpoint q c<font color=Cyan>)</font>
<a name="line-1136"></a>  do_bit c blist <font color=Red>=</font> blist <font color=Cyan>+++</font> blist_of_list <font color=Red>[</font>Endpoint_Bit c<font color=Red>]</font>
<a name="line-1137"></a>
<a name="line-1138"></a><a name="qcdata_unsequentialize"></a><font color=Blue><i>-- | Take a specimen heterogeneous data structure to specify the</i></font>
<a name="line-1139"></a><font color=Blue><i>-- \"shape\" desired (length of lists, etc); then reads the given list</i></font>
<a name="line-1140"></a><font color=Blue><i>-- of leaves in as a piece of heterogeneous data of the same</i></font>
<a name="line-1141"></a><font color=Blue><i>-- shape. The ordering of the leaves, and the division of the leaves</i></font>
<a name="line-1142"></a><font color=Blue><i>-- into qubit and bit positions, is assumed to be the same as that</i></font>
<a name="line-1143"></a><font color=Blue><i>-- which 'qcdata_sequentialize' produces for the given shape.</i></font>
<a name="line-1144"></a><font color=Blue><i>-- </i></font>
<a name="line-1145"></a><font color=Blue><i>-- A \"length mismatch\" error occurs if the list does not have</i></font>
<a name="line-1146"></a><font color=Blue><i>-- exactly the required length. A \"shape mismatch\" error occurs if</i></font>
<a name="line-1147"></a><font color=Blue><i>-- the list contains an 'Endpoint_Bit' entry corresponding to a</i></font>
<a name="line-1148"></a><font color=Blue><i>-- 'Qubit' position in the shape, or an 'Endpoint_Qubit' entry</i></font>
<a name="line-1149"></a><font color=Blue><i>-- corresponding to a 'Bit' position.</i></font>
<a name="line-1150"></a><font color=Blue><i>--           </i></font>
<a name="line-1151"></a><font color=Blue><i>-- Please note that, by contrast with the function</i></font>
<a name="line-1152"></a><font color=Blue><i>-- 'qcdata_sequentialize', the first argument is a shape term</i></font>
<a name="line-1153"></a><font color=Blue><i>-- parameter, not a shape type parameter. It is used to decide where</i></font>
<a name="line-1154"></a><font color=Blue><i>-- the qubits and bits should go in the data structure.</i></font>
<a name="line-1155"></a><font color=Blue>qcdata_unsequentialize</font> <font color=Red>::</font> <font color=Cyan>(</font>QCData qc<font color=Cyan>)</font> <font color=Red>=&gt;</font> qc <font color=Red>-&gt;</font> <font color=Red>[</font>B_Endpoint q c<font color=Red>]</font> <font color=Red>-&gt;</font> QCType q c qc
<a name="line-1156"></a><font color=Blue>qcdata_unsequentialize</font> shape xlist <font color=Red>=</font> xs <font color=Green><u>where</u></font>
<a name="line-1157"></a>  xs <font color=Red>=</font> <font color=Green><u>case</u></font> qcdata_fold_map shape do_qubit do_bit shape xlist <font color=Green><u>of</u></font>
<a name="line-1158"></a>    <font color=Cyan>(</font>xs<font color=Cyan>,</font> []<font color=Cyan>)</font> <font color=Red>-&gt;</font> xs
<a name="line-1159"></a>    <font color=Cyan>(</font>xs<font color=Cyan>,</font> <font color=Green><u>_</u></font><font color=Cyan>)</font> <font color=Red>-&gt;</font> error <font color=Magenta>"qcdata_unsequentialize: length mismatch"</font>
<a name="line-1160"></a>    
<a name="line-1161"></a>  <font color=Blue><i>-- first argument of do_qubit and do_bit is dummy</i></font>
<a name="line-1162"></a>  do_qubit <font color=Red>::</font> Qubit <font color=Red>-&gt;</font> <font color=Red>[</font>B_Endpoint q c<font color=Red>]</font> <font color=Red>-&gt;</font> <font color=Cyan>(</font>q<font color=Cyan>,</font> <font color=Red>[</font>B_Endpoint q c<font color=Red>]</font><font color=Cyan>)</font>
<a name="line-1163"></a>  do_qubit x <font color=Cyan>(</font>Endpoint_Qubit h <font color=Red><b>:</b></font> t<font color=Cyan>)</font> <font color=Red>=</font> <font color=Cyan>(</font>h<font color=Cyan>,</font> t<font color=Cyan>)</font>
<a name="line-1164"></a>  do_qubit x <font color=Cyan>(</font>Endpoint_Bit h <font color=Red><b>:</b></font> t<font color=Cyan>)</font> <font color=Red>=</font> error <font color=Magenta>"qcdata_unsequentialize: shape mismatch"</font>
<a name="line-1165"></a>  do_qubit x [] <font color=Red>=</font> error <font color=Magenta>"qcdata_unsequentialize: length mismatch"</font>
<a name="line-1166"></a>
<a name="line-1167"></a>  do_bit <font color=Red>::</font> Bit <font color=Red>-&gt;</font> <font color=Red>[</font>B_Endpoint q c<font color=Red>]</font> <font color=Red>-&gt;</font> <font color=Cyan>(</font>c<font color=Cyan>,</font> <font color=Red>[</font>B_Endpoint q c<font color=Red>]</font><font color=Cyan>)</font>
<a name="line-1168"></a>  do_bit x <font color=Cyan>(</font>Endpoint_Bit h <font color=Red><b>:</b></font> t<font color=Cyan>)</font> <font color=Red>=</font> <font color=Cyan>(</font>h<font color=Cyan>,</font> t<font color=Cyan>)</font>
<a name="line-1169"></a>  do_bit x <font color=Cyan>(</font>Endpoint_Qubit h <font color=Red><b>:</b></font> t<font color=Cyan>)</font> <font color=Red>=</font> error <font color=Magenta>"qcdata_unsequentialize: shape mismatch"</font>
<a name="line-1170"></a>  do_bit x [] <font color=Red>=</font> error <font color=Magenta>"qcdata_unsequentialize: length mismatch"</font>
<a name="line-1171"></a>
<a name="line-1172"></a><a name="qcdata_makeshape"></a><font color=Blue><i>-- | Combine a shape type argument /q/, two leaf type arguments /a/</i></font>
<a name="line-1173"></a><font color=Blue><i>-- and /b/, and a shape size argument /x/ into a single shape argument</i></font>
<a name="line-1174"></a><font color=Blue><i>-- /qx/. Note:</i></font>
<a name="line-1175"></a><font color=Blue><i>-- </i></font>
<a name="line-1176"></a><font color=Blue><i>-- * /q/ captures only the type, but not the size of the data. Only</i></font>
<a name="line-1177"></a><font color=Blue><i>-- the type of /q/ is used; its value can be undefined. This is</i></font>
<a name="line-1178"></a><font color=Blue><i>-- sufficient to determine the depth of leaves in a data structure,</i></font>
<a name="line-1179"></a><font color=Blue><i>-- but not their number.</i></font>
<a name="line-1180"></a><font color=Blue><i>-- </i></font>
<a name="line-1181"></a><font color=Blue><i>-- * /x/ captures only the size of the data, but not its type. In</i></font>
<a name="line-1182"></a><font color=Blue><i>-- particular, /x/ may have leaves of non-atomic types. /x/ must</i></font>
<a name="line-1183"></a><font color=Blue><i>-- consist of well-defined constructors up to the depth of leaves of</i></font>
<a name="line-1184"></a><font color=Blue><i>-- /q/, but the values at the actual leaves of /x/ may be undefined. </i></font>
<a name="line-1185"></a><font color=Blue><i>-- </i></font>
<a name="line-1186"></a><font color=Blue><i>-- * The output /qx/ combines the type of /q/ with the size of /x/,</i></font>
<a name="line-1187"></a><font color=Blue><i>-- and can therefore be used both as a shape type and a shape value.</i></font>
<a name="line-1188"></a><font color=Blue><i>-- Note that the actual leaves of /qx/ will be 'qubit' and 'bit',</i></font>
<a name="line-1189"></a><font color=Blue><i>-- which are synonyms for 'undefined'. </i></font>
<a name="line-1190"></a><font color=Blue><i>-- </i></font>
<a name="line-1191"></a><font color=Blue><i>-- Example:</i></font>
<a name="line-1192"></a><font color=Blue><i>-- </i></font>
<a name="line-1193"></a><font color=Blue><i>-- &gt; qc = undefined :: ([Qubit], [[Bit]])</i></font>
<a name="line-1194"></a><font color=Blue><i>-- &gt; x = ([undefined, (0,False)], [[undefined], [Just 2, Nothing]])</i></font>
<a name="line-1195"></a><font color=Blue><i>-- &gt; qcdata_makeshape qc a b x = ([qubit, qubit], [[bit], [bit, bit]])</i></font>
<a name="line-1196"></a><font color=Blue><i>-- </i></font>
<a name="line-1197"></a><font color=Blue><i>-- where /a/ :: @(Int,Bool)@, /b/ :: @(Maybe Int)@.</i></font>
<a name="line-1198"></a><font color=Blue>qcdata_makeshape</font> <font color=Red>::</font> <font color=Cyan>(</font>QCData qc<font color=Cyan>)</font> <font color=Red>=&gt;</font> qc <font color=Red>-&gt;</font> a <font color=Red>-&gt;</font> b <font color=Red>-&gt;</font> QCType a b qc <font color=Red>-&gt;</font> qc
<a name="line-1199"></a><font color=Blue>qcdata_makeshape</font> q <font color=Cyan>(</font>a<font color=Red>::</font>a<font color=Cyan>)</font> <font color=Cyan>(</font>b<font color=Red>::</font>b<font color=Cyan>)</font> x <font color=Red>=</font> qcdata_map q map_qubit map_bit x <font color=Green><u>where</u></font>
<a name="line-1200"></a>  map_qubit <font color=Red>=</font> const qubit <font color=Red>::</font> a <font color=Red>-&gt;</font> Qubit
<a name="line-1201"></a>  map_bit <font color=Red>=</font> const bit <font color=Red>::</font> b <font color=Red>-&gt;</font> Bit
<a name="line-1202"></a>
<a name="line-1203"></a><a name="qcdata_mapM_op"></a><font color=Blue><i>-- | Like 'qcdata_mapM', except the leaves are visited in exactly the</i></font>
<a name="line-1204"></a><font color=Blue><i>-- opposite order. This is used primarily for cosmetic reasons: For</i></font>
<a name="line-1205"></a><font color=Blue><i>-- example, when initializing a bunch of ancillas, and then</i></font>
<a name="line-1206"></a><font color=Blue><i>-- terminating them, the circuit will look more symmetric if they are</i></font>
<a name="line-1207"></a><font color=Blue><i>-- terminated in the opposite order.</i></font>
<a name="line-1208"></a><font color=Blue>qcdata_mapM_op</font> <font color=Red>::</font> <font color=Cyan>(</font>QCData qc<font color=Cyan>,</font> Monad m<font color=Cyan>)</font> <font color=Red>=&gt;</font> qc <font color=Red>-&gt;</font> <font color=Cyan>(</font>q <font color=Red>-&gt;</font> m q'<font color=Cyan>)</font> <font color=Red>-&gt;</font> <font color=Cyan>(</font>c <font color=Red>-&gt;</font> m c'<font color=Cyan>)</font> <font color=Red>-&gt;</font> QCType q c qc <font color=Red>-&gt;</font> m <font color=Cyan>(</font>QCType q' c' qc<font color=Cyan>)</font>
<a name="line-1209"></a><font color=Blue>qcdata_mapM_op</font> shapetype <font color=Cyan>(</font>f <font color=Red>::</font> q <font color=Red>-&gt;</font> m q'<font color=Cyan>)</font> <font color=Cyan>(</font>g <font color=Red>::</font> c <font color=Red>-&gt;</font> m c'<font color=Cyan>)</font> xs <font color=Red>=</font> <font color=Green><u>do</u></font>
<a name="line-1210"></a>  <font color=Green><u>let</u></font> shapeterm <font color=Red>=</font> qcdata_makeshape shapetype <font color=Cyan>(</font>dummy<font color=Red>::</font>q<font color=Cyan>)</font> <font color=Cyan>(</font>dummy<font color=Red>::</font>c<font color=Cyan>)</font> xs 
<a name="line-1211"></a>  <font color=Green><u>let</u></font> xlist <font color=Red>=</font> qcdata_sequentialize shapeterm xs
<a name="line-1212"></a>  ylist <font color=Red>&lt;-</font> sequence_right <font color=Red>[</font> map_endpointM f g x <font color=Red>|</font> x <font color=Red>&lt;-</font> xlist <font color=Red>]</font>
<a name="line-1213"></a>  <font color=Green><u>let</u></font> ys <font color=Red>=</font> qcdata_unsequentialize shapeterm ylist
<a name="line-1214"></a>  return ys
<a name="line-1215"></a>  <font color=Green><u>where</u></font>
<a name="line-1216"></a>    map_endpointM f g <font color=Cyan>(</font>Endpoint_Qubit x<font color=Cyan>)</font> <font color=Red>=</font> <font color=Green><u>do</u></font>
<a name="line-1217"></a>      x' <font color=Red>&lt;-</font> f x
<a name="line-1218"></a>      return <font color=Cyan>(</font>Endpoint_Qubit x'<font color=Cyan>)</font>
<a name="line-1219"></a>    map_endpointM f g <font color=Cyan>(</font>Endpoint_Bit y<font color=Cyan>)</font> <font color=Red>=</font> <font color=Green><u>do</u></font>
<a name="line-1220"></a>      y' <font color=Red>&lt;-</font> g y
<a name="line-1221"></a>      return <font color=Cyan>(</font>Endpoint_Bit y'<font color=Cyan>)</font>
<a name="line-1222"></a>
<a name="line-1223"></a><font color=Blue><i>-- ----------------------------------------------------------------------  </i></font>
<a name="line-1224"></a><font color=Blue><i>-- ** The QCDataPlus class</i></font>
<a name="line-1225"></a>
<a name="line-1226"></a><font color=Blue><i>-- Implementation note: Since Haskell does not allow cyclic</i></font>
<a name="line-1227"></a><font color=Blue><i>-- dependencies in the definition of type classes, it was a</i></font>
<a name="line-1228"></a><font color=Blue><i>-- non-trivial problem to define 'QShape' and 'QCDataPlus' so that the</i></font>
<a name="line-1229"></a><font color=Blue><i>-- implications go both ways. We solved this problem by basing both</i></font>
<a name="line-1230"></a><font color=Blue><i>-- classes on QCData, together with a generous application of</i></font>
<a name="line-1231"></a><font color=Blue><i>-- equational reasoning.</i></font>
<a name="line-1232"></a>
<a name="line-1233"></a><font color=Blue><i>-- | The 'QCDataPlus' type class is almost identical to 'QCData',</i></font>
<a name="line-1234"></a><font color=Blue><i>-- except that it contains one additional piece of information that</i></font>
<a name="line-1235"></a><font color=Blue><i>-- allows the type checker to prove the implications</i></font>
<a name="line-1236"></a><font color=Blue><i>-- </i></font>
<a name="line-1237"></a><font color=Blue><i>-- &gt; QCDataPlus qc     implies   QShape (BType qc) (QType qc) (CType qc)</i></font>
<a name="line-1238"></a><font color=Blue><i>-- &gt; QCDataPlus qc     implies   QData (QType qc)</i></font>
<a name="line-1239"></a><font color=Blue><i>-- &gt; QCDataPlus qc     implies   CData (CType qc)</i></font>
<a name="line-1240"></a><font color=Blue><i>-- &gt; QCDataPlus qc     implies   BData (BType qc)</i></font>
<a name="line-1241"></a><font color=Blue><i>-- </i></font>
<a name="line-1242"></a><font color=Blue><i>-- This is sometimes useful, for example, in the context of a function</i></font>
<a name="line-1243"></a><font color=Blue><i>-- that inputs a 'QCData', measures all the qubits, and returns a</i></font>
<a name="line-1244"></a><font color=Blue><i>-- 'CData'. However, the additional information for the type checker</i></font>
<a name="line-1245"></a><font color=Blue><i>-- comes at a price, which is drastically increased compilation time.</i></font>
<a name="line-1246"></a><font color=Blue><i>-- Therefore 'QCDataPlus' should only be used when 'QCData' is</i></font>
<a name="line-1247"></a><font color=Blue><i>-- insufficient.</i></font>
<a name="line-1248"></a>
<a name="line-1249"></a><a name="QCDataPlus"></a><font color=Green><u>class</u></font> <font color=Cyan>(</font>QCData qc<font color=Cyan>,</font> QData <font color=Cyan>(</font>QType qc<font color=Cyan>)</font><font color=Cyan>)</font> <font color=Red>=&gt;</font> QCDataPlus qc
<a name="line-1250"></a><a name="instance%20QCDataPlus%20qc"></a><font color=Green><u>instance</u></font> <font color=Cyan>(</font>QCData qc<font color=Cyan>,</font> QData <font color=Cyan>(</font>QType qc<font color=Cyan>)</font><font color=Cyan>)</font> <font color=Red>=&gt;</font> QCDataPlus qc
<a name="line-1251"></a>
<a name="line-1252"></a><font color=Blue><i>-- ----------------------------------------------------------------------</i></font>
<a name="line-1253"></a><font color=Blue><i>-- ** Fixed size QCDataPlus</i></font>
<a name="line-1254"></a>
<a name="line-1255"></a><a name="QCData_Simple"></a><font color=Blue><i>-- | 'QCDataPlus_Simple' is a convenience type class that combines</i></font>
<a name="line-1256"></a><a name="QCData_Simple"></a><font color=Blue><i>-- 'QCDataPlus' and 'SimpleType'.</i></font>
<a name="line-1257"></a><a name="QCData_Simple"></a><font color=Green><u>class</u></font> <font color=Cyan>(</font>QCData qc<font color=Cyan>,</font> SimpleType qc<font color=Cyan>)</font> <font color=Red>=&gt;</font> QCData_Simple qc
<a name="line-1258"></a><a name="instance%20QCData_Simple%20qc"></a><font color=Green><u>instance</u></font> <font color=Cyan>(</font>QCData qc<font color=Cyan>,</font> SimpleType qc<font color=Cyan>)</font> <font color=Red>=&gt;</font> QCData_Simple qc
<a name="line-1259"></a>
<a name="line-1260"></a><a name="QCDataPlus_Simple"></a><font color=Blue><i>-- | 'QCDataPlus_Simple' is a convenience type class that combines</i></font>
<a name="line-1261"></a><a name="QCDataPlus_Simple"></a><font color=Blue><i>-- 'QCDataPlus' and 'SimpleType'.</i></font>
<a name="line-1262"></a><a name="QCDataPlus_Simple"></a><font color=Green><u>class</u></font> <font color=Cyan>(</font>QCDataPlus qc<font color=Cyan>,</font> SimpleType qc<font color=Cyan>)</font> <font color=Red>=&gt;</font> QCDataPlus_Simple qc
<a name="line-1263"></a><a name="instance%20QCDataPlus_Simple%20qc"></a><font color=Green><u>instance</u></font> <font color=Cyan>(</font>QCDataPlus qc<font color=Cyan>,</font> SimpleType qc<font color=Cyan>)</font> <font color=Red>=&gt;</font> QCDataPlus_Simple qc
<a name="line-1264"></a>
<a name="line-1265"></a><font color=Blue><i>-- Implementation note: We could just have made 'SimpleType' a</i></font>
<a name="line-1266"></a><font color=Blue><i>-- subclass of 'QCData' directly, but this would require the</i></font>
<a name="line-1267"></a><font color=Blue><i>-- type-checker to do lots of additional theorem proving, to the point</i></font>
<a name="line-1268"></a><font color=Blue><i>-- of overflowing the context stack and significantly slowing down</i></font>
<a name="line-1269"></a><font color=Blue><i>-- compilation.</i></font>
<a name="line-1270"></a>
<a name="line-1271"></a><font color=Blue><i>-- ----------------------------------------------------------------------</i></font>
<a name="line-1272"></a><font color=Blue><i>-- ** The QCLeaf class</i></font>
<a name="line-1273"></a>
<a name="line-1274"></a><a name="QCLeaf"></a><font color=Blue><i>-- | The class 'QCLeaf' consists of the two types 'Qubit' and 'Bit'.</i></font>
<a name="line-1275"></a><a name="QCLeaf"></a><font color=Blue><i>-- It is primarily used for convenience, in those cases (such as the</i></font>
<a name="line-1276"></a><a name="QCLeaf"></a><font color=Blue><i>-- arithmetic library) where some class instance should be defined for</i></font>
<a name="line-1277"></a><a name="QCLeaf"></a><font color=Blue><i>-- the cases 'Qubit' and 'Bit', but not for general 'QCData'. It is</i></font>
<a name="line-1278"></a><a name="QCLeaf"></a><font color=Blue><i>-- also used, e.g., in the definition of the './=.' operator.</i></font>
<a name="line-1279"></a><a name="QCLeaf"></a><font color=Green><u>class</u></font> <font color=Cyan>(</font>QCData q<font color=Cyan>,</font> 
<a name="line-1280"></a>       SimpleType q<font color=Cyan>,</font> 
<a name="line-1281"></a>       ControlSource q<font color=Cyan>,</font> 
<a name="line-1282"></a>       ControlSource <font color=Cyan>(</font>Signed q<font color=Cyan>)</font><font color=Cyan>,</font> 
<a name="line-1283"></a>       Labelable q String<font color=Cyan>,</font> 
<a name="line-1284"></a>       QCType Qubit Bit q <font color=Red>~</font> q<font color=Cyan>,</font>
<a name="line-1285"></a>       QCType Bool Bool q <font color=Red>~</font> Bool<font color=Cyan>)</font> <font color=Red>=&gt;</font> QCLeaf q
<a name="line-1286"></a>
<a name="line-1287"></a><a name="instance%20QCLeaf%20Qubit"></a><font color=Green><u>instance</u></font> QCLeaf Qubit
<a name="line-1288"></a><a name="instance%20QCLeaf%20Bit"></a><font color=Green><u>instance</u></font> QCLeaf Bit
<a name="line-1289"></a>
<a name="line-1290"></a><font color=Blue><i>-- ----------------------------------------------------------------------</i></font>
<a name="line-1291"></a><font color=Blue><i>-- ** Canonical string representation</i></font>
<a name="line-1292"></a>
<a name="line-1293"></a><font color=Blue><i>-- $ For the purpose of storing boxed subroutines, it is useful to</i></font>
<a name="line-1294"></a><font color=Blue><i>-- have a unique representation of 'QCData' shapes as strings.  The</i></font>
<a name="line-1295"></a><font color=Blue><i>-- currently implementation relies on 'show' to give unique</i></font>
<a name="line-1296"></a><font color=Blue><i>-- representations. Therefore, when defining 'Show' instances for</i></font>
<a name="line-1297"></a><font color=Blue><i>-- 'QCData', one should make sure that the generated strings contain</i></font>
<a name="line-1298"></a><font color=Blue><i>-- enough information to recover both the type and the shape uniquely.</i></font>
<a name="line-1299"></a>
<a name="line-1300"></a><a name="Qubit_Leaf"></a><font color=Blue><i>-- | A type to represent a 'Qubit' leaf, for the sole purpose that</i></font>
<a name="line-1301"></a><a name="Qubit_Leaf"></a><font color=Blue><i>-- 'show' will show it as \"Q\".</i></font>
<a name="line-1302"></a><a name="Qubit_Leaf"></a><font color=Green><u>data</u></font> Qubit_Leaf <font color=Red>=</font> Qubit_Leaf
<a name="line-1303"></a><a name="instance%20Show%20Qubit_Leaf"></a><font color=Green><u>instance</u></font> Show Qubit_Leaf <font color=Green><u>where</u></font>
<a name="line-1304"></a>  show <font color=Green><u>_</u></font> <font color=Red>=</font> <font color=Magenta>"Q"</font>
<a name="line-1305"></a>
<a name="line-1306"></a><a name="Bit_Leaf"></a><font color=Blue><i>-- | A type to represent a 'Bit' leaf, for the sole purpose that</i></font>
<a name="line-1307"></a><a name="Bit_Leaf"></a><font color=Blue><i>-- 'show' will show it as \"C\".</i></font>
<a name="line-1308"></a><a name="Bit_Leaf"></a><font color=Green><u>data</u></font> Bit_Leaf <font color=Red>=</font> Bit_Leaf
<a name="line-1309"></a><a name="instance%20Show%20Bit_Leaf"></a><font color=Green><u>instance</u></font> Show Bit_Leaf <font color=Green><u>where</u></font>
<a name="line-1310"></a>  show <font color=Green><u>_</u></font> <font color=Red>=</font> <font color=Magenta>"C"</font>
<a name="line-1311"></a>
<a name="line-1312"></a><a name="canonical_shape"></a><font color=Blue><i>-- | Turn any 'QCData' into a string uniquely identifying its type and</i></font>
<a name="line-1313"></a><font color=Blue><i>-- shape. The current implementation assumes that appropriately unique</i></font>
<a name="line-1314"></a><font color=Blue><i>-- 'Show' instances are defined for all 'QCData'.</i></font>
<a name="line-1315"></a><font color=Blue>canonical_shape</font> <font color=Red>::</font> <font color=Cyan>(</font>QCData qc<font color=Cyan>)</font> <font color=Red>=&gt;</font> qc <font color=Red>-&gt;</font> String  
<a name="line-1316"></a><font color=Blue>canonical_shape</font> qc <font color=Red>=</font> show <font color=Cyan>$</font> qcdata_map qc do_qubit do_bit qc
<a name="line-1317"></a>  <font color=Green><u>where</u></font>
<a name="line-1318"></a>    do_qubit <font color=Red>::</font> Qubit <font color=Red>-&gt;</font> Qubit_Leaf
<a name="line-1319"></a>    do_qubit q <font color=Red>=</font> Qubit_Leaf
<a name="line-1320"></a>    
<a name="line-1321"></a>    do_bit <font color=Red>::</font> Bit <font color=Red>-&gt;</font> Bit_Leaf
<a name="line-1322"></a>    do_bit c <font color=Red>=</font> Bit_Leaf
<a name="line-1323"></a>           
<a name="line-1324"></a><a name="LType"></a><font color=Blue><i>-- | The type operator 'LType' converts 'Qubit' to 'Qubit_Leaf' and</i></font>
<a name="line-1325"></a><a name="LType"></a><font color=Blue><i>-- 'Bit' to 'Bit_Leaf'.</i></font>
<a name="line-1326"></a><a name="LType"></a><font color=Green><u>type</u></font> LType a <font color=Red>=</font> QCType Qubit_Leaf Bit_Leaf a
<a name="line-1327"></a>
<a name="line-1328"></a><font color=Blue><i>-- ======================================================================</i></font>
<a name="line-1329"></a><font color=Blue><i>-- * Defining new QCData instances</i></font>
<a name="line-1330"></a>
<a name="line-1331"></a><font color=Blue><i>-- $ To define a new kind of quantum data, the following must be</i></font>
<a name="line-1332"></a><font color=Blue><i>-- defined:</i></font>
<a name="line-1333"></a><font color=Blue><i>-- </i></font>
<a name="line-1334"></a><font color=Blue><i>-- * A class instance of 'QCData',</i></font>
<a name="line-1335"></a><font color=Blue><i>-- </i></font>
<a name="line-1336"></a><font color=Blue><i>-- * a type instance of 'QCType', and</i></font>
<a name="line-1337"></a><font color=Blue><i>-- </i></font>
<a name="line-1338"></a><font color=Blue><i>-- * a type instance of 'QTypeB'.</i></font>
<a name="line-1339"></a><font color=Blue><i>-- </i></font>
<a name="line-1340"></a><font color=Blue><i>-- If the new type is simple, an class instance of 'SimpleType' should</i></font>
<a name="line-1341"></a><font color=Blue><i>-- also be defined.</i></font>
<a name="line-1342"></a><font color=Blue><i>-- </i></font>
<a name="line-1343"></a><font color=Blue><i>-- If the new type may be integrated with Template Haskell, a class</i></font>
<a name="line-1344"></a><font color=Blue><i>-- instance of 'CircLiftingUnpack' should also be defined.</i></font>
<a name="line-1345"></a><font color=Blue><i>-- </i></font>
<a name="line-1346"></a><font color=Blue><i>-- To ensure that circuit labeling will work for the new type, a class</i></font>
<a name="line-1347"></a><font color=Blue><i>-- instance of 'Labelable' must also be defined for every member of</i></font>
<a name="line-1348"></a><font color=Blue><i>-- 'QCData'. See "Quipper.Labels" for detailed instructions on how to</i></font>
<a name="line-1349"></a><font color=Blue><i>-- do so.</i></font>
<a name="line-1350"></a><font color=Blue><i>-- </i></font>
<a name="line-1351"></a><font color=Blue><i>-- Modules that define new kinds of quantum data should import</i></font>
<a name="line-1352"></a><font color=Blue><i>-- "Quipper.Internal".</i></font>
</pre>
</body>
</html>