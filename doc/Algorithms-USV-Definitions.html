<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Algorithms.USV.Definitions</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Algorithms-USV-Definitions.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/Algorithms/USV/Definitions.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">The Quipper System</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>None</td></tr></table><p class="caption">Algorithms.USV.Definitions</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Types for the Unique Shortest Vector algorithm </a></li><li><a href="#g:2">General purpose functions</a></li><li><a href="#g:3">Linear algebra</a></li><li><a href="#g:4">Euclid's algorithm</a></li><li><a href="#g:5">Classical subroutines </a></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>This module provides global definitions for 
 the Unique Shortest Vector algorithm.</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><span class="keyword">type</span> <a href="#t:TwoPoint">TwoPoint</a> = (<a href="Quipper-Monad.html#t:Qubit">Qubit</a>, &#91;<a href="QuipperLib-Arith.html#t:QDInt">QDInt</a>&#93;)</li><li class="src short"><span class="keyword">type</span> <a href="#t:CosetState">CosetState</a> = (<a href="Quipper-Monad.html#t:Qubit">Qubit</a>, <a href="QuipperLib-Arith.html#t:QDInt">QDInt</a>)</li><li class="src short"><span class="keyword">type</span> <a href="#t:Psi_k">Psi_k</a> = (<a href="Quipper-Monad.html#t:Qubit">Qubit</a>, <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a>)</li><li class="src short"><a href="#v:concat_pair">concat_pair</a> :: (&#91;a&#93;, &#91;b&#93;) -&gt; (&#91;a&#93;, &#91;b&#93;) -&gt; (&#91;a&#93;, &#91;b&#93;)</li><li class="src short"><a href="#v:multi_split">multi_split</a> :: <a href="http://hackage.haskell.org/package/random-1.1/docs/System-Random.html#t:StdGen">StdGen</a> -&gt; &#91;<a href="http://hackage.haskell.org/package/random-1.1/docs/System-Random.html#t:StdGen">StdGen</a>&#93;</li><li class="src short"><a href="#v:find">find</a> :: &#91;a&#93; -&gt; (a -&gt; <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Bool.html#t:Bool">Bool</a>) -&gt; <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-String.html#t:String">String</a> -&gt; (a, &#91;a&#93;)</li><li class="src short"><a href="#v:separate">separate</a> :: &#91;a&#93; -&gt; (a -&gt; <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Bool.html#t:Bool">Bool</a>) -&gt; (&#91;a&#93;, &#91;a&#93;)</li><li class="src short"><a href="#v:expand">expand</a> :: <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Prelude.html#t:Integer">Integer</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Prelude.html#t:Integer">Integer</a> -&gt; &#91;<a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Prelude.html#t:Integer">Integer</a>&#93;</li><li class="src short"><a href="#v:qdiscard_psi_ks">qdiscard_psi_ks</a> :: &#91;<a href="Algorithms-USV-Definitions.html#t:Psi_k">Psi_k</a>&#93; -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> ()</li><li class="src short"><a href="#v:find_partners">find_partners</a> :: <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Ord.html#t:Ord">Ord</a> b =&gt; (a -&gt; b) -&gt; &#91;a&#93; -&gt; (&#91;(a, a)&#93;, &#91;a&#93;)</li><li class="src short"><a href="#v:norm">norm</a> :: &#91;<a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Prelude.html#t:Integer">Integer</a>&#93; -&gt; <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Prelude.html#t:Float">Float</a></li><li class="src short"><a href="#v:vector_add">vector_add</a> :: <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Prelude.html#t:Num">Num</a> a =&gt; &#91;a&#93; -&gt; &#91;a&#93; -&gt; &#91;a&#93;</li><li class="src short"><a href="#v:q_vector_add">q_vector_add</a> :: &#91;<a href="QuipperLib-Arith.html#t:QDInt">QDInt</a>&#93; -&gt; &#91;<a href="QuipperLib-Arith.html#t:QDInt">QDInt</a>&#93; -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> &#91;<a href="QuipperLib-Arith.html#t:QDInt">QDInt</a>&#93;</li><li class="src short"><a href="#v:scalar_mult">scalar_mult</a> :: <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Prelude.html#t:Num">Num</a> a =&gt; a -&gt; &#91;a&#93; -&gt; &#91;a&#93;</li><li class="src short"><a href="#v:q_scalar_mult">q_scalar_mult</a> :: <a href="QuipperLib-Arith.html#t:QDInt">QDInt</a> -&gt; &#91;<a href="QuipperLib-Arith.html#t:QDInt">QDInt</a>&#93; -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> &#91;<a href="QuipperLib-Arith.html#t:QDInt">QDInt</a>&#93;</li><li class="src short"><a href="#v:matrix_mult">matrix_mult</a> :: &#91;&#91;<a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Prelude.html#t:Integer">Integer</a>&#93;&#93; -&gt; &#91;<a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Prelude.html#t:Integer">Integer</a>&#93; -&gt; &#91;<a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Prelude.html#t:Integer">Integer</a>&#93;</li><li class="src short"><a href="#v:q_matrix_mult">q_matrix_mult</a> :: &#91;&#91;<a href="QuipperLib-Arith.html#t:QDInt">QDInt</a>&#93;&#93; -&gt; &#91;<a href="QuipperLib-Arith.html#t:QDInt">QDInt</a>&#93; -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> &#91;<a href="QuipperLib-Arith.html#t:QDInt">QDInt</a>&#93;</li><li class="src short"><a href="#v:is_zero_vector">is_zero_vector</a> :: &#91;<a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Prelude.html#t:Integer">Integer</a>&#93; -&gt; <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Bool.html#t:Bool">Bool</a></li><li class="src short"><a href="#v:ext_euclid">ext_euclid</a> :: <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Prelude.html#t:Integer">Integer</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Prelude.html#t:Integer">Integer</a> -&gt; (<a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Prelude.html#t:Integer">Integer</a>, <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Prelude.html#t:Integer">Integer</a>, <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Prelude.html#t:Integer">Integer</a>, <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Prelude.html#t:Integer">Integer</a>, <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Prelude.html#t:Integer">Integer</a>)</li><li class="src short"><a href="#v:lll">lll</a> :: &#91;&#91;<a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Prelude.html#t:Integer">Integer</a>&#93;&#93; -&gt; &#91;&#91;<a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Prelude.html#t:Integer">Integer</a>&#93;&#93;</li><li class="src short"><a href="#v:find_prime">find_prime</a> :: <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a></li><li class="src short"><a href="#v:is_in_lattice">is_in_lattice</a> :: &#91;<a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Prelude.html#t:Integer">Integer</a>&#93; -&gt; &#91;&#91;<a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Prelude.html#t:Integer">Integer</a>&#93;&#93; -&gt; <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Bool.html#t:Bool">Bool</a></li><li class="src short"><a href="#v:reduce_lattice">reduce_lattice</a> :: &#91;&#91;<a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Prelude.html#t:Integer">Integer</a>&#93;&#93; -&gt; &#91;&#91;<a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Prelude.html#t:Integer">Integer</a>&#93;&#93;</li><li class="src short"><a href="#v:column_op">column_op</a> :: &#91;<a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Prelude.html#t:Integer">Integer</a>&#93; -&gt; &#91;<a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Prelude.html#t:Integer">Integer</a>&#93; -&gt; (&#91;<a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Prelude.html#t:Integer">Integer</a>&#93;, &#91;<a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Prelude.html#t:Integer">Integer</a>&#93;)</li></ul></div><div id="interface"><h1 id="g:1">Types for the Unique Shortest Vector algorithm </h1><div class="top"><p class="src"><span class="keyword">type</span> <a id="t:TwoPoint" class="def">TwoPoint</a> = (<a href="Quipper-Monad.html#t:Qubit">Qubit</a>, &#91;<a href="QuipperLib-Arith.html#t:QDInt">QDInt</a>&#93;) <a href="src/Algorithms/USV/Definitions.html#line-25" class="link">Source</a> <a href="#t:TwoPoint" class="selflink">#</a></p><div class="doc"><p>An input to <code>tPP</code>: a pair of a <code><a href="Quipper-Monad.html#t:Qubit">Qubit</a></code> and a list
 of <code><a href="QuipperLib-Arith.html#t:QDInt">QDInt</a></code>s. Holds a superposition of two vectors with an
 unknown fixed difference.</p></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a id="t:CosetState" class="def">CosetState</a> = (<a href="Quipper-Monad.html#t:Qubit">Qubit</a>, <a href="QuipperLib-Arith.html#t:QDInt">QDInt</a>) <a href="src/Algorithms/USV/Definitions.html#line-30" class="link">Source</a> <a href="#t:CosetState" class="selflink">#</a></p><div class="doc"><p>An input to <code>dCP</code>: a pair of a <code><a href="Quipper-Monad.html#t:Qubit">Qubit</a></code> and a
 <code><a href="QuipperLib-Arith.html#t:QDInt">QDInt</a></code>. Holds a superposition of two numbers with an
 unknown fixed difference.</p></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a id="t:Psi_k" class="def">Psi_k</a> = (<a href="Quipper-Monad.html#t:Qubit">Qubit</a>, <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a>) <a href="src/Algorithms/USV/Definitions.html#line-38" class="link">Source</a> <a href="#t:Psi_k" class="selflink">#</a></p><div class="doc"><p>An input to <code>sieving</code>: a pair of a <code><a href="Quipper-Monad.html#t:Qubit">Qubit</a></code> and an 
 integer. Holds a state of the form:</p><p><img src="images/CosetState.png"> </p><p>together with the integer <em>k</em>.</p></div></div><h1 id="g:2">General purpose functions</h1><div class="top"><p class="src"><a id="v:concat_pair" class="def">concat_pair</a> :: (&#91;a&#93;, &#91;b&#93;) -&gt; (&#91;a&#93;, &#91;b&#93;) -&gt; (&#91;a&#93;, &#91;b&#93;) <a href="src/Algorithms/USV/Definitions.html#line-45" class="link">Source</a> <a href="#v:concat_pair" class="selflink">#</a></p><div class="doc"><p>Concatenate two pairs of lists componentwise. </p></div></div><div class="top"><p class="src"><a id="v:multi_split" class="def">multi_split</a> :: <a href="http://hackage.haskell.org/package/random-1.1/docs/System-Random.html#t:StdGen">StdGen</a> -&gt; &#91;<a href="http://hackage.haskell.org/package/random-1.1/docs/System-Random.html#t:StdGen">StdGen</a>&#93; <a href="src/Algorithms/USV/Definitions.html#line-49" class="link">Source</a> <a href="#v:multi_split" class="selflink">#</a></p><div class="doc"><p>Construct a list of random number generators.</p></div></div><div class="top"><p class="src"><a id="v:find" class="def">find</a> :: &#91;a&#93; -&gt; (a -&gt; <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Bool.html#t:Bool">Bool</a>) -&gt; <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-String.html#t:String">String</a> -&gt; (a, &#91;a&#93;) <a href="src/Algorithms/USV/Definitions.html#line-57" class="link">Source</a> <a href="#v:find" class="selflink">#</a></p><div class="doc"><p>Given a list <em>l</em>, a predicate <em>p</em> and an error message <em>msg</em>, 
 return a pair (<em>a</em>,<em>l'</em>) where <em>a</em> is the first element 
 of <em>l</em> satisfying <em>p</em> and <em>l'</em> is the remaining list. 
 If no such element exists, raise an error and display <em>msg</em>.</p></div></div><div class="top"><p class="src"><a id="v:separate" class="def">separate</a> :: &#91;a&#93; -&gt; (a -&gt; <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Bool.html#t:Bool">Bool</a>) -&gt; (&#91;a&#93;, &#91;a&#93;) <a href="src/Algorithms/USV/Definitions.html#line-68" class="link">Source</a> <a href="#v:separate" class="selflink">#</a></p><div class="doc"><p>Given a list <em>l</em> and a predicate <em>p</em>, return a pair
 (<em>l1</em>, <em>l2</em>) where <em>l1</em> contains the elements of <em>l</em> 
 satisfying <em>p</em> and <em>l2</em> the others.</p></div></div><div class="top"><p class="src"><a id="v:expand" class="def">expand</a> :: <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Prelude.html#t:Integer">Integer</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Prelude.html#t:Integer">Integer</a> -&gt; &#91;<a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Prelude.html#t:Integer">Integer</a>&#93; <a href="src/Algorithms/USV/Definitions.html#line-76" class="link">Source</a> <a href="#v:expand" class="selflink">#</a></p><div class="doc"><p>Given integers <em>m</em> and <em>n</em>, compute the 
 big-endian expansion of <em>m</em> in base <em>n</em>.</p></div></div><div class="top"><p class="src"><a id="v:qdiscard_psi_ks" class="def">qdiscard_psi_ks</a> :: &#91;<a href="Algorithms-USV-Definitions.html#t:Psi_k">Psi_k</a>&#93; -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> () <a href="src/Algorithms/USV/Definitions.html#line-87" class="link">Source</a> <a href="#v:qdiscard_psi_ks" class="selflink">#</a></p><div class="doc"><p>Discard a list of <code><a href="Algorithms-USV-Definitions.html#t:Psi_k">Psi_k</a></code>s</p></div></div><div class="top"><p class="src"><a id="v:find_partners" class="def">find_partners</a> :: <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Ord.html#t:Ord">Ord</a> b =&gt; (a -&gt; b) -&gt; &#91;a&#93; -&gt; (&#91;(a, a)&#93;, &#91;a&#93;) <a href="src/Algorithms/USV/Definitions.html#line-110" class="link">Source</a> <a href="#v:find_partners" class="selflink">#</a></p><div class="doc"><p>Given a list of people, and a function assigning a religion to
 each person, divide the people into couples of the same religion.
 Some people will remain single if there isn't a suitable
 partner. Return a list of couples and a list of single people.</p><p>The algorithm proceeds as follows. We have a room for each
 religion. Initially the rooms are empty. As each person arrives,
 they go to their room. If the room is empty, they stay there. If
 the room is occupied, they marry the occupant and join the list
 of couples. At the end, all single people are retrieved from
 their rooms.</p><p>This function is lazy, i.e., couples are formed as they are
 found. Only the singles have to wait until the end of the list.</p><p>Running time is O(<em>n</em> log <em>n</em>).</p></div></div><h1 id="g:3">Linear algebra</h1><div class="top"><p class="src"><a id="v:norm" class="def">norm</a> :: &#91;<a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Prelude.html#t:Integer">Integer</a>&#93; -&gt; <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Prelude.html#t:Float">Float</a> <a href="src/Algorithms/USV/Definitions.html#line-128" class="link">Source</a> <a href="#v:norm" class="selflink">#</a></p><div class="doc"><p>Compute the Euclidean norm of a vector.</p></div></div><div class="top"><p class="src"><a id="v:vector_add" class="def">vector_add</a> :: <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Prelude.html#t:Num">Num</a> a =&gt; &#91;a&#93; -&gt; &#91;a&#93; -&gt; &#91;a&#93; <a href="src/Algorithms/USV/Definitions.html#line-132" class="link">Source</a> <a href="#v:vector_add" class="selflink">#</a></p><div class="doc"><p>Compute the sum of two vectors.</p></div></div><div class="top"><p class="src"><a id="v:q_vector_add" class="def">q_vector_add</a> :: &#91;<a href="QuipperLib-Arith.html#t:QDInt">QDInt</a>&#93; -&gt; &#91;<a href="QuipperLib-Arith.html#t:QDInt">QDInt</a>&#93; -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> &#91;<a href="QuipperLib-Arith.html#t:QDInt">QDInt</a>&#93; <a href="src/Algorithms/USV/Definitions.html#line-136" class="link">Source</a> <a href="#v:q_vector_add" class="selflink">#</a></p><div class="doc"><p>Quantum version of <code><a href="Algorithms-USV-Definitions.html#v:vector_add">vector_add</a></code>.</p></div></div><div class="top"><p class="src"><a id="v:scalar_mult" class="def">scalar_mult</a> :: <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Prelude.html#t:Num">Num</a> a =&gt; a -&gt; &#91;a&#93; -&gt; &#91;a&#93; <a href="src/Algorithms/USV/Definitions.html#line-142" class="link">Source</a> <a href="#v:scalar_mult" class="selflink">#</a></p><div class="doc"><p>Compute the multiplication of a scalar with a vector.</p></div></div><div class="top"><p class="src"><a id="v:q_scalar_mult" class="def">q_scalar_mult</a> :: <a href="QuipperLib-Arith.html#t:QDInt">QDInt</a> -&gt; &#91;<a href="QuipperLib-Arith.html#t:QDInt">QDInt</a>&#93; -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> &#91;<a href="QuipperLib-Arith.html#t:QDInt">QDInt</a>&#93; <a href="src/Algorithms/USV/Definitions.html#line-146" class="link">Source</a> <a href="#v:q_scalar_mult" class="selflink">#</a></p><div class="doc"><p>Quantum version of <code><a href="Algorithms-USV-Definitions.html#v:scalar_mult">scalar_mult</a></code>.</p></div></div><div class="top"><p class="src"><a id="v:matrix_mult" class="def">matrix_mult</a> :: &#91;&#91;<a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Prelude.html#t:Integer">Integer</a>&#93;&#93; -&gt; &#91;<a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Prelude.html#t:Integer">Integer</a>&#93; -&gt; &#91;<a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Prelude.html#t:Integer">Integer</a>&#93; <a href="src/Algorithms/USV/Definitions.html#line-162" class="link">Source</a> <a href="#v:matrix_mult" class="selflink">#</a></p><div class="doc"><p>Multiply an <em>n</em>&#215;<em>m</em>-matrix by an <em>m</em>-dimensional column 
 vector to obtain an <em>n</em>-dimensional column vector. The 
 matrix is represented as a list of <em>m</em> columns. </p><p>Precondition: <em>m</em> &gt; 0.</p><p>Example:</p><pre>matrix_mult &#91;&#91;1,2,3&#93;,&#91;1,0,0&#93;&#93; &#91;1,1&#93; = &#91;2,2,3&#93;</pre></div></div><div class="top"><p class="src"><a id="v:q_matrix_mult" class="def">q_matrix_mult</a> :: &#91;&#91;<a href="QuipperLib-Arith.html#t:QDInt">QDInt</a>&#93;&#93; -&gt; &#91;<a href="QuipperLib-Arith.html#t:QDInt">QDInt</a>&#93; -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> &#91;<a href="QuipperLib-Arith.html#t:QDInt">QDInt</a>&#93; <a href="src/Algorithms/USV/Definitions.html#line-168" class="link">Source</a> <a href="#v:q_matrix_mult" class="selflink">#</a></p><div class="doc"><p>Quantum version of <code><a href="Algorithms-USV-Definitions.html#v:matrix_mult">matrix_mult</a></code>.</p></div></div><div class="top"><p class="src"><a id="v:is_zero_vector" class="def">is_zero_vector</a> :: &#91;<a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Prelude.html#t:Integer">Integer</a>&#93; -&gt; <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Bool.html#t:Bool">Bool</a> <a href="src/Algorithms/USV/Definitions.html#line-178" class="link">Source</a> <a href="#v:is_zero_vector" class="selflink">#</a></p><div class="doc"><p>Check whether a vector is 0.</p></div></div><h1 id="g:4">Euclid's algorithm</h1><div class="top"><p class="src"><a id="v:ext_euclid" class="def">ext_euclid</a> :: <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Prelude.html#t:Integer">Integer</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Prelude.html#t:Integer">Integer</a> -&gt; (<a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Prelude.html#t:Integer">Integer</a>, <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Prelude.html#t:Integer">Integer</a>, <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Prelude.html#t:Integer">Integer</a>, <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Prelude.html#t:Integer">Integer</a>, <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Prelude.html#t:Integer">Integer</a>) <a href="src/Algorithms/USV/Definitions.html#line-196" class="link">Source</a> <a href="#v:ext_euclid" class="selflink">#</a></p><div class="doc"><p>The extended Euclidean algorithm. <code><a href="Algorithms-USV-Definitions.html#v:ext_euclid">ext_euclid</a></code> <em>a</em> <em>b</em> returns
 (<em>x</em>, <em>y</em>, <em>z</em>, <em>w</em>, <em>d</em>) such that:</p><ul><li>0 &#8804; <em>d</em> = gcd(<em>a</em>, <em>b</em>), the greatest common divisor of <em>a</em> and
 <em>b</em>;</li><li><em>ax</em> + <em>by</em> = <em>d</em>;</li><li><em>az</em> + <em>bw</em> = 0;</li><li>the determinant <em>xw</em> - <em>yz</em> = 1.</li></ul></div></div><h1 id="g:5">Classical subroutines </h1><div class="top"><p class="src"><a id="v:lll" class="def">lll</a> :: &#91;&#91;<a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Prelude.html#t:Integer">Integer</a>&#93;&#93; -&gt; &#91;&#91;<a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Prelude.html#t:Integer">Integer</a>&#93;&#93; <a href="src/Algorithms/USV/Definitions.html#line-225" class="link">Source</a> <a href="#v:lll" class="selflink">#</a></p><div class="doc"><p>Reduce a basis using the Lenstra-Lenstra-Lov&#225;scz algorithm.</p><p>Uses the corresponding Haskell library. </p></div></div><div class="top"><p class="src"><a id="v:find_prime" class="def">find_prime</a> :: <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a> <a href="src/Algorithms/USV/Definitions.html#line-236" class="link">Source</a> <a href="#v:find_prime" class="selflink">#</a></p><div class="doc"><p>Given an integer <em>m</em>, find the smallest prime <em>p</em> such that <em>m</em> &#8804;
 <em>p</em> &#8804; 2<em>m</em>.</p><p>Uses preexisting <code><a href="http://hackage.haskell.org/package/primes-0.2.1.0/docs/Data-Numbers-Primes.html#v:isPrime">isPrime</a></code> algorithm. </p></div></div><div class="top"><p class="src"><a id="v:is_in_lattice" class="def">is_in_lattice</a> :: &#91;<a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Prelude.html#t:Integer">Integer</a>&#93; -&gt; &#91;&#91;<a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Prelude.html#t:Integer">Integer</a>&#93;&#93; -&gt; <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Bool.html#t:Bool">Bool</a> <a href="src/Algorithms/USV/Definitions.html#line-259" class="link">Source</a> <a href="#v:is_in_lattice" class="selflink">#</a></p><div class="doc"><p>Given a vector <em>u</em> and a basis <em>bb</em> = [<em>b</em><sub>0</sub>, &#8230;, 
 <em>b</em><sub><em>n</em>-1</sub>], determine whether <em>u</em> belongs to the lattice
 generated by <em>bb</em>, i.e., whether there exist integers <em>a</em><sub>0</sub>,
 &#8230;, <em>a</em><sub><em>n</em>-1</sub> such that <em>u</em> = <em>a</em><sub>0</sub><em>b</em><sub>0</sub> + &#8230; +
 <em>a</em><sub><em>n</em>-1</sub><em>b</em><sub><em>n</em>-1</sub>. </p><p>Precondition: <em>u</em> and <em>b</em><sub>0</sub>, &#8230;, <em>b</em><sub><em>n</em>-1</sub> must all be
 of the same dimension.</p><p>The algorithm proceeds as follows: first, do invertible integer
 column operations on <em>b</em><sub>0</sub>, &#8230;, <em>b</em><sub><em>n</em>-1</sub> until the top
 entries of <em>b</em><sub>1</sub>, &#8230;, <em>b</em><sub><em>n</em>-1</sub> are 0. This can be done
 efficiently by using the extended Euclidean algorithm for two
 columns at a time. Then check whether the top entry of <em>b</em><sub>0</sub>
 divides the top entry of <em>u</em>. If no, output <code><a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Bool.html#v:False">False</a></code>. Otherwise, if
 the top entry of <em>b</em><sub>0</sub> is 0, drop the top row and continue
 recursively. Otherwise, subtract an appropriate multiple of 
 <em>b</em><sub>0</sub> from <em>u</em>, drop <em>b</em><sub>0</sub>, drop the top row, and
 continue recursively. Trivial base cases occur when the number of
 rows or columns reaches 0.</p></div></div><div class="top"><p class="src"><a id="v:reduce_lattice" class="def">reduce_lattice</a> :: &#91;&#91;<a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Prelude.html#t:Integer">Integer</a>&#93;&#93; -&gt; &#91;&#91;<a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Prelude.html#t:Integer">Integer</a>&#93;&#93; <a href="src/Algorithms/USV/Definitions.html#line-277" class="link">Source</a> <a href="#v:reduce_lattice" class="selflink">#</a></p><div class="doc"><p>Given a basis <em>bb</em> = &#91;<em>b</em><sub>0</sub>, &#8230;, <em>b</em><sub><em>n</em>-1</sub>&#93;, find
 another equivalent basis whose elements are linearly independent.</p></div></div><div class="top"><p class="src"><a id="v:column_op" class="def">column_op</a> :: &#91;<a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Prelude.html#t:Integer">Integer</a>&#93; -&gt; &#91;<a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Prelude.html#t:Integer">Integer</a>&#93; -&gt; (&#91;<a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Prelude.html#t:Integer">Integer</a>&#93;, &#91;<a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Prelude.html#t:Integer">Integer</a>&#93;) <a href="src/Algorithms/USV/Definitions.html#line-288" class="link">Source</a> <a href="#v:column_op" class="selflink">#</a></p><div class="doc"><p>Perform a reversible column operation on two integer vectors,
 creating (and then dropping) a leading zero in the second vector.</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.17.3</p></div></body></html>
