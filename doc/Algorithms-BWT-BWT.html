<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Algorithms.BWT.BWT</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Algorithms-BWT-BWT.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/Algorithms/BWT/BWT.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">The Quipper System</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>None</td></tr></table><p class="caption">Algorithms.BWT.BWT</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Oracle abstraction</a></li><li><a href="#g:2">Top-level algorithm</a></li><li><a href="#g:3">Oracle implementation</a><ul><li><a href="#g:4">Oracle subroutines</a></li><li><a href="#g:5">The oracle data structure</a></li></ul></li><li><a href="#g:6">Main functions</a></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>This module provides an implementation of the main binary welded
 tree algorithm and oracle, using a more-or-less imperative
 programming style. We abstract the oracle into a data type, so that
 different oracles can be plugged into the main algorithm.</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><span class="keyword">data</span> <a href="#t:Oracle">Oracle</a> = <a href="#v:Oracle">Oracle</a> {<ul class="subs"><li><a href="#v:n">n</a> :: <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a></li><li><a href="#v:m">m</a> :: <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a></li><li><a href="#v:k">k</a> :: <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a></li><li><a href="#v:entrance">entrance</a> :: <a href="Libraries-Auxiliary.html#t:Boollist">Boollist</a></li><li><a href="#v:oraclefun">oraclefun</a> :: <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a> -&gt; (<a href="QuipperLib-Qureg.html#t:Qureg">Qureg</a>, <a href="QuipperLib-Qureg.html#t:Qureg">Qureg</a>, <a href="Quipper-Monad.html#t:Qubit">Qubit</a>) -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> ()</li></ul>}</li><li class="src short"><a href="#v:qrwbwt">qrwbwt</a> :: <a href="Algorithms-BWT-BWT.html#t:Oracle">Oracle</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a> -&gt; <a href="Quipper-Circuit.html#t:Timestep">Timestep</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> &#91;<a href="Quipper-Monad.html#t:Bit">Bit</a>&#93;</li><li class="src short"><a href="#v:timestep">timestep</a> :: (<a href="QuipperLib-Qureg.html#t:Qureg">Qureg</a>, <a href="QuipperLib-Qureg.html#t:Qureg">Qureg</a>, <a href="Quipper-Monad.html#t:Qubit">Qubit</a>, <a href="Quipper-Circuit.html#t:Timestep">Timestep</a>, <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a>) -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> ()</li><li class="src short"><a href="#v:oracle">oracle</a> :: (<a href="QuipperLib-Qureg.html#t:Qureg">Qureg</a>, <a href="QuipperLib-Qureg.html#t:Qureg">Qureg</a>, <a href="Quipper-Monad.html#t:Qubit">Qubit</a>, <a href="QuipperLib-Qureg.html#t:Boolreg">Boolreg</a>, <a href="QuipperLib-Qureg.html#t:Boolreg">Boolreg</a>, <a href="QuipperLib-Qureg.html#t:Boolreg">Boolreg</a>, <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a>) -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> ()</li><li class="src short"><a href="#v:parseNodeRoot">parseNodeRoot</a> :: (<a href="QuipperLib-Qureg.html#t:Qureg">Qureg</a>, <a href="Quipper-Monad.html#t:Qubit">Qubit</a>, <a href="Quipper-Monad.html#t:Qubit">Qubit</a>, <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a>) -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> ()</li><li class="src short"><a href="#v:parseNodeEven">parseNodeEven</a> :: (<a href="QuipperLib-Qureg.html#t:Qureg">Qureg</a>, <a href="Quipper-Monad.html#t:Qubit">Qubit</a>, <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a>) -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> ()</li><li class="src short"><a href="#v:testIsParent">testIsParent</a> :: (<a href="QuipperLib-Qureg.html#t:Qureg">Qureg</a>, <a href="Quipper-Monad.html#t:Qubit">Qubit</a>, <a href="Quipper-Monad.html#t:Qubit">Qubit</a>, <a href="Quipper-Monad.html#t:Qubit">Qubit</a>, <a href="QuipperLib-Qureg.html#t:Boolreg">Boolreg</a>, <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a>, <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a>, <a href="Quipper-Monad.html#t:Qubit">Qubit</a>) -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> ()</li><li class="src short"><a href="#v:testIsChild">testIsChild</a> :: (<a href="Quipper-Monad.html#t:Qubit">Qubit</a>, <a href="Quipper-Monad.html#t:Qubit">Qubit</a>, <a href="Quipper-Monad.html#t:Qubit">Qubit</a>, <a href="QuipperLib-Qureg.html#t:Boolreg">Boolreg</a>, <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a>) -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> ()</li><li class="src short"><a href="#v:setParent">setParent</a> :: (<a href="QuipperLib-Qureg.html#t:Qureg">Qureg</a>, <a href="QuipperLib-Qureg.html#t:Qureg">Qureg</a>, <a href="Quipper-Monad.html#t:Qubit">Qubit</a>, <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a>) -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> ()</li><li class="src short"><a href="#v:setChild">setChild</a> :: (<a href="QuipperLib-Qureg.html#t:Qureg">Qureg</a>, <a href="QuipperLib-Qureg.html#t:Qureg">Qureg</a>, <a href="Quipper-Monad.html#t:Qubit">Qubit</a>, <a href="Quipper-Monad.html#t:Qubit">Qubit</a>, <a href="QuipperLib-Qureg.html#t:Boolreg">Boolreg</a>, <a href="QuipperLib-Qureg.html#t:Boolreg">Boolreg</a>, <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a>) -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> ()</li><li class="src short"><a href="#v:setChildInTree">setChildInTree</a> :: (<a href="QuipperLib-Qureg.html#t:Qureg">Qureg</a>, <a href="QuipperLib-Qureg.html#t:Qureg">Qureg</a>, <a href="Quipper-Monad.html#t:Qubit">Qubit</a>, <a href="Quipper-Monad.html#t:Qubit">Qubit</a>, <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a>) -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> ()</li><li class="src short"><a href="#v:setWeld">setWeld</a> :: (<a href="QuipperLib-Qureg.html#t:Qureg">Qureg</a>, <a href="QuipperLib-Qureg.html#t:Qureg">Qureg</a>, <a href="Quipper-Monad.html#t:Qubit">Qubit</a>, <a href="Quipper-Monad.html#t:Qubit">Qubit</a>, <a href="QuipperLib-Qureg.html#t:Boolreg">Boolreg</a>, <a href="QuipperLib-Qureg.html#t:Boolreg">Boolreg</a>, <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a>) -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> ()</li><li class="src short"><a href="#v:doWeld1">doWeld1</a> :: (<a href="QuipperLib-Qureg.html#t:Qureg">Qureg</a>, <a href="QuipperLib-Qureg.html#t:Qureg">Qureg</a>, <a href="Quipper-Monad.html#t:Qubit">Qubit</a>, <a href="QuipperLib-Qureg.html#t:Boolreg">Boolreg</a>, <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a>) -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> ()</li><li class="src short"><a href="#v:doWeld0">doWeld0</a> :: (<a href="QuipperLib-Qureg.html#t:Qureg">Qureg</a>, <a href="QuipperLib-Qureg.html#t:Qureg">Qureg</a>, <a href="Quipper-Monad.html#t:Qubit">Qubit</a>, <a href="QuipperLib-Qureg.html#t:Boolreg">Boolreg</a>, <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a>) -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> ()</li><li class="src short"><a href="#v:cAddNum">cAddNum</a> :: (<a href="Quipper-Monad.html#t:Qubit">Qubit</a>, <a href="QuipperLib-Qureg.html#t:Qureg">Qureg</a>, <a href="QuipperLib-Qureg.html#t:Qureg">Qureg</a>, <a href="QuipperLib-Qureg.html#t:Boolreg">Boolreg</a>, <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a>) -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> ()</li><li class="src short"><a href="#v:cAddNumClear">cAddNumClear</a> :: (<a href="Quipper-Monad.html#t:Qubit">Qubit</a>, <a href="QuipperLib-Qureg.html#t:Qureg">Qureg</a>, <a href="QuipperLib-Qureg.html#t:Qureg">Qureg</a>, <a href="QuipperLib-Qureg.html#t:Boolreg">Boolreg</a>, <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a>) -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> ()</li><li class="src short"><a href="#v:cSubNum">cSubNum</a> :: (<a href="Quipper-Monad.html#t:Qubit">Qubit</a>, <a href="QuipperLib-Qureg.html#t:Qureg">Qureg</a>, <a href="QuipperLib-Qureg.html#t:Qureg">Qureg</a>, <a href="QuipperLib-Qureg.html#t:Boolreg">Boolreg</a>, <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a>) -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> ()</li><li class="src short"><a href="#v:cSubNumClear">cSubNumClear</a> :: (<a href="Quipper-Monad.html#t:Qubit">Qubit</a>, <a href="QuipperLib-Qureg.html#t:Qureg">Qureg</a>, <a href="QuipperLib-Qureg.html#t:Qureg">Qureg</a>, <a href="QuipperLib-Qureg.html#t:Boolreg">Boolreg</a>, <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a>) -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> ()</li><li class="src short"><a href="#v:oracle_orthodox">oracle_orthodox</a> :: <a href="Libraries-Auxiliary.html#t:Boollist">Boollist</a> -&gt; <a href="Libraries-Auxiliary.html#t:Boollist">Boollist</a> -&gt; <a href="Algorithms-BWT-BWT.html#t:Oracle">Oracle</a></li><li class="src short"><a href="#v:main_circuit">main_circuit</a> :: <a href="Quipper-Printing.html#t:Format">Format</a> -&gt; <a href="QuipperLib-Decompose-GateBase.html#t:GateBase">GateBase</a> -&gt; <a href="Algorithms-BWT-BWT.html#t:Oracle">Oracle</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a> -&gt; <a href="Quipper-Circuit.html#t:Timestep">Timestep</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/System-IO.html#t:IO">IO</a> ()</li><li class="src short"><a href="#v:main_oracle">main_oracle</a> :: <a href="Quipper-Printing.html#t:Format">Format</a> -&gt; <a href="QuipperLib-Decompose-GateBase.html#t:GateBase">GateBase</a> -&gt; <a href="Algorithms-BWT-BWT.html#t:Oracle">Oracle</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/System-IO.html#t:IO">IO</a> ()</li></ul></div><div id="interface"><h1 id="g:1">Oracle abstraction</h1><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:Oracle" class="def">Oracle</a> <a href="src/Algorithms/BWT/BWT.html#line-41" class="link">Source</a> <a href="#t:Oracle" class="selflink">#</a></p><div class="doc"><p>A data structure to hold an oracle. The binary welded tree
 algorithm is parametric on an oracle. An oracle encodes a graph,
 and provides the following information: the tree depth <em>n</em> (in the
 above example: 3), the label length <em>m</em> (in bits; 5 in the above
 example), the number of edge colors <em>k</em>, the entrance label
 <em>ENTRANCE</em>, and for each color 0 &#8804; <em>c</em> &lt; <em>k</em>, a reversible circuit
 <em>ORACLE</em><a href="/a/,/b/,/r/">sub /c/</a>. On basis vectors, this circuit
 encodes the edge information in the following sense:</p><pre>ORACLE<sub>c</sub>(a, b, r) = (a, b &amp;#8853; v<sub>c</sub>(a), r &amp;#8853; f<sub>c</sub>(a)),</pre><p>where <em>f</em><a href="/a/">sub /c/</a> is 1 if the node <em>a</em> is connected to an
 edge of color <em>c</em>, and 0 otherwise; and <em>v</em><a href="a">sub /c/</a> is the
 node label connected to node <em>a</em> along an edge of color <em>c</em> (if
 any), and arbitrary otherwise. </p><p>Not all available node labels need to be used (for example, 0 and
 16 are unused in the graph in the above illustration).</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a id="v:Oracle" class="def">Oracle</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><ul><li><dfn class="src"><a id="v:n" class="def">n</a> :: <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a></dfn><div class="doc empty">&nbsp;</div></li><li><dfn class="src"><a id="v:m" class="def">m</a> :: <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a></dfn><div class="doc empty">&nbsp;</div></li><li><dfn class="src"><a id="v:k" class="def">k</a> :: <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a></dfn><div class="doc empty">&nbsp;</div></li><li><dfn class="src"><a id="v:entrance" class="def">entrance</a> :: <a href="Libraries-Auxiliary.html#t:Boollist">Boollist</a></dfn><div class="doc empty">&nbsp;</div></li><li><dfn class="src"><a id="v:oraclefun" class="def">oraclefun</a> :: <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a> -&gt; (<a href="QuipperLib-Qureg.html#t:Qureg">Qureg</a>, <a href="QuipperLib-Qureg.html#t:Qureg">Qureg</a>, <a href="Quipper-Monad.html#t:Qubit">Qubit</a>) -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> ()</dfn><div class="doc empty">&nbsp;</div></li></ul></div></td></tr></table></div></div><h1 id="g:2">Top-level algorithm</h1><div class="top"><p class="src"><a id="v:qrwbwt" class="def">qrwbwt</a> :: <a href="Algorithms-BWT-BWT.html#t:Oracle">Oracle</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a> -&gt; <a href="Quipper-Circuit.html#t:Timestep">Timestep</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> &#91;<a href="Quipper-Monad.html#t:Bit">Bit</a>&#93; <a href="src/Algorithms/BWT/BWT.html#line-59" class="link">Source</a> <a href="#v:qrwbwt" class="selflink">#</a></p><div class="doc"><p>The main loop of the binary welded tree algorithm. </p><p><code>qrwbwt oracle s dt</code>: Do a quantum random walk on the binary welded
 tree given by the oracle <em>oracle</em>, for <em>s</em> times steps of length
 <em>dt</em>. Returns a bit list corresponding to the computed exit node
 label.</p></div></div><div class="top"><p class="src"><a id="v:timestep" class="def">timestep</a> :: (<a href="QuipperLib-Qureg.html#t:Qureg">Qureg</a>, <a href="QuipperLib-Qureg.html#t:Qureg">Qureg</a>, <a href="Quipper-Monad.html#t:Qubit">Qubit</a>, <a href="Quipper-Circuit.html#t:Timestep">Timestep</a>, <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a>) -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> () <a href="src/Algorithms/BWT/BWT.html#line-86" class="link">Source</a> <a href="#v:timestep" class="selflink">#</a></p><div class="doc"><p><code>timestep (a, b, r, dt, m)</code>: Perform a single time step <em>dt</em> of
 the quantum walk. This is done by iterating through each of the
 available edge colors, and performing a diffusion step for each
 color. Here, <em>a</em> is an <em>m</em>-qubit registers holding (a superposition
 of) the current node label. <em>b</em> is an <em>m</em>-qubit ancilla register,
 and <em>r</em> is an ancilla qubit. Both <em>b</em> and <em>r</em> are expected to be
 initialized to |0&#9002; by the caller, and will be returned in state
 |0&#9002;.</p></div></div><h1 id="g:3">Oracle implementation</h1><div class="doc"><p>The functions in this section implement a particular oracle for a
 binary welded tree. The oracle is parametric on:</p><ul><li>the tree depth <em>n</em>;</li><li>two &quot;welding vectors&quot; <em>f</em> and <em>g</em>, specifying how the leaves of
 the two binary trees are connected to each other. Specifically, <em>f</em>
 and <em>g</em> encode the permutations of leaves given by a &#8614; a &#8853; f and 
 a &#8614; a + g, respectively, where &quot;&#8853;&quot; denotes bitwise exclusive or,
 and &quot;+&quot; denotes binary addition.</li></ul></div><h2 id="g:4">Oracle subroutines</h2><div class="top"><p class="src"><a id="v:oracle" class="def">oracle</a> :: (<a href="QuipperLib-Qureg.html#t:Qureg">Qureg</a>, <a href="QuipperLib-Qureg.html#t:Qureg">Qureg</a>, <a href="Quipper-Monad.html#t:Qubit">Qubit</a>, <a href="QuipperLib-Qureg.html#t:Boolreg">Boolreg</a>, <a href="QuipperLib-Qureg.html#t:Boolreg">Boolreg</a>, <a href="QuipperLib-Qureg.html#t:Boolreg">Boolreg</a>, <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a>) -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> () <a href="src/Algorithms/BWT/BWT.html#line-127" class="link">Source</a> <a href="#v:oracle" class="selflink">#</a></p><div class="doc"><p>The top-level oracle circuit. The arguments are of the form (<em>a</em>,
 <em>b</em>, <em>r</em>, <em>color</em>, <em>f</em>, <em>g</em>, <em>n</em>), where <em>a</em>, <em>b</em> are quantum
 registers of length <em>n</em>+2, <em>color</em> is a boolean register of length
 2, and <em>f</em> and <em>g</em> are boolean registers of length <em>n</em>.</p></div></div><div class="top"><p class="src"><a id="v:parseNodeRoot" class="def">parseNodeRoot</a> :: (<a href="QuipperLib-Qureg.html#t:Qureg">Qureg</a>, <a href="Quipper-Monad.html#t:Qubit">Qubit</a>, <a href="Quipper-Monad.html#t:Qubit">Qubit</a>, <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a>) -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> () <a href="src/Algorithms/BWT/BWT.html#line-155" class="link">Source</a> <a href="#v:parseNodeRoot" class="selflink">#</a></p><div class="doc"><p>Input a node label <em>a</em> of length at least <em>n</em>+1. Negate both
 <em>root</em> and <em>even</em> if <em>a</em> is a root node.</p></div></div><div class="top"><p class="src"><a id="v:parseNodeEven" class="def">parseNodeEven</a> :: (<a href="QuipperLib-Qureg.html#t:Qureg">Qureg</a>, <a href="Quipper-Monad.html#t:Qubit">Qubit</a>, <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a>) -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> () <a href="src/Algorithms/BWT/BWT.html#line-184" class="link">Source</a> <a href="#v:parseNodeEven" class="selflink">#</a></p><div class="doc"><p>Input a node label <em>a</em> of length at least <em>n</em>+1. Negate <em>even</em>
 if the node <em>a</em> occurs at an even height in the tree.</p></div></div><div class="top"><p class="src"><a id="v:testIsParent" class="def">testIsParent</a> :: (<a href="QuipperLib-Qureg.html#t:Qureg">Qureg</a>, <a href="Quipper-Monad.html#t:Qubit">Qubit</a>, <a href="Quipper-Monad.html#t:Qubit">Qubit</a>, <a href="Quipper-Monad.html#t:Qubit">Qubit</a>, <a href="QuipperLib-Qureg.html#t:Boolreg">Boolreg</a>, <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a>, <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a>, <a href="Quipper-Monad.html#t:Qubit">Qubit</a>) -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> () <a href="src/Algorithms/BWT/BWT.html#line-223" class="link">Source</a> <a href="#v:testIsParent" class="selflink">#</a></p><div class="doc"><p>Input a node label <em>a</em> of length at least 1, and flags <em>root</em>
 and <em>even</em> describing whether <em>a</em> is a root and at an even level,
 respectively. Negate <em>isparent</em> if <em>a</em> has a parent of color
 <em>color</em> in the tree. </p><p>The qubit <em>ismatch</em> is an ancilla, and <em>really</em> is either 0 or
 1. They are jointly used to control uncomputation, so that the
 following sequence will compute and then uncompute <code><a href="Algorithms-BWT-BWT.html#v:testIsParent">testIsParent</a></code>:</p><pre>ismatch &lt;- qinit 0
testIsParent (a, root, even, isparent, color, n, 1, ismatch)
testIsParent (a, root, even, isparent, color, n, 0, ismatch)
qterm 0 ismatch</pre></div></div><div class="top"><p class="src"><a id="v:testIsChild" class="def">testIsChild</a> :: (<a href="Quipper-Monad.html#t:Qubit">Qubit</a>, <a href="Quipper-Monad.html#t:Qubit">Qubit</a>, <a href="Quipper-Monad.html#t:Qubit">Qubit</a>, <a href="QuipperLib-Qureg.html#t:Boolreg">Boolreg</a>, <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a>) -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> () <a href="src/Algorithms/BWT/BWT.html#line-261" class="link">Source</a> <a href="#v:testIsChild" class="selflink">#</a></p><div class="doc"><p>Consider a node <em>a</em>, and negate <em>ischild</em> if <em>a</em> has a child
 node of color <em>color</em>. Also set <em>direction</em> to indicate whether
 it is a &quot;left&quot; or &quot;right&quot; child. Here, <em>color</em> is a boolean
 register of length 2, representing a color. This function is
 self-inverse.</p></div></div><div class="top"><p class="src"><a id="v:setParent" class="def">setParent</a> :: (<a href="QuipperLib-Qureg.html#t:Qureg">Qureg</a>, <a href="QuipperLib-Qureg.html#t:Qureg">Qureg</a>, <a href="Quipper-Monad.html#t:Qubit">Qubit</a>, <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a>) -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> () <a href="src/Algorithms/BWT/BWT.html#line-283" class="link">Source</a> <a href="#v:setParent" class="selflink">#</a></p><div class="doc"><p>Input a node label <em>a</em> of length at least <em>n</em>+2, and a flag
 <em>isparent</em> that has been initialized accordingly. Also input a
 register <em>b</em> of length at least <em>n</em>+2, initialized to |0&#9002;.  If
 <em>isparent</em> is set, set <em>b</em> to the node label of the parent of
 <em>a</em>. This is self-inverse.</p></div></div><div class="top"><p class="src"><a id="v:setChild" class="def">setChild</a> :: (<a href="QuipperLib-Qureg.html#t:Qureg">Qureg</a>, <a href="QuipperLib-Qureg.html#t:Qureg">Qureg</a>, <a href="Quipper-Monad.html#t:Qubit">Qubit</a>, <a href="Quipper-Monad.html#t:Qubit">Qubit</a>, <a href="QuipperLib-Qureg.html#t:Boolreg">Boolreg</a>, <a href="QuipperLib-Qureg.html#t:Boolreg">Boolreg</a>, <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a>) -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> () <a href="src/Algorithms/BWT/BWT.html#line-301" class="link">Source</a> <a href="#v:setChild" class="selflink">#</a></p><div class="doc"><p>Similar to <code><a href="Algorithms-BWT-BWT.html#v:setParent">setParent</a></code>, but set <em>b</em> to the node label of the
 indicated child of <em>a</em>. Here <em>a</em> and <em>b</em> are quantum registers of
 length at least <em>n</em>+2, and <em>f</em> and <em>g</em> are boolean registers of
 length <em>n</em>.</p></div></div><div class="top"><p class="src"><a id="v:setChildInTree" class="def">setChildInTree</a> :: (<a href="QuipperLib-Qureg.html#t:Qureg">Qureg</a>, <a href="QuipperLib-Qureg.html#t:Qureg">Qureg</a>, <a href="Quipper-Monad.html#t:Qubit">Qubit</a>, <a href="Quipper-Monad.html#t:Qubit">Qubit</a>, <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a>) -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> () <a href="src/Algorithms/BWT/BWT.html#line-321" class="link">Source</a> <a href="#v:setChildInTree" class="selflink">#</a></p><div class="doc"><p>A special case of <code><a href="Algorithms-BWT-BWT.html#v:setChild">setChild</a></code>, where the child is inside the same
 binary tree (i.e., not via the welding). </p></div></div><div class="top"><p class="src"><a id="v:setWeld" class="def">setWeld</a> :: (<a href="QuipperLib-Qureg.html#t:Qureg">Qureg</a>, <a href="QuipperLib-Qureg.html#t:Qureg">Qureg</a>, <a href="Quipper-Monad.html#t:Qubit">Qubit</a>, <a href="Quipper-Monad.html#t:Qubit">Qubit</a>, <a href="QuipperLib-Qureg.html#t:Boolreg">Boolreg</a>, <a href="QuipperLib-Qureg.html#t:Boolreg">Boolreg</a>, <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a>) -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> () <a href="src/Algorithms/BWT/BWT.html#line-340" class="link">Source</a> <a href="#v:setWeld" class="selflink">#</a></p><div class="doc"><p>A special case of <code><a href="Algorithms-BWT-BWT.html#v:setChild">setChild</a></code>, where the child is in the opposite
 binary tree, i.e., we follow one of the welding edges.</p></div></div><div class="top"><p class="src"><a id="v:doWeld1" class="def">doWeld1</a> :: (<a href="QuipperLib-Qureg.html#t:Qureg">Qureg</a>, <a href="QuipperLib-Qureg.html#t:Qureg">Qureg</a>, <a href="Quipper-Monad.html#t:Qubit">Qubit</a>, <a href="QuipperLib-Qureg.html#t:Boolreg">Boolreg</a>, <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a>) -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> () <a href="src/Algorithms/BWT/BWT.html#line-370" class="link">Source</a> <a href="#v:doWeld1" class="selflink">#</a></p><div class="doc"><p>Input a node label <em>a</em>, and a register <em>b</em> initialized to
 |0&#9002;. If <em>weldctrl</em> is set, set <em>b</em> to the node connected to <em>a</em>
 by the welding function <em>f</em>. This is self-inverse. Here, <em>a</em> and
 <em>b</em> are quantum registers of length at least <em>n</em>+2, and <em>f</em> is a
 boolean register of length <em>n</em>.</p></div></div><div class="top"><p class="src"><a id="v:doWeld0" class="def">doWeld0</a> :: (<a href="QuipperLib-Qureg.html#t:Qureg">Qureg</a>, <a href="QuipperLib-Qureg.html#t:Qureg">Qureg</a>, <a href="Quipper-Monad.html#t:Qubit">Qubit</a>, <a href="QuipperLib-Qureg.html#t:Boolreg">Boolreg</a>, <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a>) -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> () <a href="src/Algorithms/BWT/BWT.html#line-393" class="link">Source</a> <a href="#v:doWeld0" class="selflink">#</a></p><div class="doc"><p>Input a node label <em>a</em>, and a register <em>b</em> initialized to
 |0&#9002;. If <em>weldctrl</em> is set, set <em>b</em> to the node connected to <em>a</em>
 by the welding function <em>g</em>. This is self-inverse. Here, <em>a</em> and
 <em>b</em> are quantum registers of length at least <em>n</em>+2, and <em>g</em> is a
 boolean register of length <em>n</em>.</p></div></div><div class="top"><p class="src"><a id="v:cAddNum" class="def">cAddNum</a> :: (<a href="Quipper-Monad.html#t:Qubit">Qubit</a>, <a href="QuipperLib-Qureg.html#t:Qureg">Qureg</a>, <a href="QuipperLib-Qureg.html#t:Qureg">Qureg</a>, <a href="QuipperLib-Qureg.html#t:Boolreg">Boolreg</a>, <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a>) -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> () <a href="src/Algorithms/BWT/BWT.html#line-410" class="link">Source</a> <a href="#v:cAddNum" class="selflink">#</a></p><div class="doc"><p>This function implements integer addition. Input a quantum
 register <em>input</em> and a boolean register <em>num</em>, representing
 integers, and a quantum register <em>out</em> initialized to |0&#9002;. If
 <em>control</em> is set, set <em>out</em> to <em>input</em> + <em>num</em>, otherwise do
 nothing.  Here <em>input</em> and <em>out</em> are quantum registers of length at
 least <em>n</em>, <em>num</em> is a boolean register of length <em>n</em>.</p></div></div><div class="top"><p class="src"><a id="v:cAddNumClear" class="def">cAddNumClear</a> :: (<a href="Quipper-Monad.html#t:Qubit">Qubit</a>, <a href="QuipperLib-Qureg.html#t:Qureg">Qureg</a>, <a href="QuipperLib-Qureg.html#t:Qureg">Qureg</a>, <a href="QuipperLib-Qureg.html#t:Boolreg">Boolreg</a>, <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a>) -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> () <a href="src/Algorithms/BWT/BWT.html#line-453" class="link">Source</a> <a href="#v:cAddNumClear" class="selflink">#</a></p><div class="doc"><p>A helper function for clearing the scratch space used by <code><a href="Algorithms-BWT-BWT.html#v:cAddNum">cAddNum</a></code>.</p></div></div><div class="top"><p class="src"><a id="v:cSubNum" class="def">cSubNum</a> :: (<a href="Quipper-Monad.html#t:Qubit">Qubit</a>, <a href="QuipperLib-Qureg.html#t:Qureg">Qureg</a>, <a href="QuipperLib-Qureg.html#t:Qureg">Qureg</a>, <a href="QuipperLib-Qureg.html#t:Boolreg">Boolreg</a>, <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a>) -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> () <a href="src/Algorithms/BWT/BWT.html#line-477" class="link">Source</a> <a href="#v:cSubNum" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Algorithms-BWT-BWT.html#v:cAddNum">cAddNum</a></code>, except subtract instead of adding. </p></div></div><div class="top"><p class="src"><a id="v:cSubNumClear" class="def">cSubNumClear</a> :: (<a href="Quipper-Monad.html#t:Qubit">Qubit</a>, <a href="QuipperLib-Qureg.html#t:Qureg">Qureg</a>, <a href="QuipperLib-Qureg.html#t:Qureg">Qureg</a>, <a href="QuipperLib-Qureg.html#t:Boolreg">Boolreg</a>, <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a>) -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> () <a href="src/Algorithms/BWT/BWT.html#line-520" class="link">Source</a> <a href="#v:cSubNumClear" class="selflink">#</a></p><div class="doc"><p>A helper function for clearing the scratch space used by <code><a href="Algorithms-BWT-BWT.html#v:cSubNum">cSubNum</a></code>.</p></div></div><h2 id="g:5">The oracle data structure</h2><div class="top"><p class="src"><a id="v:oracle_orthodox" class="def">oracle_orthodox</a> :: <a href="Libraries-Auxiliary.html#t:Boollist">Boollist</a> -&gt; <a href="Libraries-Auxiliary.html#t:Boollist">Boollist</a> -&gt; <a href="Algorithms-BWT-BWT.html#t:Oracle">Oracle</a> <a href="src/Algorithms/BWT/BWT.html#line-554" class="link">Source</a> <a href="#v:oracle_orthodox" class="selflink">#</a></p><div class="doc"><p>This function inputs two welding functions <em>f</em> and <em>g</em>, and
 returns the oracle defined by the preceding functions. </p><p>We call this the &quot;orthodox&quot; oracle, because the implementation
 follows its specification very closely. For example, it uses a very
 &quot;imperative&quot; programming style. For alternative implementations
 of this and other oracles, see the modules
 <a href="Algorithms-BWT-Alternative.html">Algorithms.BWT.Alternative</a> and <a href="Algorithms-BWT-Template.html">Algorithms.BWT.Template</a>.</p></div></div><h1 id="g:6">Main functions</h1><div class="top"><p class="src"><a id="v:main_circuit" class="def">main_circuit</a> :: <a href="Quipper-Printing.html#t:Format">Format</a> -&gt; <a href="QuipperLib-Decompose-GateBase.html#t:GateBase">GateBase</a> -&gt; <a href="Algorithms-BWT-BWT.html#t:Oracle">Oracle</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a> -&gt; <a href="Quipper-Circuit.html#t:Timestep">Timestep</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/System-IO.html#t:IO">IO</a> () <a href="src/Algorithms/BWT/BWT.html#line-583" class="link">Source</a> <a href="#v:main_circuit" class="selflink">#</a></p><div class="doc"><p>Output the circuit for the quantum walk and a binary welded tree,
 for the given <code><a href="Algorithms-BWT-BWT.html#t:Oracle">Oracle</a></code> in the specified <code><a href="Quipper-Printing.html#t:Format">Format</a></code> and using the
 specified <code><a href="QuipperLib-Decompose-GateBase.html#t:GateBase">GateBase</a></code>. Use <em>s</em> time steps of length <em>dt</em>.</p></div></div><div class="top"><p class="src"><a id="v:main_oracle" class="def">main_oracle</a> :: <a href="Quipper-Printing.html#t:Format">Format</a> -&gt; <a href="QuipperLib-Decompose-GateBase.html#t:GateBase">GateBase</a> -&gt; <a href="Algorithms-BWT-BWT.html#t:Oracle">Oracle</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/System-IO.html#t:IO">IO</a> () <a href="src/Algorithms/BWT/BWT.html#line-592" class="link">Source</a> <a href="#v:main_oracle" class="selflink">#</a></p><div class="doc"><p>Output the circuit for the given <code><a href="Algorithms-BWT-BWT.html#t:Oracle">Oracle</a></code> and the given color
 (specified as an <code><a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a></code>). Use the specified output <code><a href="Quipper-Printing.html#t:Format">Format</a></code> and
 <code><a href="QuipperLib-Decompose-GateBase.html#t:GateBase">GateBase</a></code>.</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.17.3</p></div></body></html>
