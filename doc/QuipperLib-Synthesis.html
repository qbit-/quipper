<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>QuipperLib.Synthesis</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_QuipperLib-Synthesis.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/QuipperLib/Synthesis.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">The Quipper System</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>None</td></tr></table><p class="caption">QuipperLib.Synthesis</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Precision</a></li><li><a href="#g:2">Phase</a></li><li><a href="#g:3">Auxiliary functions</a></li><li><a href="#g:4">Single-qubit exact synthesis</a></li><li><a href="#g:5">Multi-qubit exact synthesis</a></li><li><a href="#g:6">Single-qubit approximate synthesis</a><ul><li><a href="#g:7"><em>z</em>-Rotations</a></li><li><a href="#g:8">Global phase gates</a></li><li><a href="#g:9"><em>U</em>(2) from Euler angles</a></li><li><a href="#g:10"><em>U</em>(2) from matrix</a></li><li><a href="#g:11">Controlled gates</a></li></ul></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>A Quipper library for synthesizing Clifford+<em>T</em> circuits directly
 from a matrix description or Euler angle description of a unitary
 operator. This library provides both exact and approximate
 synthesis.</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><span class="keyword">type</span> <a href="#t:Precision">Precision</a> = <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Prelude.html#t:Double">Double</a></li><li class="src short"><a href="#v:bits">bits</a> :: <a href="QuipperLib-Synthesis.html#t:Precision">Precision</a></li><li class="src short"><a href="#v:digits">digits</a> :: <a href="QuipperLib-Synthesis.html#t:Precision">Precision</a></li><li class="src short"><span class="keyword">type</span> <a href="#t:KeepPhase">KeepPhase</a> = <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Bool.html#t:Bool">Bool</a></li><li class="src short"><a href="#v:apply_gate_at">apply_gate_at</a> :: <a href="http://hackage.haskell.org/package/fixedprec-0.3.0.2/docs/Quantum-Synthesis-CliffordT.html#t:Gate">Gate</a> -&gt; <a href="Quipper-Monad.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> ()</li><li class="src short"><a href="#v:apply_gates_at">apply_gates_at</a> :: &#91;<a href="http://hackage.haskell.org/package/fixedprec-0.3.0.2/docs/Quantum-Synthesis-CliffordT.html#t:Gate">Gate</a>&#93; -&gt; <a href="Quipper-Monad.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> ()</li><li class="src short"><a href="#v:apply_gates2_at">apply_gates2_at</a> :: &#91;<a href="http://hackage.haskell.org/package/fixedprec-0.3.0.2/docs/Quantum-Synthesis-CliffordT.html#t:Gate">Gate</a>&#93; -&gt; <a href="Quipper-Monad.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper-Monad.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> ()</li><li class="src short"><a href="#v:twolevel">twolevel</a> :: <a href="http://hackage.haskell.org/package/fixedprec-0.3.0.2/docs/Quantum-Synthesis-MultiQubitSynthesis.html#t:Index">Index</a> -&gt; <a href="http://hackage.haskell.org/package/fixedprec-0.3.0.2/docs/Quantum-Synthesis-MultiQubitSynthesis.html#t:Index">Index</a> -&gt; &#91;<a href="Quipper-Monad.html#t:Qubit">Qubit</a>&#93; -&gt; (<a href="Quipper-Monad.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> ()) -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> ()</li><li class="src short"><a href="#v:gate_T_power_at">gate_T_power_at</a> :: <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a> -&gt; <a href="Quipper-Monad.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> ()</li><li class="src short"><a href="#v:apply_twolevel_at">apply_twolevel_at</a> :: <a href="http://hackage.haskell.org/package/fixedprec-0.3.0.2/docs/Quantum-Synthesis-MultiQubitSynthesis.html#t:TwoLevel">TwoLevel</a> -&gt; &#91;<a href="Quipper-Monad.html#t:Qubit">Qubit</a>&#93; -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> ()</li><li class="src short"><a href="#v:apply_twolevels_at">apply_twolevels_at</a> :: &#91;<a href="http://hackage.haskell.org/package/fixedprec-0.3.0.2/docs/Quantum-Synthesis-MultiQubitSynthesis.html#t:TwoLevel">TwoLevel</a>&#93; -&gt; &#91;<a href="Quipper-Monad.html#t:Qubit">Qubit</a>&#93; -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> ()</li><li class="src short"><a href="#v:apply_twolevel_alt_at">apply_twolevel_alt_at</a> :: <a href="http://hackage.haskell.org/package/fixedprec-0.3.0.2/docs/Quantum-Synthesis-MultiQubitSynthesis.html#t:TwoLevelAlt">TwoLevelAlt</a> -&gt; &#91;<a href="Quipper-Monad.html#t:Qubit">Qubit</a>&#93; -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> ()</li><li class="src short"><a href="#v:apply_twolevels_alt_at">apply_twolevels_alt_at</a> :: &#91;<a href="http://hackage.haskell.org/package/fixedprec-0.3.0.2/docs/Quantum-Synthesis-MultiQubitSynthesis.html#t:TwoLevelAlt">TwoLevelAlt</a>&#93; -&gt; &#91;<a href="Quipper-Monad.html#t:Qubit">Qubit</a>&#93; -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> ()</li><li class="src short"><a href="#v:exact_synthesis1">exact_synthesis1</a> :: <a href="http://hackage.haskell.org/package/fixedprec-0.3.0.2/docs/Quantum-Synthesis-CliffordT.html#t:ToGates">ToGates</a> a =&gt; a -&gt; <a href="Quipper-Monad.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a></li><li class="src short"><a href="#v:exact_synthesis">exact_synthesis</a> :: (<a href="http://hackage.haskell.org/package/fixedprec-0.3.0.2/docs/Quantum-Synthesis-Ring.html#t:ToQOmega">ToQOmega</a> a, <a href="http://hackage.haskell.org/package/fixedprec-0.3.0.2/docs/Quantum-Synthesis-Matrix.html#t:Nat">Nat</a> n) =&gt; <a href="http://hackage.haskell.org/package/fixedprec-0.3.0.2/docs/Quantum-Synthesis-Matrix.html#t:Matrix">Matrix</a> n n a -&gt; &#91;<a href="Quipper-Monad.html#t:Qubit">Qubit</a>&#93; -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> &#91;<a href="Quipper-Monad.html#t:Qubit">Qubit</a>&#93;</li><li class="src short"><a href="#v:exact_synthesis_alt">exact_synthesis_alt</a> :: (<a href="http://hackage.haskell.org/package/fixedprec-0.3.0.2/docs/Quantum-Synthesis-Ring.html#t:ToQOmega">ToQOmega</a> a, <a href="http://hackage.haskell.org/package/fixedprec-0.3.0.2/docs/Quantum-Synthesis-Matrix.html#t:Nat">Nat</a> n) =&gt; <a href="http://hackage.haskell.org/package/fixedprec-0.3.0.2/docs/Quantum-Synthesis-Matrix.html#t:Matrix">Matrix</a> n n a -&gt; &#91;<a href="Quipper-Monad.html#t:Qubit">Qubit</a>&#93; -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> &#91;<a href="Quipper-Monad.html#t:Qubit">Qubit</a>&#93;</li><li class="src short"><a href="#v:approximate_synthesis_zrot">approximate_synthesis_zrot</a> :: <a href="http://hackage.haskell.org/package/random-1.1/docs/System-Random.html#t:RandomGen">RandomGen</a> g =&gt; <a href="QuipperLib-Synthesis.html#t:Precision">Precision</a> -&gt; <a href="http://hackage.haskell.org/package/fixedprec-0.3.0.2/docs/Quantum-Synthesis-SymReal.html#t:SymReal">SymReal</a> -&gt; g -&gt; <a href="Quipper-Monad.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a></li><li class="src short"><a href="#v:approximate_synthesis_phase">approximate_synthesis_phase</a> :: <a href="http://hackage.haskell.org/package/random-1.1/docs/System-Random.html#t:RandomGen">RandomGen</a> g =&gt; <a href="QuipperLib-Synthesis.html#t:KeepPhase">KeepPhase</a> -&gt; <a href="QuipperLib-Synthesis.html#t:Precision">Precision</a> -&gt; <a href="http://hackage.haskell.org/package/fixedprec-0.3.0.2/docs/Quantum-Synthesis-SymReal.html#t:SymReal">SymReal</a> -&gt; g -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> ()</li><li class="src short"><a href="#v:approximate_synthesis_euler">approximate_synthesis_euler</a> :: <a href="http://hackage.haskell.org/package/random-1.1/docs/System-Random.html#t:RandomGen">RandomGen</a> g =&gt; <a href="QuipperLib-Synthesis.html#t:KeepPhase">KeepPhase</a> -&gt; <a href="QuipperLib-Synthesis.html#t:Precision">Precision</a> -&gt; (<a href="http://hackage.haskell.org/package/fixedprec-0.3.0.2/docs/Quantum-Synthesis-SymReal.html#t:SymReal">SymReal</a>, <a href="http://hackage.haskell.org/package/fixedprec-0.3.0.2/docs/Quantum-Synthesis-SymReal.html#t:SymReal">SymReal</a>, <a href="http://hackage.haskell.org/package/fixedprec-0.3.0.2/docs/Quantum-Synthesis-SymReal.html#t:SymReal">SymReal</a>, <a href="http://hackage.haskell.org/package/fixedprec-0.3.0.2/docs/Quantum-Synthesis-SymReal.html#t:SymReal">SymReal</a>) -&gt; g -&gt; <a href="Quipper-Monad.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a></li><li class="src short"><a href="#v:approximate_synthesis_u2">approximate_synthesis_u2</a> :: <a href="http://hackage.haskell.org/package/random-1.1/docs/System-Random.html#t:RandomGen">RandomGen</a> g =&gt; <a href="QuipperLib-Synthesis.html#t:KeepPhase">KeepPhase</a> -&gt; <a href="QuipperLib-Synthesis.html#t:Precision">Precision</a> -&gt; <a href="http://hackage.haskell.org/package/fixedprec-0.3.0.2/docs/Quantum-Synthesis-Matrix.html#t:U2">U2</a> (<a href="http://hackage.haskell.org/package/fixedprec-0.3.0.2/docs/Quantum-Synthesis-Ring.html#t:Cplx">Cplx</a> <a href="http://hackage.haskell.org/package/fixedprec-0.3.0.2/docs/Quantum-Synthesis-SymReal.html#t:SymReal">SymReal</a>) -&gt; g -&gt; <a href="Quipper-Monad.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a></li><li class="src short"><a href="#v:approximate_synthesis_zrot_ctrl">approximate_synthesis_zrot_ctrl</a> :: <a href="http://hackage.haskell.org/package/random-1.1/docs/System-Random.html#t:RandomGen">RandomGen</a> g =&gt; <a href="QuipperLib-Synthesis.html#t:Precision">Precision</a> -&gt; <a href="http://hackage.haskell.org/package/fixedprec-0.3.0.2/docs/Quantum-Synthesis-SymReal.html#t:SymReal">SymReal</a> -&gt; g -&gt; <a href="Quipper-Monad.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper-Monad.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a></li><li class="src short"><a href="#v:approximate_synthesis_phase_ctrl">approximate_synthesis_phase_ctrl</a> :: <a href="http://hackage.haskell.org/package/random-1.1/docs/System-Random.html#t:RandomGen">RandomGen</a> g =&gt; <a href="QuipperLib-Synthesis.html#t:KeepPhase">KeepPhase</a> -&gt; <a href="QuipperLib-Synthesis.html#t:Precision">Precision</a> -&gt; <a href="http://hackage.haskell.org/package/fixedprec-0.3.0.2/docs/Quantum-Synthesis-SymReal.html#t:SymReal">SymReal</a> -&gt; g -&gt; <a href="Quipper-Monad.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a></li></ul></div><div id="interface"><h1 id="g:1">Precision</h1><div class="top"><p class="src"><span class="keyword">type</span> <a id="t:Precision" class="def">Precision</a> = <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Prelude.html#t:Double">Double</a> <a href="src/QuipperLib/Synthesis.html#line-32" class="link">Source</a> <a href="#t:Precision" class="selflink">#</a></p><div class="doc"><p>A type to measure precision. Precision is expressed as a number
 <em>b</em> of bits, i.e., binary digits, so that &#949; = 2<sup>&#8722;<em>b</em></sup>.</p></div></div><div class="top"><p class="src"><a id="v:bits" class="def">bits</a> :: <a href="QuipperLib-Synthesis.html#t:Precision">Precision</a> <a href="src/QuipperLib/Synthesis.html#line-38" class="link">Source</a> <a href="#v:bits" class="selflink">#</a></p><div class="doc"><p>Binary digits, as a unit of precision. For example, the following
 specifies a precision of 20 binary digits:</p><pre>prec = 20 * bits</pre></div></div><div class="top"><p class="src"><a id="v:digits" class="def">digits</a> :: <a href="QuipperLib-Synthesis.html#t:Precision">Precision</a> <a href="src/QuipperLib/Synthesis.html#line-45" class="link">Source</a> <a href="#v:digits" class="selflink">#</a></p><div class="doc"><p>Decimal digits, as a unit of precision. For example, the
 following specifies a precision of 30 decimal digits:</p><pre>prec = 30 * digits</pre></div></div><h1 id="g:2">Phase</h1><div class="top"><p class="src"><span class="keyword">type</span> <a id="t:KeepPhase" class="def">KeepPhase</a> = <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Bool.html#t:Bool">Bool</a> <a href="src/QuipperLib/Synthesis.html#line-53" class="link">Source</a> <a href="#t:KeepPhase" class="selflink">#</a></p><div class="doc"><p>A boolean flag indicating whether to respect global phases
 during circuit synthesis (<code><a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Bool.html#v:True">True</a></code>) or disregard them (<code><a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Bool.html#v:False">False</a></code>).</p></div></div><h1 id="g:3">Auxiliary functions</h1><div class="top"><p class="src"><a id="v:apply_gate_at" class="def">apply_gate_at</a> :: <a href="http://hackage.haskell.org/package/fixedprec-0.3.0.2/docs/Quantum-Synthesis-CliffordT.html#t:Gate">Gate</a> -&gt; <a href="Quipper-Monad.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> () <a href="src/QuipperLib/Synthesis.html#line-60" class="link">Source</a> <a href="#v:apply_gate_at" class="selflink">#</a></p><div class="doc"><p>Apply a gate (from the type <code><a href="http://hackage.haskell.org/package/fixedprec-0.3.0.2/docs/Quantum-Synthesis-CliffordT.html#t:Gate">Gate</a></code> of Clifford+<em>T</em> operators) to
 the given <code><a href="Quipper-Monad.html#t:Qubit">Qubit</a></code>.</p></div></div><div class="top"><p class="src"><a id="v:apply_gates_at" class="def">apply_gates_at</a> :: &#91;<a href="http://hackage.haskell.org/package/fixedprec-0.3.0.2/docs/Quantum-Synthesis-CliffordT.html#t:Gate">Gate</a>&#93; -&gt; <a href="Quipper-Monad.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> () <a href="src/QuipperLib/Synthesis.html#line-84" class="link">Source</a> <a href="#v:apply_gates_at" class="selflink">#</a></p><div class="doc"><p>Apply a gate list (from the type <code><a href="http://hackage.haskell.org/package/fixedprec-0.3.0.2/docs/Quantum-Synthesis-CliffordT.html#t:Gate">Gate</a></code> of Clifford+<em>T</em>
 operators) to the given <code><a href="Quipper-Monad.html#t:Qubit">Qubit</a></code>. </p><p>Note: the operators in the list are applied right-to-left, i.e.,
 the gate list is assumed given in matrix multiplication order, but
 are applied in circuit order.</p></div></div><div class="top"><p class="src"><a id="v:apply_gates2_at" class="def">apply_gates2_at</a> :: &#91;<a href="http://hackage.haskell.org/package/fixedprec-0.3.0.2/docs/Quantum-Synthesis-CliffordT.html#t:Gate">Gate</a>&#93; -&gt; <a href="Quipper-Monad.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper-Monad.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> () <a href="src/QuipperLib/Synthesis.html#line-90" class="link">Source</a> <a href="#v:apply_gates2_at" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="QuipperLib-Synthesis.html#v:apply_gates_at">apply_gates_at</a></code>, but apply the same list of gates to two
 qubits in parallel.</p></div></div><div class="top"><p class="src"><a id="v:twolevel" class="def">twolevel</a> :: <a href="http://hackage.haskell.org/package/fixedprec-0.3.0.2/docs/Quantum-Synthesis-MultiQubitSynthesis.html#t:Index">Index</a> -&gt; <a href="http://hackage.haskell.org/package/fixedprec-0.3.0.2/docs/Quantum-Synthesis-MultiQubitSynthesis.html#t:Index">Index</a> -&gt; &#91;<a href="Quipper-Monad.html#t:Qubit">Qubit</a>&#93; -&gt; (<a href="Quipper-Monad.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> ()) -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> () <a href="src/QuipperLib/Synthesis.html#line-107" class="link">Source</a> <a href="#v:twolevel" class="selflink">#</a></p><div class="doc"><p>Input two indices <em>i</em> and <em>j</em>, a list of qubits <em>qlist</em>, and an
 imperative-style single-qubit gate <em>U</em>. Apply the two-level
 operator <em>U</em><sub><em>i</em>,<em>j</em></sub> to <em>qlist</em>. Intended usage:</p><pre>twolevel i j qlist gate_U_at</pre><p>The qubits in <em>qlist</em> are ordered lexicographically left-to-right,
 e.g., &#91;|00&#9002;, |01&#9002;, |10&#9002;, |11&#9002;&#93;.</p><p>This function implements an improved version of Gray codes.</p></div></div><div class="top"><p class="src"><a id="v:gate_T_power_at" class="def">gate_T_power_at</a> :: <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a> -&gt; <a href="Quipper-Monad.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> () <a href="src/QuipperLib/Synthesis.html#line-139" class="link">Source</a> <a href="#v:gate_T_power_at" class="selflink">#</a></p><div class="doc"><p>Apply a <em>T</em><sup><em>m</em></sup> gate. This gate is decomposed into <em>Z</em>, <em>S</em>,
 <em>S</em><sup>&#8224;</sup>, <em>T</em>, and <em>T</em><sup>&#8224;</sup> gates.</p></div></div><div class="top"><p class="src"><a id="v:apply_twolevel_at" class="def">apply_twolevel_at</a> :: <a href="http://hackage.haskell.org/package/fixedprec-0.3.0.2/docs/Quantum-Synthesis-MultiQubitSynthesis.html#t:TwoLevel">TwoLevel</a> -&gt; &#91;<a href="Quipper-Monad.html#t:Qubit">Qubit</a>&#93; -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> () <a href="src/QuipperLib/Synthesis.html#line-163" class="link">Source</a> <a href="#v:apply_twolevel_at" class="selflink">#</a></p><div class="doc"><p>Apply a <code><a href="http://hackage.haskell.org/package/fixedprec-0.3.0.2/docs/Quantum-Synthesis-MultiQubitSynthesis.html#t:TwoLevel">TwoLevel</a></code> gate to the given list of qubits. 
 The qubits in <em>qlist</em> are ordered lexicographically left-to-right,
 e.g., &#91;|00&#9002;, |01&#9002;, |10&#9002;, |11&#9002;&#93;.</p></div></div><div class="top"><p class="src"><a id="v:apply_twolevels_at" class="def">apply_twolevels_at</a> :: &#91;<a href="http://hackage.haskell.org/package/fixedprec-0.3.0.2/docs/Quantum-Synthesis-MultiQubitSynthesis.html#t:TwoLevel">TwoLevel</a>&#93; -&gt; &#91;<a href="Quipper-Monad.html#t:Qubit">Qubit</a>&#93; -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> () <a href="src/QuipperLib/Synthesis.html#line-198" class="link">Source</a> <a href="#v:apply_twolevels_at" class="selflink">#</a></p><div class="doc"><p>Apply a list of <code><a href="http://hackage.haskell.org/package/fixedprec-0.3.0.2/docs/Quantum-Synthesis-MultiQubitSynthesis.html#t:TwoLevel">TwoLevel</a></code> gates to the given list of
 qubits. </p><p>The qubits in <em>qlist</em> are ordered lexicographically left-to-right,
 e.g., &#91;|00&#9002;, |01&#9002;, |10&#9002;, |11&#9002;&#93;.</p><p>Note: the operators in the list are applied right-to-left, i.e.,
 the gate list is assumed given in matrix multiplication order, but
 are applied in circuit order.</p></div></div><div class="top"><p class="src"><a id="v:apply_twolevel_alt_at" class="def">apply_twolevel_alt_at</a> :: <a href="http://hackage.haskell.org/package/fixedprec-0.3.0.2/docs/Quantum-Synthesis-MultiQubitSynthesis.html#t:TwoLevelAlt">TwoLevelAlt</a> -&gt; &#91;<a href="Quipper-Monad.html#t:Qubit">Qubit</a>&#93; -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> () <a href="src/QuipperLib/Synthesis.html#line-204" class="link">Source</a> <a href="#v:apply_twolevel_alt_at" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="QuipperLib-Synthesis.html#v:apply_twolevel_at">apply_twolevel_at</a></code>, but use the alternate generators for
 two-level gates.</p></div></div><div class="top"><p class="src"><a id="v:apply_twolevels_alt_at" class="def">apply_twolevels_alt_at</a> :: &#91;<a href="http://hackage.haskell.org/package/fixedprec-0.3.0.2/docs/Quantum-Synthesis-MultiQubitSynthesis.html#t:TwoLevelAlt">TwoLevelAlt</a>&#93; -&gt; &#91;<a href="Quipper-Monad.html#t:Qubit">Qubit</a>&#93; -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> () <a href="src/QuipperLib/Synthesis.html#line-252" class="link">Source</a> <a href="#v:apply_twolevels_alt_at" class="selflink">#</a></p><div class="doc"><p>Apply a list of <code><a href="http://hackage.haskell.org/package/fixedprec-0.3.0.2/docs/Quantum-Synthesis-MultiQubitSynthesis.html#t:TwoLevelAlt">TwoLevelAlt</a></code> gates to the given list of
 qubits. </p><p>The qubits in <em>qlist</em> are ordered lexicographically left-to-right,
 e.g., &#91;|00&#9002;, |01&#9002;, |10&#9002;, |11&#9002;&#93;.</p><p>Note: the operators in the list are applied right-to-left, i.e.,
 the gate list is assumed given in matrix multiplication order, but
 are applied in circuit order.</p></div></div><h1 id="g:4">Single-qubit exact synthesis</h1><div class="top"><p class="src"><a id="v:exact_synthesis1" class="def">exact_synthesis1</a> :: <a href="http://hackage.haskell.org/package/fixedprec-0.3.0.2/docs/Quantum-Synthesis-CliffordT.html#t:ToGates">ToGates</a> a =&gt; a -&gt; <a href="Quipper-Monad.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a> <a href="src/QuipperLib/Synthesis.html#line-274" class="link">Source</a> <a href="#v:exact_synthesis1" class="selflink">#</a></p><div class="doc"><p>Decompose the given operator exactly into a single-qubit
 Clifford+<em>T</em> circuit. The operator must be given in one of the
 available exact formats, i.e., any instance of the <code><a href="http://hackage.haskell.org/package/fixedprec-0.3.0.2/docs/Quantum-Synthesis-CliffordT.html#t:ToGates">ToGates</a></code> class.
 Typical instances are:</p><ul><li><code><a href="http://hackage.haskell.org/package/fixedprec-0.3.0.2/docs/Quantum-Synthesis-Matrix.html#t:U2">U2</a></code> <code><a href="http://hackage.haskell.org/package/fixedprec-0.3.0.2/docs/Quantum-Synthesis-Ring.html#t:DRComplex">DRComplex</a></code>: a 2&#215;2 unitary operator with entries from the
 ring &#8484;&#91;1/&#8730;2, <em>i</em>&#93;;</li><li><code><a href="http://hackage.haskell.org/package/fixedprec-0.3.0.2/docs/Quantum-Synthesis-Matrix.html#t:U2">U2</a></code> <code><a href="http://hackage.haskell.org/package/fixedprec-0.3.0.2/docs/Quantum-Synthesis-Ring.html#t:DOmega">DOmega</a></code>: a 2&#215;2 unitary operator with entries from the ring
 <b>D</b>&#91;&#969;&#93;;</li><li><code><a href="http://hackage.haskell.org/package/fixedprec-0.3.0.2/docs/Quantum-Synthesis-Matrix.html#t:SO3">SO3</a></code> <code><a href="http://hackage.haskell.org/package/fixedprec-0.3.0.2/docs/Quantum-Synthesis-Ring.html#t:DRootTwo">DRootTwo</a></code>: a 3&#215;3 Bloch sphere operator with entries from the
 ring &#8484;&#91;1/&#8730;2&#93;. In this last case, the operator will be synthesized
 up to an unspecified global phase.</li></ul></div></div><h1 id="g:5">Multi-qubit exact synthesis</h1><div class="top"><p class="src"><a id="v:exact_synthesis" class="def">exact_synthesis</a> :: (<a href="http://hackage.haskell.org/package/fixedprec-0.3.0.2/docs/Quantum-Synthesis-Ring.html#t:ToQOmega">ToQOmega</a> a, <a href="http://hackage.haskell.org/package/fixedprec-0.3.0.2/docs/Quantum-Synthesis-Matrix.html#t:Nat">Nat</a> n) =&gt; <a href="http://hackage.haskell.org/package/fixedprec-0.3.0.2/docs/Quantum-Synthesis-Matrix.html#t:Matrix">Matrix</a> n n a -&gt; &#91;<a href="Quipper-Monad.html#t:Qubit">Qubit</a>&#93; -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> &#91;<a href="Quipper-Monad.html#t:Qubit">Qubit</a>&#93; <a href="src/QuipperLib/Synthesis.html#line-300" class="link">Source</a> <a href="#v:exact_synthesis" class="selflink">#</a></p><div class="doc"><p>Decompose the given operator exactly into a Clifford+<em>T</em> circuit.
 The operator must be given as an <em>n</em>&#215;<em>n</em>-matrix with coefficients
 in a ring that is an instance of the <code>ToQRComplex</code> class. Typical
 examples of such rings are <code><a href="http://hackage.haskell.org/package/fixedprec-0.3.0.2/docs/Quantum-Synthesis-Ring.html#t:DRComplex">DRComplex</a></code>, <code><a href="http://hackage.haskell.org/package/fixedprec-0.3.0.2/docs/Quantum-Synthesis-Ring.html#t:DOmega">DOmega</a></code>, and <code><a href="http://hackage.haskell.org/package/fixedprec-0.3.0.2/docs/Quantum-Synthesis-Ring.html#t:QRComplex">QRComplex</a></code>.</p><p>If this function is applied to a list of <em>m</em> qubits, then we must
 have <em>n</em> &#8804; 2<sup><em>m</em></sup>.</p><p>The qubits in <em>qlist</em> are ordered lexicographically left-to-right,
 e.g., &#91;|00&#9002;, |01&#9002;, |10&#9002;, |11&#9002;&#93;.</p><p>The generated circuit contains no ancillas, but may contain
 multi-controlled gates whose decomposition into Clifford+<em>T</em>
 generators requires ancillas.</p></div></div><div class="top"><p class="src"><a id="v:exact_synthesis_alt" class="def">exact_synthesis_alt</a> :: (<a href="http://hackage.haskell.org/package/fixedprec-0.3.0.2/docs/Quantum-Synthesis-Ring.html#t:ToQOmega">ToQOmega</a> a, <a href="http://hackage.haskell.org/package/fixedprec-0.3.0.2/docs/Quantum-Synthesis-Matrix.html#t:Nat">Nat</a> n) =&gt; <a href="http://hackage.haskell.org/package/fixedprec-0.3.0.2/docs/Quantum-Synthesis-Matrix.html#t:Matrix">Matrix</a> n n a -&gt; &#91;<a href="Quipper-Monad.html#t:Qubit">Qubit</a>&#93; -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> &#91;<a href="Quipper-Monad.html#t:Qubit">Qubit</a>&#93; <a href="src/QuipperLib/Synthesis.html#line-314" class="link">Source</a> <a href="#v:exact_synthesis_alt" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="QuipperLib-Synthesis.html#v:exact_synthesis">exact_synthesis</a></code>, but use the alternate algorithm from
 Section 6 of Giles-Selinger. This means all but at most one of the
 generated multi-controlled gates have determinant 1, which means
 they can be further decomposed without ancillas.</p></div></div><h1 id="g:6">Single-qubit approximate synthesis</h1><h2 id="g:7"><em>z</em>-Rotations</h2><div class="top"><p class="src"><a id="v:approximate_synthesis_zrot" class="def">approximate_synthesis_zrot</a> :: <a href="http://hackage.haskell.org/package/random-1.1/docs/System-Random.html#t:RandomGen">RandomGen</a> g =&gt; <a href="QuipperLib-Synthesis.html#t:Precision">Precision</a> -&gt; <a href="http://hackage.haskell.org/package/fixedprec-0.3.0.2/docs/Quantum-Synthesis-SymReal.html#t:SymReal">SymReal</a> -&gt; g -&gt; <a href="Quipper-Monad.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a> <a href="src/QuipperLib/Synthesis.html#line-342" class="link">Source</a> <a href="#v:approximate_synthesis_zrot" class="selflink">#</a></p><div class="doc"><p>Decompose an <em>R</em><a href="&amp;#952;">sub /z/</a> = <i>e</i><sup>&#8722;<em>i</em>&#952;<em>Z</em>/2</sup> gate into a
 single-qubit Clifford+<em>T</em> circuit up to the given precision. </p><p><img src="images/Rz.png"></p><p>The parameters are:</p><ul><li>a precision <em>b</em> &#8805; 0;</li><li>an angle &#952;, given as a <code><a href="http://hackage.haskell.org/package/fixedprec-0.3.0.2/docs/Quantum-Synthesis-SymReal.html#t:SymReal">SymReal</a></code> value;</li><li>a source of randomness <em>g</em>.</li></ul></div></div><h2 id="g:8">Global phase gates</h2><div class="top"><p class="src"><a id="v:approximate_synthesis_phase" class="def">approximate_synthesis_phase</a> :: <a href="http://hackage.haskell.org/package/random-1.1/docs/System-Random.html#t:RandomGen">RandomGen</a> g =&gt; <a href="QuipperLib-Synthesis.html#t:KeepPhase">KeepPhase</a> -&gt; <a href="QuipperLib-Synthesis.html#t:Precision">Precision</a> -&gt; <a href="http://hackage.haskell.org/package/fixedprec-0.3.0.2/docs/Quantum-Synthesis-SymReal.html#t:SymReal">SymReal</a> -&gt; g -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> () <a href="src/QuipperLib/Synthesis.html#line-372" class="link">Source</a> <a href="#v:approximate_synthesis_phase" class="selflink">#</a></p><div class="doc"><p>Construct a Clifford+<em>T</em> circuit (with no inputs and outputs)
 that approximates a scalar global phase gate <i>e</i><sup><em>i</em>&#952;</sup> up to the
 given precision. The parameters are:</p><ul><li>a flag <em>keepphase</em> to indicate whether global phase should be
 respected. (Note that if this is set to <code><a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Bool.html#v:False">False</a></code>, then this function
 is just a no-op);</li><li>a precision <em>b</em> &#8805; 0;</li><li>an angle &#952;, given as a <code><a href="http://hackage.haskell.org/package/fixedprec-0.3.0.2/docs/Quantum-Synthesis-SymReal.html#t:SymReal">SymReal</a></code> value;</li><li>a source of randomness <em>g</em>.</li></ul><p>We use the following decomposition:</p><p><img src="images/phase.png"></p></div></div><h2 id="g:9"><em>U</em>(2) from Euler angles</h2><div class="top"><p class="src"><a id="v:approximate_synthesis_euler" class="def">approximate_synthesis_euler</a> :: <a href="http://hackage.haskell.org/package/random-1.1/docs/System-Random.html#t:RandomGen">RandomGen</a> g =&gt; <a href="QuipperLib-Synthesis.html#t:KeepPhase">KeepPhase</a> -&gt; <a href="QuipperLib-Synthesis.html#t:Precision">Precision</a> -&gt; (<a href="http://hackage.haskell.org/package/fixedprec-0.3.0.2/docs/Quantum-Synthesis-SymReal.html#t:SymReal">SymReal</a>, <a href="http://hackage.haskell.org/package/fixedprec-0.3.0.2/docs/Quantum-Synthesis-SymReal.html#t:SymReal">SymReal</a>, <a href="http://hackage.haskell.org/package/fixedprec-0.3.0.2/docs/Quantum-Synthesis-SymReal.html#t:SymReal">SymReal</a>, <a href="http://hackage.haskell.org/package/fixedprec-0.3.0.2/docs/Quantum-Synthesis-SymReal.html#t:SymReal">SymReal</a>) -&gt; g -&gt; <a href="Quipper-Monad.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a> <a href="src/QuipperLib/Synthesis.html#line-404" class="link">Source</a> <a href="#v:approximate_synthesis_euler" class="selflink">#</a></p><div class="doc"><p>Decompose the operator</p><ul><li><em>U</em> = <i>e</i><sup><em>i</em>&#945;</sup> R<sub><em>z</em></sub>(&#946;) R<sub><em>x</em></sub>(&#947;) R<sub><em>z</em></sub>(&#948;)</li></ul><p>into the Clifford+<em>T</em> gate base, up to the given precision.
 The parameters are:</p><ul><li>a flag <em>keepphase</em> to indicate whether global phase should be
   respected. If this is <code><a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Bool.html#v:False">False</a></code>, the angle &#945; is disregarded;</li><li>a precision <em>b</em> &#8805; 0;</li><li>a tuple of Euler angles (&#945;, &#946;, &#947;, &#948;), given as <code><a href="http://hackage.haskell.org/package/fixedprec-0.3.0.2/docs/Quantum-Synthesis-SymReal.html#t:SymReal">SymReal</a></code> values;</li><li>a source of randomness <em>g</em>.</li></ul></div></div><h2 id="g:10"><em>U</em>(2) from matrix</h2><div class="top"><p class="src"><a id="v:approximate_synthesis_u2" class="def">approximate_synthesis_u2</a> :: <a href="http://hackage.haskell.org/package/random-1.1/docs/System-Random.html#t:RandomGen">RandomGen</a> g =&gt; <a href="QuipperLib-Synthesis.html#t:KeepPhase">KeepPhase</a> -&gt; <a href="QuipperLib-Synthesis.html#t:Precision">Precision</a> -&gt; <a href="http://hackage.haskell.org/package/fixedprec-0.3.0.2/docs/Quantum-Synthesis-Matrix.html#t:U2">U2</a> (<a href="http://hackage.haskell.org/package/fixedprec-0.3.0.2/docs/Quantum-Synthesis-Ring.html#t:Cplx">Cplx</a> <a href="http://hackage.haskell.org/package/fixedprec-0.3.0.2/docs/Quantum-Synthesis-SymReal.html#t:SymReal">SymReal</a>) -&gt; g -&gt; <a href="Quipper-Monad.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a> <a href="src/QuipperLib/Synthesis.html#line-436" class="link">Source</a> <a href="#v:approximate_synthesis_u2" class="selflink">#</a></p><div class="doc"><p>Decompose a single-qubit unitary gate <em>U</em> into the Clifford+<em>T</em>
 gate base, up to the given precision, provided that det <em>U</em> = 1.
 The parameters are:</p><ul><li>a flag <em>keepphase</em> to indicate whether global phase should be
 respected;</li><li>a precision <em>b</em> &#8805; 0;</li><li>a 2&#215;2 complex matrix, with entries expressed as <code><a href="http://hackage.haskell.org/package/fixedprec-0.3.0.2/docs/Quantum-Synthesis-Ring.html#t:Cplx">Cplx</a></code> <code><a href="http://hackage.haskell.org/package/fixedprec-0.3.0.2/docs/Quantum-Synthesis-SymReal.html#t:SymReal">SymReal</a></code> values;</li><li>a source of randomness <em>g</em>.</li></ul></div></div><h2 id="g:11">Controlled gates</h2><div class="top"><p class="src"><a id="v:approximate_synthesis_zrot_ctrl" class="def">approximate_synthesis_zrot_ctrl</a> :: <a href="http://hackage.haskell.org/package/random-1.1/docs/System-Random.html#t:RandomGen">RandomGen</a> g =&gt; <a href="QuipperLib-Synthesis.html#t:Precision">Precision</a> -&gt; <a href="http://hackage.haskell.org/package/fixedprec-0.3.0.2/docs/Quantum-Synthesis-SymReal.html#t:SymReal">SymReal</a> -&gt; g -&gt; <a href="Quipper-Monad.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper-Monad.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a> <a href="src/QuipperLib/Synthesis.html#line-461" class="link">Source</a> <a href="#v:approximate_synthesis_zrot_ctrl" class="selflink">#</a></p><div class="doc"><p>Decompose a controlled <em>R</em><a href="&amp;#952;">sub /z/</a> = <i>e</i><sup>&#8722;<em>i</em>&#952;<em>Z</em>/2</sup> gate
 into a single-qubit Clifford+<em>T</em> circuit up to the given
 precision. The parameters are as for <code><a href="QuipperLib-Synthesis.html#v:approximate_synthesis_phase">approximate_synthesis_phase</a></code>.
 The first input is the target qubit, and the second input the
 control.</p><p>We use the following decomposition. It has lower <em>T</em>-count than the
 alternatives and makes good use of parallelism. Since it uses the
 same rotation twice, only a single run of the synthesis algorithm
 is required.</p><p><img src="images/controlled-zrot.png"></p></div></div><div class="top"><p class="src"><a id="v:approximate_synthesis_phase_ctrl" class="def">approximate_synthesis_phase_ctrl</a> :: <a href="http://hackage.haskell.org/package/random-1.1/docs/System-Random.html#t:RandomGen">RandomGen</a> g =&gt; <a href="QuipperLib-Synthesis.html#t:KeepPhase">KeepPhase</a> -&gt; <a href="QuipperLib-Synthesis.html#t:Precision">Precision</a> -&gt; <a href="http://hackage.haskell.org/package/fixedprec-0.3.0.2/docs/Quantum-Synthesis-SymReal.html#t:SymReal">SymReal</a> -&gt; g -&gt; <a href="Quipper-Monad.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a> <a href="src/QuipperLib/Synthesis.html#line-489" class="link">Source</a> <a href="#v:approximate_synthesis_phase_ctrl" class="selflink">#</a></p><div class="doc"><p>Decompose a controlled phase gate</p><p><img src="images/controlled_phase.png"></p><p>into the Clifford+<em>T</em> gate base. The parameters are as for
 <code><a href="QuipperLib-Synthesis.html#v:approximate_synthesis_phase">approximate_synthesis_phase</a></code>.</p><p>We use the following decomposition. It has lower <em>T</em>-count than the
 alternatives and makes good use of parallelism. Since it uses the
 same rotation twice, only a single run of the synthesis algorithm
 is required.</p><p><img src="images/controlled-phase-decomp.png"></p><p>If the <code><a href="QuipperLib-Synthesis.html#t:KeepPhase">KeepPhase</a></code> flag is set, respect global phase; otherwise,
 disregard it.</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.17.3</p></div></body></html>
