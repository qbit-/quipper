<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Algorithms.BF.BooleanFormula</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Algorithms-BF-BooleanFormula.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/Algorithms/BF/BooleanFormula.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">The Quipper System</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>None</td></tr></table><p class="caption">Algorithms.BF.BooleanFormula</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Classical data structures</a><ul><li><a href="#g:2">Oracle description</a></li><li><a href="#g:3">Hex boards</a></li></ul></li><li><a href="#g:4">Quantum data structures</a></li><li><a href="#g:5">Oracle implementation</a></li><li><a href="#g:6">Possible main functions</a></li><li><a href="#g:7">Running the Boolean Formula Algorithm</a></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>This module contains the implementation of the various quantum circuits
 that make up the boolean formula algorithm. Please see <a href="Algorithms-BF-Main.html">Algorithms.BF.Main</a>
 for an overview of the boolean formula algorithm.</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><span class="keyword">data</span> <a href="#t:BooleanFormulaOracle">BooleanFormulaOracle</a> = <a href="#v:BFO">BFO</a> {<ul class="subs"><li><a href="#v:oracle_x_max">oracle_x_max</a> :: <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a></li><li><a href="#v:oracle_y_max">oracle_y_max</a> :: <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a></li><li><a href="#v:oracle_t">oracle_t</a> :: <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a></li><li><a href="#v:oracle_s">oracle_s</a> :: <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a></li><li><a href="#v:oracle_m">oracle_m</a> :: <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a></li><li><a href="#v:start_board">start_board</a> :: <a href="Algorithms-BF-BooleanFormula.html#t:HexBoard">HexBoard</a></li><li><a href="#v:oracle_hex">oracle_hex</a> :: <a href="Algorithms-BF-BooleanFormula.html#t:HexCircuit">HexCircuit</a></li></ul>}</li><li class="src short"><span class="keyword">data</span> <a href="#t:HexCircuit">HexCircuit</a><ul class="subs"><li>= <a href="#v:Hex">Hex</a></li><li>| <a href="#v:Dummy">Dummy</a></li><li>| <a href="#v:EmptyHex">EmptyHex</a></li></ul></li><li class="src short"><a href="#v:createOracle">createOracle</a> :: <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a> -&gt; <a href="Algorithms-BF-BooleanFormula.html#t:BooleanFormulaOracle">BooleanFormulaOracle</a></li><li class="src short"><a href="#v:update_hex">update_hex</a> :: <a href="Algorithms-BF-BooleanFormula.html#t:BooleanFormulaOracle">BooleanFormulaOracle</a> -&gt; <a href="Algorithms-BF-BooleanFormula.html#t:HexCircuit">HexCircuit</a> -&gt; <a href="Algorithms-BF-BooleanFormula.html#t:BooleanFormulaOracle">BooleanFormulaOracle</a></li><li class="src short"><a href="#v:update_start_board">update_start_board</a> :: <a href="Algorithms-BF-BooleanFormula.html#t:BooleanFormulaOracle">BooleanFormulaOracle</a> -&gt; <a href="Algorithms-BF-BooleanFormula.html#t:HexBoard">HexBoard</a> -&gt; <a href="Algorithms-BF-BooleanFormula.html#t:BooleanFormulaOracle">BooleanFormulaOracle</a></li><li class="src short"><a href="#v:full_oracle">full_oracle</a> :: <a href="Algorithms-BF-BooleanFormula.html#t:BooleanFormulaOracle">BooleanFormulaOracle</a></li><li class="src short"><a href="#v:test_oracle">test_oracle</a> :: <a href="Algorithms-BF-BooleanFormula.html#t:BooleanFormulaOracle">BooleanFormulaOracle</a></li><li class="src short"><span class="keyword">type</span> <a href="#t:HexBoard">HexBoard</a> = (&#91;<a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Bool.html#t:Bool">Bool</a>&#93;, &#91;<a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Bool.html#t:Bool">Bool</a>&#93;)</li><li class="src short"><a href="#v:moves_made">moves_made</a> :: <a href="Algorithms-BF-BooleanFormula.html#t:HexBoard">HexBoard</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a></li><li class="src short"><a href="#v:empty_spaces">empty_spaces</a> :: <a href="Algorithms-BF-BooleanFormula.html#t:HexBoard">HexBoard</a> -&gt; &#91;<a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a>&#93;</li><li class="src short"><span class="keyword">type</span> <a href="#t:PhaseEstimationRegister">PhaseEstimationRegister</a> = &#91;<a href="Quipper-Monad.html#t:Qubit">Qubit</a>&#93;</li><li class="src short"><span class="keyword">type</span> <a href="#t:GenericDirectionRegister">GenericDirectionRegister</a> a = &#91;a&#93;</li><li class="src short"><span class="keyword">type</span> <a href="#t:DirectionRegister">DirectionRegister</a> = <a href="Algorithms-BF-BooleanFormula.html#t:GenericDirectionRegister">GenericDirectionRegister</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a></li><li class="src short"><span class="keyword">data</span> <a href="#t:GenericBooleanFormulaRegister">GenericBooleanFormulaRegister</a> a = <a href="#v:BFR">BFR</a> {<ul class="subs"><li><a href="#v:position_flags">position_flags</a> :: (a, a)</li><li><a href="#v:position">position</a> :: &#91;<a href="Algorithms-BF-BooleanFormula.html#t:GenericDirectionRegister">GenericDirectionRegister</a> a&#93;</li><li><a href="#v:work_leaf">work_leaf</a> :: a</li><li><a href="#v:work_paraleaf">work_paraleaf</a> :: a</li><li><a href="#v:work_binary">work_binary</a> :: a</li><li><a href="#v:work_height">work_height</a> :: a</li><li><a href="#v:work_r">work_r</a> :: a</li><li><a href="#v:work_rp">work_rp</a> :: a</li><li><a href="#v:work_rpp">work_rpp</a> :: a</li><li><a href="#v:direction">direction</a> :: <a href="Algorithms-BF-BooleanFormula.html#t:GenericDirectionRegister">GenericDirectionRegister</a> a</li></ul>}</li><li class="src short"><span class="keyword">type</span> <a href="#t:BooleanFormulaRegister">BooleanFormulaRegister</a> = <a href="Algorithms-BF-BooleanFormula.html#t:GenericBooleanFormulaRegister">GenericBooleanFormulaRegister</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a></li><li class="src short"><a href="#v:labelBFR">labelBFR</a> :: <a href="Algorithms-BF-BooleanFormula.html#t:BooleanFormulaRegister">BooleanFormulaRegister</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> ()</li><li class="src short"><span class="keyword">type</span> <a href="#t:BoolRegister">BoolRegister</a> = <a href="Algorithms-BF-BooleanFormula.html#t:GenericBooleanFormulaRegister">GenericBooleanFormulaRegister</a> <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Bool.html#t:Bool">Bool</a></li><li class="src short"><a href="#v:toTuple">toTuple</a> :: <a href="Algorithms-BF-BooleanFormula.html#t:GenericBooleanFormulaRegister">GenericBooleanFormulaRegister</a> a -&gt; ((a, a), &#91;&#91;a&#93;&#93;, (a, a, a, a, a, a, a), &#91;a&#93;)</li><li class="src short"><a href="#v:fromTuple">fromTuple</a> :: ((a, a), &#91;&#91;a&#93;&#93;, (a, a, a, a, a, a, a), &#91;a&#93;) -&gt; <a href="Algorithms-BF-BooleanFormula.html#t:GenericBooleanFormulaRegister">GenericBooleanFormulaRegister</a> a</li><li class="src short"><a href="#v:createRegister">createRegister</a> :: <a href="Algorithms-BF-BooleanFormula.html#t:BooleanFormulaOracle">BooleanFormulaOracle</a> -&gt; <a href="Algorithms-BF-BooleanFormula.html#t:BoolRegister">BoolRegister</a></li><li class="src short"><a href="#v:registerShape">registerShape</a> :: <a href="Algorithms-BF-BooleanFormula.html#t:BooleanFormulaOracle">BooleanFormulaOracle</a> -&gt; <a href="Algorithms-BF-BooleanFormula.html#t:BooleanFormulaRegister">BooleanFormulaRegister</a></li><li class="src short"><a href="#v:initializeRegister">initializeRegister</a> :: <a href="Algorithms-BF-BooleanFormula.html#t:BooleanFormulaOracle">BooleanFormulaOracle</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> <a href="Algorithms-BF-BooleanFormula.html#t:BooleanFormulaRegister">BooleanFormulaRegister</a></li><li class="src short"><a href="#v:qw_bf">qw_bf</a> :: <a href="Algorithms-BF-BooleanFormula.html#t:BooleanFormulaOracle">BooleanFormulaOracle</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> &#91;<a href="Quipper-Monad.html#t:Bit">Bit</a>&#93;</li><li class="src short"><a href="#v:subroutine_inverse_qft">subroutine_inverse_qft</a> :: <a href="Algorithms-BF-BooleanFormula.html#t:BooleanFormulaOracle">BooleanFormulaOracle</a> -&gt; &#91;<a href="Quipper-Monad.html#t:Qubit">Qubit</a>&#93; -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> &#91;<a href="Quipper-Monad.html#t:Qubit">Qubit</a>&#93;</li><li class="src short"><a href="#v:map_exp_u">map_exp_u</a> :: <a href="Algorithms-BF-BooleanFormula.html#t:BooleanFormulaOracle">BooleanFormulaOracle</a> -&gt; &#91;<a href="Quipper-Monad.html#t:Qubit">Qubit</a>&#93; -&gt; <a href="Algorithms-BF-BooleanFormula.html#t:BooleanFormulaRegister">BooleanFormulaRegister</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> ()</li><li class="src short"><a href="#v:exp_u">exp_u</a> :: <a href="Algorithms-BF-BooleanFormula.html#t:BooleanFormulaOracle">BooleanFormulaOracle</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Prelude.html#t:Integer">Integer</a> -&gt; <a href="Algorithms-BF-BooleanFormula.html#t:BooleanFormulaRegister">BooleanFormulaRegister</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> ()</li><li class="src short"><a href="#v:u">u</a> :: <a href="Algorithms-BF-BooleanFormula.html#t:BooleanFormulaOracle">BooleanFormulaOracle</a> -&gt; <a href="Algorithms-BF-BooleanFormula.html#t:BooleanFormulaRegister">BooleanFormulaRegister</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> ()</li><li class="src short"><a href="#v:subroutine_u">subroutine_u</a> :: <a href="Algorithms-BF-BooleanFormula.html#t:BooleanFormulaOracle">BooleanFormulaOracle</a> -&gt; <a href="Algorithms-BF-BooleanFormula.html#t:BooleanFormulaRegister">BooleanFormulaRegister</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> ()</li><li class="src short"><a href="#v:oracle">oracle</a> :: <a href="Algorithms-BF-BooleanFormula.html#t:BooleanFormulaOracle">BooleanFormulaOracle</a> -&gt; <a href="Algorithms-BF-BooleanFormula.html#t:BooleanFormulaRegister">BooleanFormulaRegister</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> ()</li><li class="src short"><a href="#v:subroutine_oracle">subroutine_oracle</a> :: <a href="Algorithms-BF-BooleanFormula.html#t:BooleanFormulaOracle">BooleanFormulaOracle</a> -&gt; <a href="Algorithms-BF-BooleanFormula.html#t:BooleanFormulaRegister">BooleanFormulaRegister</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> ()</li><li class="src short"><a href="#v:controls">controls</a> :: <a href="Quipper-Monad.html#t:Qubit">Qubit</a> -&gt; &#91;<a href="Algorithms-BF-BooleanFormula.html#t:DirectionRegister">DirectionRegister</a>&#93; -&gt; &#91;<a href="Quipper-Control.html#t:ControlList">ControlList</a>&#93;</li><li class="src short"><a href="#v:diffuse">diffuse</a> :: <a href="Algorithms-BF-BooleanFormula.html#t:BooleanFormulaRegister">BooleanFormulaRegister</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> ()</li><li class="src short"><a href="#v:subroutine_diffuse">subroutine_diffuse</a> :: <a href="Algorithms-BF-BooleanFormula.html#t:BooleanFormulaOracle">BooleanFormulaOracle</a> -&gt; <a href="Algorithms-BF-BooleanFormula.html#t:BooleanFormulaRegister">BooleanFormulaRegister</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> ()</li><li class="src short"><span class="keyword">data</span> <a href="#t:Where">Where</a><ul class="subs"><li>= <a href="#v:Width">Width</a></li><li>| <a href="#v:M">M</a></li><li>| <a href="#v:M2">M2</a></li></ul></li><li class="src short"><a href="#v:walk">walk</a> :: <a href="Algorithms-BF-BooleanFormula.html#t:BooleanFormulaRegister">BooleanFormulaRegister</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> ()</li><li class="src short"><a href="#v:subroutine_walk">subroutine_walk</a> :: <a href="Algorithms-BF-BooleanFormula.html#t:BooleanFormulaOracle">BooleanFormulaOracle</a> -&gt; <a href="Algorithms-BF-BooleanFormula.html#t:BooleanFormulaRegister">BooleanFormulaRegister</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> ()</li><li class="src short"><a href="#v:undo_oracle">undo_oracle</a> :: <a href="Algorithms-BF-BooleanFormula.html#t:BooleanFormulaOracle">BooleanFormulaOracle</a> -&gt; <a href="Algorithms-BF-BooleanFormula.html#t:BooleanFormulaRegister">BooleanFormulaRegister</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> ()</li><li class="src short"><a href="#v:subroutine_undo_oracle">subroutine_undo_oracle</a> :: <a href="Algorithms-BF-BooleanFormula.html#t:BooleanFormulaOracle">BooleanFormulaOracle</a> -&gt; <a href="Algorithms-BF-BooleanFormula.html#t:BooleanFormulaRegister">BooleanFormulaRegister</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> ()</li><li class="src short"><a href="#v:toParent">toParent</a> :: <a href="Algorithms-BF-BooleanFormula.html#t:Where">Where</a> -&gt; <a href="Algorithms-BF-BooleanFormula.html#t:BooleanFormulaRegister">BooleanFormulaRegister</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> ()</li><li class="src short"><a href="#v:copy_from_to">copy_from_to</a> :: <a href="Quipper-Monad.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper-Monad.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> (<a href="Quipper-Monad.html#t:Qubit">Qubit</a>, <a href="Quipper-Monad.html#t:Qubit">Qubit</a>)</li><li class="src short"><a href="#v:toChild">toChild</a> :: <a href="Algorithms-BF-BooleanFormula.html#t:Where">Where</a> -&gt; <a href="Algorithms-BF-BooleanFormula.html#t:BooleanFormulaRegister">BooleanFormulaRegister</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> ()</li><li class="src short"><a href="#v:shift_left">shift_left</a> :: &#91;<a href="Algorithms-BF-BooleanFormula.html#t:DirectionRegister">DirectionRegister</a>&#93; -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> ()</li><li class="src short"><a href="#v:shift_right">shift_right</a> :: &#91;<a href="Algorithms-BF-BooleanFormula.html#t:DirectionRegister">DirectionRegister</a>&#93; -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> ()</li><li class="src short"><a href="#v:main_circuit">main_circuit</a> :: <a href="Quipper-Printing.html#t:Format">Format</a> -&gt; <a href="QuipperLib-Decompose-GateBase.html#t:GateBase">GateBase</a> -&gt; <a href="Algorithms-BF-BooleanFormula.html#t:BooleanFormulaOracle">BooleanFormulaOracle</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/System-IO.html#t:IO">IO</a> ()</li><li class="src short"><a href="#v:main_u">main_u</a> :: <a href="Quipper-Printing.html#t:Format">Format</a> -&gt; <a href="QuipperLib-Decompose-GateBase.html#t:GateBase">GateBase</a> -&gt; <a href="Algorithms-BF-BooleanFormula.html#t:BooleanFormulaOracle">BooleanFormulaOracle</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/System-IO.html#t:IO">IO</a> ()</li><li class="src short"><a href="#v:main_walk">main_walk</a> :: <a href="Quipper-Printing.html#t:Format">Format</a> -&gt; <a href="QuipperLib-Decompose-GateBase.html#t:GateBase">GateBase</a> -&gt; <a href="Algorithms-BF-BooleanFormula.html#t:BooleanFormulaOracle">BooleanFormulaOracle</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/System-IO.html#t:IO">IO</a> ()</li><li class="src short"><a href="#v:main_diffuse">main_diffuse</a> :: <a href="Quipper-Printing.html#t:Format">Format</a> -&gt; <a href="QuipperLib-Decompose-GateBase.html#t:GateBase">GateBase</a> -&gt; <a href="Algorithms-BF-BooleanFormula.html#t:BooleanFormulaOracle">BooleanFormulaOracle</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/System-IO.html#t:IO">IO</a> ()</li><li class="src short"><a href="#v:main_oracle">main_oracle</a> :: <a href="Quipper-Printing.html#t:Format">Format</a> -&gt; <a href="QuipperLib-Decompose-GateBase.html#t:GateBase">GateBase</a> -&gt; <a href="Algorithms-BF-BooleanFormula.html#t:BooleanFormulaOracle">BooleanFormulaOracle</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/System-IO.html#t:IO">IO</a> ()</li><li class="src short"><a href="#v:main_undo_oracle">main_undo_oracle</a> :: <a href="Quipper-Printing.html#t:Format">Format</a> -&gt; <a href="QuipperLib-Decompose-GateBase.html#t:GateBase">GateBase</a> -&gt; <a href="Algorithms-BF-BooleanFormula.html#t:BooleanFormulaOracle">BooleanFormulaOracle</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/System-IO.html#t:IO">IO</a> ()</li><li class="src short"><a href="#v:main_hex">main_hex</a> :: <a href="Quipper-Printing.html#t:Format">Format</a> -&gt; <a href="QuipperLib-Decompose-GateBase.html#t:GateBase">GateBase</a> -&gt; <a href="Algorithms-BF-BooleanFormula.html#t:BooleanFormulaOracle">BooleanFormulaOracle</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/System-IO.html#t:IO">IO</a> ()</li><li class="src short"><a href="#v:main_checkwin_red">main_checkwin_red</a> :: <a href="Quipper-Printing.html#t:Format">Format</a> -&gt; <a href="QuipperLib-Decompose-GateBase.html#t:GateBase">GateBase</a> -&gt; <a href="Algorithms-BF-BooleanFormula.html#t:BooleanFormulaOracle">BooleanFormulaOracle</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/System-IO.html#t:IO">IO</a> ()</li><li class="src short"><a href="#v:main_bf">main_bf</a> :: <a href="Algorithms-BF-BooleanFormula.html#t:BooleanFormulaOracle">BooleanFormulaOracle</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/System-IO.html#t:IO">IO</a> <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Bool.html#t:Bool">Bool</a></li><li class="src short"><a href="#v:whoWins">whoWins</a> :: <a href="Algorithms-BF-BooleanFormula.html#t:BooleanFormulaOracle">BooleanFormulaOracle</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/System-IO.html#t:IO">IO</a> ()</li><li class="src short"><a href="#v:main_whoWins">main_whoWins</a> :: <a href="Algorithms-BF-BooleanFormula.html#t:BooleanFormulaOracle">BooleanFormulaOracle</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/System-IO.html#t:IO">IO</a> ()</li></ul></div><div id="interface"><h1 id="g:1">Classical data structures</h1><h2 id="g:2">Oracle description</h2><div class="doc"><p>We define a data structure to hold the various parameters that
 are used to define an oracle.</p></div><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:BooleanFormulaOracle" class="def">BooleanFormulaOracle</a> <a href="src/Algorithms/BF/BooleanFormula.html#line-37" class="link">Source</a> <a href="#t:BooleanFormulaOracle" class="selflink">#</a></p><div class="doc"><p>The input to the BF Algorithm is the description of an oracle to
 represent a given size of hex board, and a given size for the phase
 estimation register.</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a id="v:BFO" class="def">BFO</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><ul><li><dfn class="src"><a id="v:oracle_x_max" class="def">oracle_x_max</a> :: <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a></dfn><div class="doc"><p>The <em>x</em>-dimension of hex board.</p></div></li><li><dfn class="src"><a id="v:oracle_y_max" class="def">oracle_y_max</a> :: <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a></dfn><div class="doc"><p>The <em>y</em>-dimension of hex board.</p></div></li><li><dfn class="src"><a id="v:oracle_t" class="def">oracle_t</a> :: <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a></dfn><div class="doc"><p>Size of phase estimation register.</p></div></li><li><dfn class="src"><a id="v:oracle_s" class="def">oracle_s</a> :: <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a></dfn><div class="doc"><p>Number of moves remaining.
 This should start as <em>x</em>&#8901;<em>y</em>, if no moves have been made.</p></div></li><li><dfn class="src"><a id="v:oracle_m" class="def">oracle_m</a> :: <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a></dfn><div class="doc"><p>Size of the direction register,
 i.e., size of labels on the BF tree.
 This should be the ceiling of log(<em>x</em>&#8901;<em>y</em>).</p></div></li><li><dfn class="src"><a id="v:start_board" class="def">start_board</a> :: <a href="Algorithms-BF-BooleanFormula.html#t:HexBoard">HexBoard</a></dfn><div class="doc"><p>A description of the starting state of the
 board, and can be used to calculate <em>s</em>.</p></div></li><li><dfn class="src"><a id="v:oracle_hex" class="def">oracle_hex</a> :: <a href="Algorithms-BF-BooleanFormula.html#t:HexCircuit">HexCircuit</a></dfn><div class="doc"><p>An extra flag that we can use so that different
 HEX circuits can be used instead of the full circuit.</p></div></li></ul></div></td></tr></table></div></div><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:HexCircuit" class="def">HexCircuit</a> <a href="src/Algorithms/BF/BooleanFormula.html#line-59" class="link">Source</a> <a href="#t:HexCircuit" class="selflink">#</a></p><div class="doc"><p>A type to define which Hex circuit to use.</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a id="v:Hex" class="def">Hex</a></td><td class="doc"><p>The actual Hex circuit.</p></td></tr><tr><td class="src"><a id="v:Dummy" class="def">Dummy</a></td><td class="doc"><p>A Dummy Hex circuit.</p></td></tr><tr><td class="src"><a id="v:EmptyHex" class="def">EmptyHex</a></td><td class="doc"><p>Nothing.</p></td></tr></table></div></div><div class="top"><p class="src"><a id="v:createOracle" class="def">createOracle</a> :: <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a> -&gt; <a href="Algorithms-BF-BooleanFormula.html#t:BooleanFormulaOracle">BooleanFormulaOracle</a> <a href="src/Algorithms/BF/BooleanFormula.html#line-67" class="link">Source</a> <a href="#v:createOracle" class="selflink">#</a></p><div class="doc"><p>Create an oracle description. This only requires <em>x</em>, <em>y</em>, and
 <em>t</em> to be specified, as the remaining values can be calculated. The number of
 moves remaining, <em>s</em>, is calculated as the total number of squares on the board, 
 and <em>m</em> is calculated as the number of bits required to represent <em>s</em>+1.</p></div></div><div class="top"><p class="src"><a id="v:update_hex" class="def">update_hex</a> :: <a href="Algorithms-BF-BooleanFormula.html#t:BooleanFormulaOracle">BooleanFormulaOracle</a> -&gt; <a href="Algorithms-BF-BooleanFormula.html#t:HexCircuit">HexCircuit</a> -&gt; <a href="Algorithms-BF-BooleanFormula.html#t:BooleanFormulaOracle">BooleanFormulaOracle</a> <a href="src/Algorithms/BF/BooleanFormula.html#line-82" class="link">Source</a> <a href="#v:update_hex" class="selflink">#</a></p><div class="doc"><p>A function to set the &quot;Dummy&quot; flag in the given oracle to the given 
 <code><a href="Algorithms-BF-BooleanFormula.html#t:HexCircuit">HexCircuit</a></code> value.</p></div></div><div class="top"><p class="src"><a id="v:update_start_board" class="def">update_start_board</a> :: <a href="Algorithms-BF-BooleanFormula.html#t:BooleanFormulaOracle">BooleanFormulaOracle</a> -&gt; <a href="Algorithms-BF-BooleanFormula.html#t:HexBoard">HexBoard</a> -&gt; <a href="Algorithms-BF-BooleanFormula.html#t:BooleanFormulaOracle">BooleanFormulaOracle</a> <a href="src/Algorithms/BF/BooleanFormula.html#line-88" class="link">Source</a> <a href="#v:update_start_board" class="selflink">#</a></p><div class="doc"><p>Update the <code><a href="Algorithms-BF-BooleanFormula.html#v:start_board">start_board</a></code> in the given oracle, with the given <code><a href="Algorithms-BF-BooleanFormula.html#t:HexBoard">HexBoard</a></code>. This
 also updates the <code><a href="Algorithms-BF-BooleanFormula.html#v:oracle_s">oracle_s</a></code> field of the oracle to be in line with
 the new <code><a href="Algorithms-BF-BooleanFormula.html#v:start_board">start_board</a></code>.</p></div></div><div class="top"><p class="src"><a id="v:full_oracle" class="def">full_oracle</a> :: <a href="Algorithms-BF-BooleanFormula.html#t:BooleanFormulaOracle">BooleanFormulaOracle</a> <a href="src/Algorithms/BF/BooleanFormula.html#line-99" class="link">Source</a> <a href="#v:full_oracle" class="selflink">#</a></p><div class="doc"><p>An oracle for a 9 by 7 Hex board, with the parameters:
 <em>x</em>=9, <em>y</em>=7, <em>t</em>=189. The calculated values are: <em>s</em>=63, <em>m</em>=6.</p></div></div><div class="top"><p class="src"><a id="v:test_oracle" class="def">test_oracle</a> :: <a href="Algorithms-BF-BooleanFormula.html#t:BooleanFormulaOracle">BooleanFormulaOracle</a> <a href="src/Algorithms/BF/BooleanFormula.html#line-106" class="link">Source</a> <a href="#v:test_oracle" class="selflink">#</a></p><div class="doc"><p>A smaller oracle for testing purposes. The numbers should be
 chosen such that <em>x</em>&#8901;<em>y</em> = 2<sup><em>n</em></sup>&#8722;1 for some <em>n</em>. Here, we set
 <em>x</em>=3 and <em>y</em>=5, to give <em>x</em>&#8901;<em>y</em>=15. We arbitrarily set the size of
 the phase estimation register to <em>t</em>=4.</p></div></div><h2 id="g:3">Hex boards</h2><div class="top"><p class="src"><span class="keyword">type</span> <a id="t:HexBoard" class="def">HexBoard</a> = (&#91;<a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Bool.html#t:Bool">Bool</a>&#93;, &#91;<a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Bool.html#t:Bool">Bool</a>&#93;) <a href="src/Algorithms/BF/BooleanFormula.html#line-115" class="link">Source</a> <a href="#t:HexBoard" class="selflink">#</a></p><div class="doc"><p>A hex board is specified by a pair of lists of booleans.  For a
 board of size <em>x</em> by <em>y</em>, each list should contain <em>x</em>&#8901;<em>y</em>
 elements.  The first list is the &quot;blue&quot; bitmap, and the second is
 the &quot;red&quot; maskmap.</p></div></div><div class="top"><p class="src"><a id="v:moves_made" class="def">moves_made</a> :: <a href="Algorithms-BF-BooleanFormula.html#t:HexBoard">HexBoard</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a> <a href="src/Algorithms/BF/BooleanFormula.html#line-120" class="link">Source</a> <a href="#v:moves_made" class="selflink">#</a></p><div class="doc"><p>A function to determine how many moves have been made on a given HexBoard.
 This function assumes that the given <code><a href="Algorithms-BF-BooleanFormula.html#t:HexBoard">HexBoard</a></code> is valid, in the sense that
 no duplicate moves have been made.</p></div></div><div class="top"><p class="src"><a id="v:empty_spaces" class="def">empty_spaces</a> :: <a href="Algorithms-BF-BooleanFormula.html#t:HexBoard">HexBoard</a> -&gt; &#91;<a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a>&#93; <a href="src/Algorithms/BF/BooleanFormula.html#line-128" class="link">Source</a> <a href="#v:empty_spaces" class="selflink">#</a></p><div class="doc"><p>A function to determine which spaces are still empty in the given HexBoard.
 This function assumes that the given <code><a href="Algorithms-BF-BooleanFormula.html#t:HexBoard">HexBoard</a></code> is valid, in the sense that
 no duplicate moves have been made. This function will return a list of all the 
 empty spaces remaining, in strictly increasing order.</p></div></div><h1 id="g:4">Quantum data structures</h1><div class="doc"><p>Some data structures to help in defining the algorithm.</p></div><div class="top"><p class="src"><span class="keyword">type</span> <a id="t:PhaseEstimationRegister" class="def">PhaseEstimationRegister</a> = &#91;<a href="Quipper-Monad.html#t:Qubit">Qubit</a>&#93; <a href="src/Algorithms/BF/BooleanFormula.html#line-145" class="link">Source</a> <a href="#t:PhaseEstimationRegister" class="selflink">#</a></p><div class="doc"><p>The phase estimation register is a simple register of qubits. This is kept
 separate from the rest of the <code><a href="Algorithms-BF-BooleanFormula.html#t:BooleanFormulaRegister">BooleanFormulaRegister</a></code> as it is this register
 which will be measured at the end of the algorithm.</p></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a id="t:GenericDirectionRegister" class="def">GenericDirectionRegister</a> a = &#91;a&#93; <a href="src/Algorithms/BF/BooleanFormula.html#line-149" class="link">Source</a> <a href="#t:GenericDirectionRegister" class="selflink">#</a></p><div class="doc"><p>The direction register is a simple register of qubits, 
   made explicit here so we can see that a &quot;position&quot; is a list of directions.</p></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a id="t:DirectionRegister" class="def">DirectionRegister</a> = <a href="Algorithms-BF-BooleanFormula.html#t:GenericDirectionRegister">GenericDirectionRegister</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a> <a href="src/Algorithms/BF/BooleanFormula.html#line-153" class="link">Source</a> <a href="#t:DirectionRegister" class="selflink">#</a></p><div class="doc"><p>A type synonym defined as the <code><a href="Quipper-Monad.html#t:Qubit">Qubit</a></code> instance of a
 <code><a href="Algorithms-BF-BooleanFormula.html#t:GenericDirectionRegister">GenericDirectionRegister</a></code>.</p></div></div><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:GenericBooleanFormulaRegister" class="def">GenericBooleanFormulaRegister</a> a <a href="src/Algorithms/BF/BooleanFormula.html#line-157" class="link">Source</a> <a href="#t:GenericBooleanFormulaRegister" class="selflink">#</a></p><div class="doc"><p>The rest of the boolean formula algorithm requires a register which is 
 split into 3 main parts.</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a id="v:BFR" class="def">BFR</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><ul><li><dfn class="src"><a id="v:position_flags" class="def">position_flags</a> :: (a, a)</dfn><div class="doc"><p>The position register is split into two parts:
 the leaf and paraleaf &quot;flags&quot;.</p></div></li><li><dfn class="src"><a id="v:position" class="def">position</a> :: &#91;<a href="Algorithms-BF-BooleanFormula.html#t:GenericDirectionRegister">GenericDirectionRegister</a> a&#93;</dfn><div class="doc"><p>The current position, and how we got there, i.e., directions we followed.
 Any position can be reached by at most <em>x</em>&#8901;<em>y</em> directions.</p></div></li><li><dfn class="src"><a id="v:work_leaf" class="def">work_leaf</a> :: a</dfn><div class="doc empty">&nbsp;</div></li><li><dfn class="src"><a id="v:work_paraleaf" class="def">work_paraleaf</a> :: a</dfn><div class="doc empty">&nbsp;</div></li><li><dfn class="src"><a id="v:work_binary" class="def">work_binary</a> :: a</dfn><div class="doc empty">&nbsp;</div></li><li><dfn class="src"><a id="v:work_height" class="def">work_height</a> :: a</dfn><div class="doc empty">&nbsp;</div></li><li><dfn class="src"><a id="v:work_r" class="def">work_r</a> :: a</dfn><div class="doc empty">&nbsp;</div></li><li><dfn class="src"><a id="v:work_rp" class="def">work_rp</a> :: a</dfn><div class="doc empty">&nbsp;</div></li><li><dfn class="src"><a id="v:work_rpp" class="def">work_rpp</a> :: a</dfn><div class="doc"><p>Seven flags that make up the work register.  </p></div></li><li><dfn class="src"><a id="v:direction" class="def">direction</a> :: <a href="Algorithms-BF-BooleanFormula.html#t:GenericDirectionRegister">GenericDirectionRegister</a> a</dfn><div class="doc"><p>The direction register.</p></div></li></ul></div></td></tr></table></div><div class="subs instances"><p id="control.i:GenericBooleanFormulaRegister" class="caption collapser" onclick="toggleSection('i:GenericBooleanFormulaRegister')">Instances</p><div id="section.i:GenericBooleanFormulaRegister" class="show"><table><tr><td class="src clearfix"><span class="inst-left"><span id="control.i:id:GenericBooleanFormulaRegister:Show:1" class="instance expander" onclick="toggleSection('i:id:GenericBooleanFormulaRegister:Show:1')"></span> <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Text-Show.html#t:Show">Show</a> a =&gt; <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Text-Show.html#t:Show">Show</a> (<a href="Algorithms-BF-BooleanFormula.html#t:GenericBooleanFormulaRegister">GenericBooleanFormulaRegister</a> a)</span> <a href="#t:GenericBooleanFormulaRegister" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div id="section.i:id:GenericBooleanFormulaRegister:Show:1" class="inst-details hide"><div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:showsPrec">showsPrec</a> :: <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a> -&gt; <a href="Algorithms-BF-BooleanFormula.html#t:GenericBooleanFormulaRegister">GenericBooleanFormulaRegister</a> a -&gt; <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Text-Show.html#t:ShowS">ShowS</a> <a href="#v:showsPrec" class="selflink">#</a></p><p class="src"><a href="#v:show">show</a> :: <a href="Algorithms-BF-BooleanFormula.html#t:GenericBooleanFormulaRegister">GenericBooleanFormulaRegister</a> a -&gt; <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-String.html#t:String">String</a> <a href="#v:show" class="selflink">#</a></p><p class="src"><a href="#v:showList">showList</a> :: &#91;<a href="Algorithms-BF-BooleanFormula.html#t:GenericBooleanFormulaRegister">GenericBooleanFormulaRegister</a> a&#93; -&gt; <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Text-Show.html#t:ShowS">ShowS</a> <a href="#v:showList" class="selflink">#</a></p></div></div></td></tr><tr><td class="src clearfix"><span class="inst-left"><span id="control.i:id:GenericBooleanFormulaRegister:QCData:2" class="instance expander" onclick="toggleSection('i:id:GenericBooleanFormulaRegister:QCData:2')"></span> <a href="Quipper-QData.html#t:QCData">QCData</a> a =&gt; <a href="Quipper-QData.html#t:QCData">QCData</a> (<a href="Algorithms-BF-BooleanFormula.html#t:GenericBooleanFormulaRegister">GenericBooleanFormulaRegister</a> a)</span> <a href="#t:GenericBooleanFormulaRegister" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div id="section.i:id:GenericBooleanFormulaRegister:QCData:2" class="inst-details hide"><div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:qcdata_mapM">qcdata_mapM</a> :: <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="Algorithms-BF-BooleanFormula.html#t:GenericBooleanFormulaRegister">GenericBooleanFormulaRegister</a> a -&gt; (q -&gt; m q') -&gt; (c -&gt; m c') -&gt; <a href="Quipper-QData.html#t:QCType">QCType</a> q c (<a href="Algorithms-BF-BooleanFormula.html#t:GenericBooleanFormulaRegister">GenericBooleanFormulaRegister</a> a) -&gt; m (<a href="Quipper-QData.html#t:QCType">QCType</a> q' c' (<a href="Algorithms-BF-BooleanFormula.html#t:GenericBooleanFormulaRegister">GenericBooleanFormulaRegister</a> a)) <a href="src/Quipper/QData.html#line-" class="link">Source</a> <a href="#v:qcdata_mapM" class="selflink">#</a></p><p class="src"><a href="#v:qcdata_zip">qcdata_zip</a> :: <a href="Algorithms-BF-BooleanFormula.html#t:GenericBooleanFormulaRegister">GenericBooleanFormulaRegister</a> a -&gt; q -&gt; c -&gt; q' -&gt; c' -&gt; <a href="Quipper-QData.html#t:QCType">QCType</a> q c (<a href="Algorithms-BF-BooleanFormula.html#t:GenericBooleanFormulaRegister">GenericBooleanFormulaRegister</a> a) -&gt; <a href="Quipper-QData.html#t:QCType">QCType</a> q' c' (<a href="Algorithms-BF-BooleanFormula.html#t:GenericBooleanFormulaRegister">GenericBooleanFormulaRegister</a> a) -&gt; <a href="Libraries-Auxiliary.html#t:ErrMsg">ErrMsg</a> -&gt; <a href="Quipper-QData.html#t:QCType">QCType</a> (q, q') (c, c') (<a href="Algorithms-BF-BooleanFormula.html#t:GenericBooleanFormulaRegister">GenericBooleanFormulaRegister</a> a) <a href="src/Quipper/QData.html#line-" class="link">Source</a> <a href="#v:qcdata_zip" class="selflink">#</a></p><p class="src"><a href="#v:qcdata_promote">qcdata_promote</a> :: <a href="Quipper-QData.html#t:BType">BType</a> (<a href="Algorithms-BF-BooleanFormula.html#t:GenericBooleanFormulaRegister">GenericBooleanFormulaRegister</a> a) -&gt; <a href="Algorithms-BF-BooleanFormula.html#t:GenericBooleanFormulaRegister">GenericBooleanFormulaRegister</a> a -&gt; <a href="Libraries-Auxiliary.html#t:ErrMsg">ErrMsg</a> -&gt; <a href="Quipper-QData.html#t:BType">BType</a> (<a href="Algorithms-BF-BooleanFormula.html#t:GenericBooleanFormulaRegister">GenericBooleanFormulaRegister</a> a) <a href="src/Quipper/QData.html#line-" class="link">Source</a> <a href="#v:qcdata_promote" class="selflink">#</a></p></div></div></td></tr><tr><td class="src clearfix"><span class="inst-left"><span id="control.i:id:GenericBooleanFormulaRegister:Labelable:3" class="instance expander" onclick="toggleSection('i:id:GenericBooleanFormulaRegister:Labelable:3')"></span> <a href="Quipper-Labels.html#t:Labelable">Labelable</a> a <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-String.html#t:String">String</a> =&gt; <a href="Quipper-Labels.html#t:Labelable">Labelable</a> (<a href="Algorithms-BF-BooleanFormula.html#t:GenericBooleanFormulaRegister">GenericBooleanFormulaRegister</a> a) <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-String.html#t:String">String</a></span> <a href="#t:GenericBooleanFormulaRegister" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div id="section.i:id:GenericBooleanFormulaRegister:Labelable:3" class="inst-details hide"><div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:label_rec">label_rec</a> :: <a href="Algorithms-BF-BooleanFormula.html#t:GenericBooleanFormulaRegister">GenericBooleanFormulaRegister</a> a -&gt; <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-String.html#t:String">String</a> -&gt; <a href="Quipper-Labels.html#t:LabelMonad">LabelMonad</a> () <a href="src/Quipper/Labels.html#line-" class="link">Source</a> <a href="#v:label_rec" class="selflink">#</a></p></div></div></td></tr><tr><td class="src clearfix"><span class="inst-left"><span id="control.i:id:GenericBooleanFormulaRegister:QCType:4" class="instance expander" onclick="toggleSection('i:id:GenericBooleanFormulaRegister:QCType:4')"></span> <span class="keyword">type</span> <a href="Quipper-QData.html#t:QCType">QCType</a> x y (<a href="Algorithms-BF-BooleanFormula.html#t:GenericBooleanFormulaRegister">GenericBooleanFormulaRegister</a> a)</span> <a href="#t:GenericBooleanFormulaRegister" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div id="section.i:id:GenericBooleanFormulaRegister:QCType:4" class="inst-details hide"><div class="src"><span class="keyword">type</span> <a href="Quipper-QData.html#t:QCType">QCType</a> x y (<a href="Algorithms-BF-BooleanFormula.html#t:GenericBooleanFormulaRegister">GenericBooleanFormulaRegister</a> a) = <a href="Algorithms-BF-BooleanFormula.html#t:GenericBooleanFormulaRegister">GenericBooleanFormulaRegister</a> (<a href="Quipper-QData.html#t:QCType">QCType</a> x y a)</div></div></td></tr><tr><td class="src clearfix"><span class="inst-left"><span id="control.i:id:GenericBooleanFormulaRegister:QTypeB:5" class="instance expander" onclick="toggleSection('i:id:GenericBooleanFormulaRegister:QTypeB:5')"></span> <span class="keyword">type</span> <a href="Quipper-QData.html#t:QTypeB">QTypeB</a> (<a href="Algorithms-BF-BooleanFormula.html#t:GenericBooleanFormulaRegister">GenericBooleanFormulaRegister</a> a)</span> <a href="#t:GenericBooleanFormulaRegister" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div id="section.i:id:GenericBooleanFormulaRegister:QTypeB:5" class="inst-details hide"><div class="src"><span class="keyword">type</span> <a href="Quipper-QData.html#t:QTypeB">QTypeB</a> (<a href="Algorithms-BF-BooleanFormula.html#t:GenericBooleanFormulaRegister">GenericBooleanFormulaRegister</a> a) = <a href="Algorithms-BF-BooleanFormula.html#t:GenericBooleanFormulaRegister">GenericBooleanFormulaRegister</a> (<a href="Quipper-QData.html#t:QTypeB">QTypeB</a> a)</div></div></td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a id="t:BooleanFormulaRegister" class="def">BooleanFormulaRegister</a> = <a href="Algorithms-BF-BooleanFormula.html#t:GenericBooleanFormulaRegister">GenericBooleanFormulaRegister</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a> <a href="src/Algorithms/BF/BooleanFormula.html#line-177" class="link">Source</a> <a href="#t:BooleanFormulaRegister" class="selflink">#</a></p><div class="doc"><p>A type synonym defined as the <code><a href="Quipper-Monad.html#t:Qubit">Qubit</a></code> instantiation of a 
 <code><a href="Algorithms-BF-BooleanFormula.html#t:GenericBooleanFormulaRegister">GenericBooleanFormulaRegister</a></code>.</p></div></div><div class="top"><p class="src"><a id="v:labelBFR" class="def">labelBFR</a> :: <a href="Algorithms-BF-BooleanFormula.html#t:BooleanFormulaRegister">BooleanFormulaRegister</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> () <a href="src/Algorithms/BF/BooleanFormula.html#line-181" class="link">Source</a> <a href="#v:labelBFR" class="selflink">#</a></p><div class="doc"><p>A function to add labels to the wires that make up a <code><a href="Algorithms-BF-BooleanFormula.html#t:BooleanFormulaRegister">BooleanFormulaRegister</a></code>.
 These labels correspond to the parts of the register. </p></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a id="t:BoolRegister" class="def">BoolRegister</a> = <a href="Algorithms-BF-BooleanFormula.html#t:GenericBooleanFormulaRegister">GenericBooleanFormulaRegister</a> <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Bool.html#t:Bool">Bool</a> <a href="src/Algorithms/BF/BooleanFormula.html#line-191" class="link">Source</a> <a href="#t:BoolRegister" class="selflink">#</a></p><div class="doc"><p>A type synonym defined as the <code><a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Bool.html#t:Bool">Bool</a></code> instantiation of a 
 <code><a href="Algorithms-BF-BooleanFormula.html#t:GenericBooleanFormulaRegister">GenericBooleanFormulaRegister</a></code>.</p></div></div><div class="top"><p class="src"><a id="v:toTuple" class="def">toTuple</a> :: <a href="Algorithms-BF-BooleanFormula.html#t:GenericBooleanFormulaRegister">GenericBooleanFormulaRegister</a> a -&gt; ((a, a), &#91;&#91;a&#93;&#93;, (a, a, a, a, a, a, a), &#91;a&#93;) <a href="src/Algorithms/BF/BooleanFormula.html#line-195" class="link">Source</a> <a href="#v:toTuple" class="selflink">#</a></p><div class="doc"><p>Helper function to simplify the <code><a href="Quipper-QData.html#t:QCData">QCData</a></code> instance for <code><a href="Algorithms-BF-BooleanFormula.html#t:BooleanFormulaRegister">BooleanFormulaRegister</a></code>. 
 Create a tuple from a <code><a href="Algorithms-BF-BooleanFormula.html#t:GenericBooleanFormulaRegister">GenericBooleanFormulaRegister</a></code>.</p></div></div><div class="top"><p class="src"><a id="v:fromTuple" class="def">fromTuple</a> :: ((a, a), &#91;&#91;a&#93;&#93;, (a, a, a, a, a, a, a), &#91;a&#93;) -&gt; <a href="Algorithms-BF-BooleanFormula.html#t:GenericBooleanFormulaRegister">GenericBooleanFormulaRegister</a> a <a href="src/Algorithms/BF/BooleanFormula.html#line-200" class="link">Source</a> <a href="#v:fromTuple" class="selflink">#</a></p><div class="doc"><p>Helper function to simplify the <code><a href="Quipper-QData.html#t:QCData">QCData</a></code> instance for <code><a href="Algorithms-BF-BooleanFormula.html#t:BooleanFormulaRegister">BooleanFormulaRegister</a></code>. 
 Create a <code><a href="Algorithms-BF-BooleanFormula.html#t:GenericBooleanFormulaRegister">GenericBooleanFormulaRegister</a></code> from a tuple.</p></div></div><div class="top"><p class="src"><a id="v:createRegister" class="def">createRegister</a> :: <a href="Algorithms-BF-BooleanFormula.html#t:BooleanFormulaOracle">BooleanFormulaOracle</a> -&gt; <a href="Algorithms-BF-BooleanFormula.html#t:BoolRegister">BoolRegister</a> <a href="src/Algorithms/BF/BooleanFormula.html#line-241" class="link">Source</a> <a href="#v:createRegister" class="selflink">#</a></p><div class="doc"><p>Create an initial classical <code><a href="Algorithms-BF-BooleanFormula.html#t:BooleanFormulaRegister">BooleanFormulaRegister</a></code> for a given oracle description.
 The <em>position</em> register is initialized in the <em>zero</em> state that represents being
 at label <em>zero</em>, or node <em>rpp</em> in the tree. The work qubits are all initialized to
 <em>zero</em>, as the first call to the <em>oracle</em> circuit will set them accordingly for
 the <em>position</em> we are currently in. The <em>direction</em> register is also set to <em>zero</em>
 as this is the direction in which the node <em>rp</em> is in. The given
 <code><a href="Algorithms-BF-BooleanFormula.html#t:BooleanFormulaOracle">BooleanFormulaOracle</a></code> is used to make sure the registers are of the correct
 size, i.e., number of qubits.</p></div></div><div class="top"><p class="src"><a id="v:registerShape" class="def">registerShape</a> :: <a href="Algorithms-BF-BooleanFormula.html#t:BooleanFormulaOracle">BooleanFormulaOracle</a> -&gt; <a href="Algorithms-BF-BooleanFormula.html#t:BooleanFormulaRegister">BooleanFormulaRegister</a> <a href="src/Algorithms/BF/BooleanFormula.html#line-259" class="link">Source</a> <a href="#v:registerShape" class="selflink">#</a></p><div class="doc"><p>Create a shape parameter for a <code><a href="Algorithms-BF-BooleanFormula.html#t:BooleanFormulaRegister">BooleanFormulaRegister</a></code> of the
 correct size.</p></div></div><div class="top"><p class="src"><a id="v:initializeRegister" class="def">initializeRegister</a> :: <a href="Algorithms-BF-BooleanFormula.html#t:BooleanFormulaOracle">BooleanFormulaOracle</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> <a href="Algorithms-BF-BooleanFormula.html#t:BooleanFormulaRegister">BooleanFormulaRegister</a> <a href="src/Algorithms/BF/BooleanFormula.html#line-263" class="link">Source</a> <a href="#v:initializeRegister" class="selflink">#</a></p><div class="doc"><p>Initialize a <code><a href="Algorithms-BF-BooleanFormula.html#t:BooleanFormulaRegister">BooleanFormulaRegister</a></code> from a <code><a href="Algorithms-BF-BooleanFormula.html#t:BooleanFormulaOracle">BooleanFormulaOracle</a></code>. </p></div></div><h1 id="g:5">Oracle implementation</h1><div class="doc"><p>The functions in this implementation follow a separation of the boolean
 formula algorithm into two parts. The first part corresponds to the 
 algorithms defined in this module. The second part consists of the 
 algorithms defined in <a href="Algorithms-BF-Hex.html">Algorithms.BF.Hex</a>. This separation relates to the 
 first part defining the quantum parts of the algorithm, including the 
 phase estimation, and the quantum walk, whereas the remaining four define 
 the classical implementation of the circuit for determining which player 
 has won a completed game of Hex, which is converted to a quantum circuit 
 using Quipper's &quot;build_circuit&quot; keyword.</p><p>Note that the circuits for the algorithms in this module have been tested
 for performing a quantum walk on the tree defined for a given oracle (but 
 with a dummy function taking the place of the call to HEX).</p></div><div class="top"><p class="src"><a id="v:qw_bf" class="def">qw_bf</a> :: <a href="Algorithms-BF-BooleanFormula.html#t:BooleanFormulaOracle">BooleanFormulaOracle</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> &#91;<a href="Quipper-Monad.html#t:Bit">Bit</a>&#93; <a href="src/Algorithms/BF/BooleanFormula.html#line-288" class="link">Source</a> <a href="#v:qw_bf" class="selflink">#</a></p><div class="doc"><p>The overall Boolean Formula Algorithm. It initializes the
 phase estimation register into an equal super-position of all 2<sup>t</sup> states,
 and the other registers as defined previously. It then maps the exponentiated
 version of the unitary <em>u</em>, as per phase estimation, before applying the 
 inverse QFT, and measuring the result.</p></div></div><div class="top"><p class="src"><a id="v:subroutine_inverse_qft" class="def">subroutine_inverse_qft</a> :: <a href="Algorithms-BF-BooleanFormula.html#t:BooleanFormulaOracle">BooleanFormulaOracle</a> -&gt; &#91;<a href="Quipper-Monad.html#t:Qubit">Qubit</a>&#93; -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> &#91;<a href="Quipper-Monad.html#t:Qubit">Qubit</a>&#93; <a href="src/Algorithms/BF/BooleanFormula.html#line-310" class="link">Source</a> <a href="#v:subroutine_inverse_qft" class="selflink">#</a></p><div class="doc"><p>The inverse quantum Fourier transform as a boxed subroutine.</p></div></div><div class="top"><p class="src"><a id="v:map_exp_u" class="def">map_exp_u</a> :: <a href="Algorithms-BF-BooleanFormula.html#t:BooleanFormulaOracle">BooleanFormulaOracle</a> -&gt; &#91;<a href="Quipper-Monad.html#t:Qubit">Qubit</a>&#93; -&gt; <a href="Algorithms-BF-BooleanFormula.html#t:BooleanFormulaRegister">BooleanFormulaRegister</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> () <a href="src/Algorithms/BF/BooleanFormula.html#line-317" class="link">Source</a> <a href="#v:map_exp_u" class="selflink">#</a></p><div class="doc"><p>&quot;Map&quot; the application of the exponentiated unitary <em>u</em>
 over the phase estimation register. That is, each qubit in the phase estimation
 register is used as a control over a call to the unitary <em>u</em>, exponentiated to
 the appropriate power.</p></div></div><div class="top"><p class="src"><a id="v:exp_u" class="def">exp_u</a> :: <a href="Algorithms-BF-BooleanFormula.html#t:BooleanFormulaOracle">BooleanFormulaOracle</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Prelude.html#t:Integer">Integer</a> -&gt; <a href="Algorithms-BF-BooleanFormula.html#t:BooleanFormulaRegister">BooleanFormulaRegister</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> () <a href="src/Algorithms/BF/BooleanFormula.html#line-327" class="link">Source</a> <a href="#v:exp_u" class="selflink">#</a></p><div class="doc"><p>Exponentiate the unitary <em>u</em>. In this implementation, this is
 achieved by repeated application of <em>u</em>.</p></div></div><div class="top"><p class="src"><a id="v:u" class="def">u</a> :: <a href="Algorithms-BF-BooleanFormula.html#t:BooleanFormulaOracle">BooleanFormulaOracle</a> -&gt; <a href="Algorithms-BF-BooleanFormula.html#t:BooleanFormulaRegister">BooleanFormulaRegister</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> () <a href="src/Algorithms/BF/BooleanFormula.html#line-340" class="link">Source</a> <a href="#v:u" class="selflink">#</a></p><div class="doc"><p>The unitary <em>u</em> represents a single step in the walk on the NAND tree. A call
 to the oracle determines what type of node we are at (so we know which directions
 are valid to step to), the call to diffuse sets the direction register to be a
 super-position of all valid directions, the call to walk performs the step, and then
 the call to undo oracle has to clean up the work registers that were set by the
 call to the oracle. Note that the undo oracle step is not simply the inverse of the
 oracle, as we have walked since the oracle was called.</p></div></div><div class="top"><p class="src"><a id="v:subroutine_u" class="def">subroutine_u</a> :: <a href="Algorithms-BF-BooleanFormula.html#t:BooleanFormulaOracle">BooleanFormulaOracle</a> -&gt; <a href="Algorithms-BF-BooleanFormula.html#t:BooleanFormulaRegister">BooleanFormulaRegister</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> () <a href="src/Algorithms/BF/BooleanFormula.html#line-350" class="link">Source</a> <a href="#v:subroutine_u" class="selflink">#</a></p><div class="doc"><p>The circuit for <code><a href="Algorithms-BF-BooleanFormula.html#v:u">u</a></code> as a boxed subroutine.</p></div></div><div class="top"><p class="src"><a id="v:oracle" class="def">oracle</a> :: <a href="Algorithms-BF-BooleanFormula.html#t:BooleanFormulaOracle">BooleanFormulaOracle</a> -&gt; <a href="Algorithms-BF-BooleanFormula.html#t:BooleanFormulaRegister">BooleanFormulaRegister</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> () <a href="src/Algorithms/BF/BooleanFormula.html#line-359" class="link">Source</a> <a href="#v:oracle" class="selflink">#</a></p><div class="doc"><p>Call the oracle to determine some extra information about where
 we are in the tree. Essentially, the special cases are when were are at one of
 the three &quot;low height&quot; nodes, or when we are at a node representing a complete 
 game of Hex, and we need to determine if this is a leaf, by calling the hex circuit,
 which determines whether the node represents a completed game of hex in which
 the red player has won.  </p></div></div><div class="top"><p class="src"><a id="v:subroutine_oracle" class="def">subroutine_oracle</a> :: <a href="Algorithms-BF-BooleanFormula.html#t:BooleanFormulaOracle">BooleanFormulaOracle</a> -&gt; <a href="Algorithms-BF-BooleanFormula.html#t:BooleanFormulaRegister">BooleanFormulaRegister</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> () <a href="src/Algorithms/BF/BooleanFormula.html#line-435" class="link">Source</a> <a href="#v:subroutine_oracle" class="selflink">#</a></p><div class="doc"><p>The circuit for the <code><a href="Algorithms-BF-BooleanFormula.html#v:oracle">oracle</a></code> as a boxed subroutine.</p></div></div><div class="top"><p class="src"><a id="v:controls" class="def">controls</a> :: <a href="Quipper-Monad.html#t:Qubit">Qubit</a> -&gt; &#91;<a href="Algorithms-BF-BooleanFormula.html#t:DirectionRegister">DirectionRegister</a>&#93; -&gt; &#91;<a href="Quipper-Control.html#t:ControlList">ControlList</a>&#93; <a href="src/Algorithms/BF/BooleanFormula.html#line-439" class="link">Source</a> <a href="#v:controls" class="selflink">#</a></p><div class="doc"><p>The controls to use, to see if we're at a &quot;low height&quot; node.</p></div></div><div class="top"><p class="src"><a id="v:diffuse" class="def">diffuse</a> :: <a href="Algorithms-BF-BooleanFormula.html#t:BooleanFormulaRegister">BooleanFormulaRegister</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> () <a href="src/Algorithms/BF/BooleanFormula.html#line-450" class="link">Source</a> <a href="#v:diffuse" class="selflink">#</a></p><div class="doc"><p>Diffuse the direction register, to be a super-position of all valid
 directions from the current node. Note, that this implementation of the boolean
 formula algorithm does not applying the correct weighting scheme to the NAND graph,
 which would require this function to diffuse with respect to the weighting scheme.</p></div></div><div class="top"><p class="src"><a id="v:subroutine_diffuse" class="def">subroutine_diffuse</a> :: <a href="Algorithms-BF-BooleanFormula.html#t:BooleanFormulaOracle">BooleanFormulaOracle</a> -&gt; <a href="Algorithms-BF-BooleanFormula.html#t:BooleanFormulaRegister">BooleanFormulaRegister</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> () <a href="src/Algorithms/BF/BooleanFormula.html#line-472" class="link">Source</a> <a href="#v:subroutine_diffuse" class="selflink">#</a></p><div class="doc"><p>The circuit for <code><a href="Algorithms-BF-BooleanFormula.html#v:diffuse">diffuse</a></code> as a boxed subroutine.</p></div></div><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:Where" class="def">Where</a> <a href="src/Algorithms/BF/BooleanFormula.html#line-478" class="link">Source</a> <a href="#t:Where" class="selflink">#</a></p><div class="doc"><p>A datatype to use instead of passing integers to <code><a href="Algorithms-BF-BooleanFormula.html#v:toParent">toParent</a></code> and <code><a href="Algorithms-BF-BooleanFormula.html#v:toChild">toChild</a></code>
 to define what needs to be shifted. This is used as only three different
 shift widths are ever used in the algorithm.</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a id="v:Width" class="def">Width</a></td><td class="doc"><p>corresponds to shifting all qubits.</p></td></tr><tr><td class="src"><a id="v:M" class="def">M</a></td><td class="doc"><p>corresponds to shifting only <em>m</em>+1 qubits.</p></td></tr><tr><td class="src"><a id="v:M2" class="def">M2</a></td><td class="doc"><p>corresponds to shifting only 2<em>m</em>+1 qubits.</p></td></tr></table></div><div class="subs instances"><p id="control.i:Where" class="caption collapser" onclick="toggleSection('i:Where')">Instances</p><div id="section.i:Where" class="show"><table><tr><td class="src clearfix"><span class="inst-left"><span id="control.i:id:Where:Eq:1" class="instance expander" onclick="toggleSection('i:id:Where:Eq:1')"></span> <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Eq.html#t:Eq">Eq</a> <a href="Algorithms-BF-BooleanFormula.html#t:Where">Where</a></span> <a href="#t:Where" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div id="section.i:id:Where:Eq:1" class="inst-details hide"><div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:-61--61-">(==)</a> :: <a href="Algorithms-BF-BooleanFormula.html#t:Where">Where</a> -&gt; <a href="Algorithms-BF-BooleanFormula.html#t:Where">Where</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Bool.html#t:Bool">Bool</a> <a href="#v:-61--61-" class="selflink">#</a></p><p class="src"><a href="#v:-47--61-">(/=)</a> :: <a href="Algorithms-BF-BooleanFormula.html#t:Where">Where</a> -&gt; <a href="Algorithms-BF-BooleanFormula.html#t:Where">Where</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Bool.html#t:Bool">Bool</a> <a href="#v:-47--61-" class="selflink">#</a></p></div></div></td></tr></table></div></div></div><div class="top"><p class="src"><a id="v:walk" class="def">walk</a> :: <a href="Algorithms-BF-BooleanFormula.html#t:BooleanFormulaRegister">BooleanFormulaRegister</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> () <a href="src/Algorithms/BF/BooleanFormula.html#line-489" class="link">Source</a> <a href="#v:walk" class="selflink">#</a></p><div class="doc"><p>Define a step on the NAND graph, in the direction specified 
 by the direction register, and updates the direction register to be where
 we have stepped from.
 For this algorithm we have developed the <code><a href="Algorithms-BF-QuantumIf.html#v:if_then_elseQ">if_then_elseQ</a></code> construct, which
 gives us a nice way of constructing if/else statements acting on
 &quot;boolean statements&quot; over qubits (see <a href="Algorithms-BF-QuantumIf.html">Algorithms.BF.QuantumIf</a>).</p></div></div><div class="top"><p class="src"><a id="v:subroutine_walk" class="def">subroutine_walk</a> :: <a href="Algorithms-BF-BooleanFormula.html#t:BooleanFormulaOracle">BooleanFormulaOracle</a> -&gt; <a href="Algorithms-BF-BooleanFormula.html#t:BooleanFormulaRegister">BooleanFormulaRegister</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> () <a href="src/Algorithms/BF/BooleanFormula.html#line-607" class="link">Source</a> <a href="#v:subroutine_walk" class="selflink">#</a></p><div class="doc"><p>The circuit for <code><a href="Algorithms-BF-BooleanFormula.html#v:walk">walk</a></code> as a boxed subroutine.</p></div></div><div class="top"><p class="src"><a id="v:undo_oracle" class="def">undo_oracle</a> :: <a href="Algorithms-BF-BooleanFormula.html#t:BooleanFormulaOracle">BooleanFormulaOracle</a> -&gt; <a href="Algorithms-BF-BooleanFormula.html#t:BooleanFormulaRegister">BooleanFormulaRegister</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> () <a href="src/Algorithms/BF/BooleanFormula.html#line-613" class="link">Source</a> <a href="#v:undo_oracle" class="selflink">#</a></p><div class="doc"><p>Uncompute the various flags that were set by the initial call
 to the oracle. It has to uncompute the flags depending on where we were before
 the walk step, so isn't just the inverse of the oracle.</p></div></div><div class="top"><p class="src"><a id="v:subroutine_undo_oracle" class="def">subroutine_undo_oracle</a> :: <a href="Algorithms-BF-BooleanFormula.html#t:BooleanFormulaOracle">BooleanFormulaOracle</a> -&gt; <a href="Algorithms-BF-BooleanFormula.html#t:BooleanFormulaRegister">BooleanFormulaRegister</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> () <a href="src/Algorithms/BF/BooleanFormula.html#line-705" class="link">Source</a> <a href="#v:subroutine_undo_oracle" class="selflink">#</a></p><div class="doc"><p>The circuit for <code><a href="Algorithms-BF-BooleanFormula.html#v:undo_oracle">undo_oracle</a></code> as a boxed subroutine.</p></div></div><div class="top"><p class="src"><a id="v:toParent" class="def">toParent</a> :: <a href="Algorithms-BF-BooleanFormula.html#t:Where">Where</a> -&gt; <a href="Algorithms-BF-BooleanFormula.html#t:BooleanFormulaRegister">BooleanFormulaRegister</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> () <a href="src/Algorithms/BF/BooleanFormula.html#line-710" class="link">Source</a> <a href="#v:toParent" class="selflink">#</a></p><div class="doc"><p>Define the circuit that updates the position register to be the
 parent node of the current position.</p></div></div><div class="top"><p class="src"><a id="v:copy_from_to" class="def">copy_from_to</a> :: <a href="Quipper-Monad.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper-Monad.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> (<a href="Quipper-Monad.html#t:Qubit">Qubit</a>, <a href="Quipper-Monad.html#t:Qubit">Qubit</a>) <a href="src/Algorithms/BF/BooleanFormula.html#line-740" class="link">Source</a> <a href="#v:copy_from_to" class="selflink">#</a></p><div class="doc"><p><code><code><a href="Algorithms-BF-BooleanFormula.html#v:copy_from_to">copy_from_to</a></code> a b</code>: Sets the state of qubit <em>b</em> to be the state of qubit <em>a</em>,
   (and the state of <em>a</em> is lost in the process, so this is not cloning).
   It falls short of swapping <em>a</em> and <em>b</em>, as we're not interested in preserving <em>a</em>.</p></div></div><div class="top"><p class="src"><a id="v:toChild" class="def">toChild</a> :: <a href="Algorithms-BF-BooleanFormula.html#t:Where">Where</a> -&gt; <a href="Algorithms-BF-BooleanFormula.html#t:BooleanFormulaRegister">BooleanFormulaRegister</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> () <a href="src/Algorithms/BF/BooleanFormula.html#line-748" class="link">Source</a> <a href="#v:toChild" class="selflink">#</a></p><div class="doc"><p>Define the circuit that updates the position register to be the
 child node of the current position.</p></div></div><div class="top"><p class="src"><a id="v:shift_left" class="def">shift_left</a> :: &#91;<a href="Algorithms-BF-BooleanFormula.html#t:DirectionRegister">DirectionRegister</a>&#93; -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> () <a href="src/Algorithms/BF/BooleanFormula.html#line-784" class="link">Source</a> <a href="#v:shift_left" class="selflink">#</a></p><div class="doc"><p>Shift every qubit in a register to the left by one. </p></div></div><div class="top"><p class="src"><a id="v:shift_right" class="def">shift_right</a> :: &#91;<a href="Algorithms-BF-BooleanFormula.html#t:DirectionRegister">DirectionRegister</a>&#93; -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> () <a href="src/Algorithms/BF/BooleanFormula.html#line-792" class="link">Source</a> <a href="#v:shift_right" class="selflink">#</a></p><div class="doc"><p>Shift every qubit in a register to the right by one.</p></div></div><h1 id="g:6">Possible main functions</h1><div class="doc"><p>The following functions define various main functions that can be called
 from an overall main function to display various parts of the
 overall Boolean Formula Algorithm. The Boolean 
 Formula Algorithm is split into 13 sub-algorithms, each of which can be
 displayed separately, or in various combinations.</p></div><div class="top"><p class="src"><a id="v:main_circuit" class="def">main_circuit</a> :: <a href="Quipper-Printing.html#t:Format">Format</a> -&gt; <a href="QuipperLib-Decompose-GateBase.html#t:GateBase">GateBase</a> -&gt; <a href="Algorithms-BF-BooleanFormula.html#t:BooleanFormulaOracle">BooleanFormulaOracle</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/System-IO.html#t:IO">IO</a> () <a href="src/Algorithms/BF/BooleanFormula.html#line-812" class="link">Source</a> <a href="#v:main_circuit" class="selflink">#</a></p><div class="doc"><p>Displays the overall Boolean Formula circuit for a given oracle description.</p></div></div><div class="top"><p class="src"><a id="v:main_u" class="def">main_u</a> :: <a href="Quipper-Printing.html#t:Format">Format</a> -&gt; <a href="QuipperLib-Decompose-GateBase.html#t:GateBase">GateBase</a> -&gt; <a href="Algorithms-BF-BooleanFormula.html#t:BooleanFormulaOracle">BooleanFormulaOracle</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/System-IO.html#t:IO">IO</a> () <a href="src/Algorithms/BF/BooleanFormula.html#line-817" class="link">Source</a> <a href="#v:main_u" class="selflink">#</a></p><div class="doc"><p>Display just 1 time-step of the given oracle,
   i.e., one iteration of the <code><a href="Algorithms-BF-BooleanFormula.html#v:u">u</a></code> from <code><a href="Algorithms-BF-BooleanFormula.html#v:exp_u">exp_u</a></code>, with no controls.</p></div></div><div class="top"><p class="src"><a id="v:main_walk" class="def">main_walk</a> :: <a href="Quipper-Printing.html#t:Format">Format</a> -&gt; <a href="QuipperLib-Decompose-GateBase.html#t:GateBase">GateBase</a> -&gt; <a href="Algorithms-BF-BooleanFormula.html#t:BooleanFormulaOracle">BooleanFormulaOracle</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/System-IO.html#t:IO">IO</a> () <a href="src/Algorithms/BF/BooleanFormula.html#line-822" class="link">Source</a> <a href="#v:main_walk" class="selflink">#</a></p><div class="doc"><p>Display just 1 time-step of the <code><a href="Algorithms-BF-BooleanFormula.html#v:walk">walk</a></code> algorithm for the given oracle,
   i.e., one iteration of <em>walk</em>, with no controls.</p></div></div><div class="top"><p class="src"><a id="v:main_diffuse" class="def">main_diffuse</a> :: <a href="Quipper-Printing.html#t:Format">Format</a> -&gt; <a href="QuipperLib-Decompose-GateBase.html#t:GateBase">GateBase</a> -&gt; <a href="Algorithms-BF-BooleanFormula.html#t:BooleanFormulaOracle">BooleanFormulaOracle</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/System-IO.html#t:IO">IO</a> () <a href="src/Algorithms/BF/BooleanFormula.html#line-827" class="link">Source</a> <a href="#v:main_diffuse" class="selflink">#</a></p><div class="doc"><p>Display just 1 time-step of the <code><a href="Algorithms-BF-BooleanFormula.html#v:diffuse">diffuse</a></code> algorithm for the given oracle,
   i.e., one iteration of <em>diffuse</em>, with no controls.</p></div></div><div class="top"><p class="src"><a id="v:main_oracle" class="def">main_oracle</a> :: <a href="Quipper-Printing.html#t:Format">Format</a> -&gt; <a href="QuipperLib-Decompose-GateBase.html#t:GateBase">GateBase</a> -&gt; <a href="Algorithms-BF-BooleanFormula.html#t:BooleanFormulaOracle">BooleanFormulaOracle</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/System-IO.html#t:IO">IO</a> () <a href="src/Algorithms/BF/BooleanFormula.html#line-832" class="link">Source</a> <a href="#v:main_oracle" class="selflink">#</a></p><div class="doc"><p>Display just 1 time-step of the <code><a href="Algorithms-BF-BooleanFormula.html#v:oracle">oracle</a></code> algorithm for the given oracle,
   i.e., one iteration of <em>oracle</em>, with no controls.</p></div></div><div class="top"><p class="src"><a id="v:main_undo_oracle" class="def">main_undo_oracle</a> :: <a href="Quipper-Printing.html#t:Format">Format</a> -&gt; <a href="QuipperLib-Decompose-GateBase.html#t:GateBase">GateBase</a> -&gt; <a href="Algorithms-BF-BooleanFormula.html#t:BooleanFormulaOracle">BooleanFormulaOracle</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/System-IO.html#t:IO">IO</a> () <a href="src/Algorithms/BF/BooleanFormula.html#line-837" class="link">Source</a> <a href="#v:main_undo_oracle" class="selflink">#</a></p><div class="doc"><p>Display just 1 time-step of the <code><a href="Algorithms-BF-BooleanFormula.html#v:undo_oracle">undo_oracle</a></code> algorithm for the given oracle,
   i.e., one iteration of <em>undo_oracle</em>, with no controls.</p></div></div><div class="top"><p class="src"><a id="v:main_hex" class="def">main_hex</a> :: <a href="Quipper-Printing.html#t:Format">Format</a> -&gt; <a href="QuipperLib-Decompose-GateBase.html#t:GateBase">GateBase</a> -&gt; <a href="Algorithms-BF-BooleanFormula.html#t:BooleanFormulaOracle">BooleanFormulaOracle</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/System-IO.html#t:IO">IO</a> () <a href="src/Algorithms/BF/BooleanFormula.html#line-842" class="link">Source</a> <a href="#v:main_hex" class="selflink">#</a></p><div class="doc"><p>Display the circuit for the Hex algorithm, for the given oracle,
 i.e., one iteration of <code><a href="Algorithms-BF-Hex.html#v:hex_oracle">hex_oracle</a></code>, with no controls.</p></div></div><div class="top"><p class="src"><a id="v:main_checkwin_red" class="def">main_checkwin_red</a> :: <a href="Quipper-Printing.html#t:Format">Format</a> -&gt; <a href="QuipperLib-Decompose-GateBase.html#t:GateBase">GateBase</a> -&gt; <a href="Algorithms-BF-BooleanFormula.html#t:BooleanFormulaOracle">BooleanFormulaOracle</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/System-IO.html#t:IO">IO</a> () <a href="src/Algorithms/BF/BooleanFormula.html#line-854" class="link">Source</a> <a href="#v:main_checkwin_red" class="selflink">#</a></p><div class="doc"><p>Display the circuit for the Checkwin_red algorithm, for the given oracle,
 i.e., one iteration of <code><a href="Algorithms-BF-Hex.html#v:checkwin_red_circuit">checkwin_red_circuit</a></code>, with no controls.</p></div></div><h1 id="g:7">Running the Boolean Formula Algorithm</h1><div class="doc"><p>The following functions define the way that the Boolean Formula Algorithm
 would be run, if we had access to a quantum computer. Indeed, the functions
 here interface with the <a href="QuantumSimulation.html">QuantumSimulation</a> quantum simulator so that they
 can be built.</p></div><div class="top"><p class="src"><a id="v:main_bf" class="def">main_bf</a> :: <a href="Algorithms-BF-BooleanFormula.html#t:BooleanFormulaOracle">BooleanFormulaOracle</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/System-IO.html#t:IO">IO</a> <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Bool.html#t:Bool">Bool</a> <a href="src/Algorithms/BF/BooleanFormula.html#line-871" class="link">Source</a> <a href="#v:main_bf" class="selflink">#</a></p><div class="doc"><p>Approximation of how the algorithm would be run if we had a quantum computer:
   uses QuantumSimulation run_generic_io function. The output of the algorithm will
 be all False only in the instance that the Blue player wins the game.</p></div></div><div class="top"><p class="src"><a id="v:whoWins" class="def">whoWins</a> :: <a href="Algorithms-BF-BooleanFormula.html#t:BooleanFormulaOracle">BooleanFormulaOracle</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/System-IO.html#t:IO">IO</a> () <a href="src/Algorithms/BF/BooleanFormula.html#line-880" class="link">Source</a> <a href="#v:whoWins" class="selflink">#</a></p><div class="doc"><p>Display the result of <code><a href="Algorithms-BF-BooleanFormula.html#v:main_bf">main_bf</a></code>,
   i.e., either &quot;Red Wins&quot;, or &quot;Blue Wins&quot; is the output.</p></div></div><div class="top"><p class="src"><a id="v:main_whoWins" class="def">main_whoWins</a> :: <a href="Algorithms-BF-BooleanFormula.html#t:BooleanFormulaOracle">BooleanFormulaOracle</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/System-IO.html#t:IO">IO</a> () <a href="src/Algorithms/BF/BooleanFormula.html#line-887" class="link">Source</a> <a href="#v:main_whoWins" class="selflink">#</a></p><div class="doc"><p>Run <code><a href="Algorithms-BF-BooleanFormula.html#v:whoWins">whoWins</a></code> for the given oracle, and its &quot;initial&quot; board.</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.17.3</p></div></body></html>
