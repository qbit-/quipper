<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Algorithms.BF.QuantumIf</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Algorithms-BF-QuantumIf.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/Algorithms/BF/QuantumIf.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">The Quipper System</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>None</td></tr></table><p class="caption">Algorithms.BF.QuantumIf</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Quantum &quot;if then else&quot; statements</a></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>This module introduces a simple way of defining &quot;boolean statements&quot;
 acting over qubits. See <a href="Algorithms-BF-Main.html">Algorithms.BF.Main</a> for an overview of the boolean 
 formula algorithm.</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><span class="keyword">data</span> <a href="#t:Boolean">Boolean</a> a<ul class="subs"><li>= <a href="#v:A">A</a> a</li><li>| <a href="#v:Not">Not</a> (<a href="Algorithms-BF-QuantumIf.html#t:Boolean">Boolean</a> a)</li><li>| <a href="#v:And">And</a> (<a href="Algorithms-BF-QuantumIf.html#t:Boolean">Boolean</a> a) (<a href="Algorithms-BF-QuantumIf.html#t:Boolean">Boolean</a> a)</li><li>| <a href="#v:Or">Or</a> (<a href="Algorithms-BF-QuantumIf.html#t:Boolean">Boolean</a> a) (<a href="Algorithms-BF-QuantumIf.html#t:Boolean">Boolean</a> a)</li></ul></li><li class="src short"><span class="keyword">data</span> <a href="#t:BooleanAnd">BooleanAnd</a> a<ul class="subs"><li>= <a href="#v:AA">AA</a> a</li><li>| <a href="#v:NotA">NotA</a> (<a href="Algorithms-BF-QuantumIf.html#t:BooleanAnd">BooleanAnd</a> a)</li><li>| <a href="#v:AndA">AndA</a> (<a href="Algorithms-BF-QuantumIf.html#t:BooleanAnd">BooleanAnd</a> a) (<a href="Algorithms-BF-QuantumIf.html#t:BooleanAnd">BooleanAnd</a> a)</li></ul></li><li class="src short"><a href="#v:booleanToAnd-39-">booleanToAnd'</a> :: <a href="Algorithms-BF-QuantumIf.html#t:Boolean">Boolean</a> a -&gt; <a href="Algorithms-BF-QuantumIf.html#t:BooleanAnd">BooleanAnd</a> a</li><li class="src short"><a href="#v:stripDoubleNot">stripDoubleNot</a> :: <a href="Algorithms-BF-QuantumIf.html#t:BooleanAnd">BooleanAnd</a> a -&gt; <a href="Algorithms-BF-QuantumIf.html#t:BooleanAnd">BooleanAnd</a> a</li><li class="src short"><a href="#v:booleanToAnd">booleanToAnd</a> :: <a href="Algorithms-BF-QuantumIf.html#t:Boolean">Boolean</a> a -&gt; <a href="Algorithms-BF-QuantumIf.html#t:BooleanAnd">BooleanAnd</a> a</li><li class="src short"><a href="#v:booleanAnd-39-">booleanAnd'</a> :: <a href="Algorithms-BF-QuantumIf.html#t:BooleanAnd">BooleanAnd</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper-Monad.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> ()</li><li class="src short"><a href="#v:booleanAnd">booleanAnd</a> :: <a href="Algorithms-BF-QuantumIf.html#t:BooleanAnd">BooleanAnd</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a></li><li class="src short"><a href="#v:if_then_elseQinv">if_then_elseQinv</a> :: <a href="Algorithms-BF-QuantumIf.html#t:Boolean">Boolean</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> () -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> () -&gt; <a href="Algorithms-BF-QuantumIf.html#t:Boolean">Boolean</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> ()</li><li class="src short"><a href="#v:if_then_elseQ">if_then_elseQ</a> :: <a href="Algorithms-BF-QuantumIf.html#t:Boolean">Boolean</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> () -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> () -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> ()</li></ul></div><div id="interface"><h1 id="g:1">Quantum &quot;if then else&quot; statements</h1><div class="doc"><p>This section introduces a simple way of defining &quot;boolean statements&quot;
 acting over qubits, that can then be used as the control in a quantum &quot;If
 Then Else&quot; statement. The idea is that an ancilla is initialized that is in 
 the state represented by the boolean statement, and is then used to control the
 two branches of the &quot;If Then Else&quot;, before being uncomputed. The boolean 
 statements can contain &quot;and&quot;, &quot;or&quot;, and &quot;not&quot;.</p></div><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:Boolean" class="def">Boolean</a> a <a href="src/Algorithms/BF/QuantumIf.html#line-25" class="link">Source</a> <a href="#t:Boolean" class="selflink">#</a></p><div class="doc"><p>We can use <code>(Boolean Qubit)</code> to build up &quot;boolean statements&quot; over qubits
 and use the &quot;boolean statement&quot; in an <code><a href="Algorithms-BF-QuantumIf.html#v:if_then_elseQ">if_then_elseQ</a></code> construct.</p><pre>Example (for qubits a, b, c, d):
(a and b) or !(c and !d) is written as:
Or (And (A a) (A b)) (Not (And (A c) (Not (A d)))) </pre></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a id="v:A" class="def">A</a> a</td><td class="doc"><p><code><a href="Algorithms-BF-QuantumIf.html#v:A">A</a></code> <em>q</em> means if <em>q</em> == <code><a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Bool.html#v:True">True</a></code>. </p></td></tr><tr><td class="src"><a id="v:Not" class="def">Not</a> (<a href="Algorithms-BF-QuantumIf.html#t:Boolean">Boolean</a> a)</td><td class="doc"><p><code><a href="Algorithms-BF-QuantumIf.html#v:Not">Not</a></code> <em>b</em> means the negation of the boolean statement <em>b</em>.</p></td></tr><tr><td class="src"><a id="v:And" class="def">And</a> (<a href="Algorithms-BF-QuantumIf.html#t:Boolean">Boolean</a> a) (<a href="Algorithms-BF-QuantumIf.html#t:Boolean">Boolean</a> a) <span class="fixity">infixr 3</span><span class="rightedge"></span></td><td class="doc"><p><code><a href="Algorithms-BF-QuantumIf.html#v:And">And</a></code> <em>a</em> <em>b</em> means the and of the boolean statements <em>a</em> and <em>b</em>.</p></td></tr><tr><td class="src"><a id="v:Or" class="def">Or</a> (<a href="Algorithms-BF-QuantumIf.html#t:Boolean">Boolean</a> a) (<a href="Algorithms-BF-QuantumIf.html#t:Boolean">Boolean</a> a) <span class="fixity">infixr 2</span><span class="rightedge"></span></td><td class="doc"><p><code><a href="Algorithms-BF-QuantumIf.html#v:Or">Or</a></code> <em>a</em> <em>b</em> means the or of the boolean statements <em>a</em> and <em>b</em></p></td></tr></table></div><div class="subs instances"><p id="control.i:Boolean" class="caption collapser" onclick="toggleSection('i:Boolean')">Instances</p><div id="section.i:Boolean" class="show"><table><tr><td class="src clearfix"><span class="inst-left"><span id="control.i:id:Boolean:Show:1" class="instance expander" onclick="toggleSection('i:id:Boolean:Show:1')"></span> <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Text-Show.html#t:Show">Show</a> a =&gt; <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Text-Show.html#t:Show">Show</a> (<a href="Algorithms-BF-QuantumIf.html#t:Boolean">Boolean</a> a)</span> <a href="#t:Boolean" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div id="section.i:id:Boolean:Show:1" class="inst-details hide"><div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:showsPrec">showsPrec</a> :: <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Int.html#t:Int">Int</a> -&gt; <a href="Algorithms-BF-QuantumIf.html#t:Boolean">Boolean</a> a -&gt; <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Text-Show.html#t:ShowS">ShowS</a> <a href="#v:showsPrec" class="selflink">#</a></p><p class="src"><a href="#v:show">show</a> :: <a href="Algorithms-BF-QuantumIf.html#t:Boolean">Boolean</a> a -&gt; <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-String.html#t:String">String</a> <a href="#v:show" class="selflink">#</a></p><p class="src"><a href="#v:showList">showList</a> :: &#91;<a href="Algorithms-BF-QuantumIf.html#t:Boolean">Boolean</a> a&#93; -&gt; <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Text-Show.html#t:ShowS">ShowS</a> <a href="#v:showList" class="selflink">#</a></p></div></div></td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:BooleanAnd" class="def">BooleanAnd</a> a <a href="src/Algorithms/BF/QuantumIf.html#line-40" class="link">Source</a> <a href="#t:BooleanAnd" class="selflink">#</a></p><div class="doc"><p>Allow <code><a href="Algorithms-BF-QuantumIf.html#v:And">And</a></code> and <code><a href="Algorithms-BF-QuantumIf.html#v:Or">Or</a></code> to be used as infix operators, with the same
 precedences.</p><p>Internally, a &quot;boolean statement&quot; is converted into a statement
   that doesn't use <em>or</em> (e.g., using De Morgan's laws).</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a id="v:AA" class="def">AA</a> a</td><td class="doc"><p><code><a href="Algorithms-BF-QuantumIf.html#v:AA">AA</a></code> <em>q</em> means if <em>q</em> == <code><a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Bool.html#v:True">True</a></code>.</p></td></tr><tr><td class="src"><a id="v:NotA" class="def">NotA</a> (<a href="Algorithms-BF-QuantumIf.html#t:BooleanAnd">BooleanAnd</a> a)</td><td class="doc"><p><code><a href="Algorithms-BF-QuantumIf.html#v:NotA">NotA</a></code> <em>b</em> means the negation of the boolean statement <em>b</em>.</p></td></tr><tr><td class="src"><a id="v:AndA" class="def">AndA</a> (<a href="Algorithms-BF-QuantumIf.html#t:BooleanAnd">BooleanAnd</a> a) (<a href="Algorithms-BF-QuantumIf.html#t:BooleanAnd">BooleanAnd</a> a)</td><td class="doc"><p><code><a href="Algorithms-BF-QuantumIf.html#v:AndA">AndA</a></code> <em>a</em> <em>b</em> means the and of the boolean statements <em>a</em> and <em>b</em>.</p></td></tr></table></div></div><div class="top"><p class="src"><a id="v:booleanToAnd-39-" class="def">booleanToAnd'</a> :: <a href="Algorithms-BF-QuantumIf.html#t:Boolean">Boolean</a> a -&gt; <a href="Algorithms-BF-QuantumIf.html#t:BooleanAnd">BooleanAnd</a> a <a href="src/Algorithms/BF/QuantumIf.html#line-51" class="link">Source</a> <a href="#v:booleanToAnd-39-" class="selflink">#</a></p><div class="doc"><p>Convert any boolean formula to a formula using just <em>and</em> and <em>not</em>. This conversion function uses De Morgan's law,
   i.e., </p><pre>A or B = !( !A and !B ),</pre><p>but does not remove double negations. For a version that also
 removes double negations, see <code><a href="Algorithms-BF-QuantumIf.html#v:booleanToAnd">booleanToAnd</a></code>.</p></div></div><div class="top"><p class="src"><a id="v:stripDoubleNot" class="def">stripDoubleNot</a> :: <a href="Algorithms-BF-QuantumIf.html#t:BooleanAnd">BooleanAnd</a> a -&gt; <a href="Algorithms-BF-QuantumIf.html#t:BooleanAnd">BooleanAnd</a> a <a href="src/Algorithms/BF/QuantumIf.html#line-59" class="link">Source</a> <a href="#v:stripDoubleNot" class="selflink">#</a></p><div class="doc"><p>Strip any redundant double negations,
   i.e., in this context <code>!!A = A</code>.</p></div></div><div class="top"><p class="src"><a id="v:booleanToAnd" class="def">booleanToAnd</a> :: <a href="Algorithms-BF-QuantumIf.html#t:Boolean">Boolean</a> a -&gt; <a href="Algorithms-BF-QuantumIf.html#t:BooleanAnd">BooleanAnd</a> a <a href="src/Algorithms/BF/QuantumIf.html#line-67" class="link">Source</a> <a href="#v:booleanToAnd" class="selflink">#</a></p><div class="doc"><p>Convert any boolean formula to a formula using just <em>and</em> and
 <em>not</em>, removing double negations.</p></div></div><div class="top"><p class="src"><a id="v:booleanAnd-39-" class="def">booleanAnd'</a> :: <a href="Algorithms-BF-QuantumIf.html#t:BooleanAnd">BooleanAnd</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper-Monad.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> () <a href="src/Algorithms/BF/QuantumIf.html#line-71" class="link">Source</a> <a href="#v:booleanAnd-39-" class="selflink">#</a></p><div class="doc"><p>Create a circuit from the &quot;boolean statement&quot;.</p></div></div><div class="top"><p class="src"><a id="v:booleanAnd" class="def">booleanAnd</a> :: <a href="Algorithms-BF-QuantumIf.html#t:BooleanAnd">BooleanAnd</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a> <a href="src/Algorithms/BF/QuantumIf.html#line-88" class="link">Source</a> <a href="#v:booleanAnd" class="selflink">#</a></p><div class="doc"><p>Create a circuit from the &quot;boolean statement&quot;, passing in an ancilla.</p></div></div><div class="top"><p class="src"><a id="v:if_then_elseQinv" class="def">if_then_elseQinv</a> :: <a href="Algorithms-BF-QuantumIf.html#t:Boolean">Boolean</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> () -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> () -&gt; <a href="Algorithms-BF-QuantumIf.html#t:Boolean">Boolean</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> () <a href="src/Algorithms/BF/QuantumIf.html#line-106" class="link">Source</a> <a href="#v:if_then_elseQinv" class="selflink">#</a></p><div class="doc"><p>The definition of a quantum if_then_else structure
 uses a &quot;boolean statement&quot; to create a single ancilla in the state defined by
 the boolean statement, and uses this as a control for the two branches of the
 if statement. The ancilla then needs to be uncomputed, this is achieved using
 the other given &quot;boolean statement&quot;, i.e., a new boolean statement that would
 produce the state of the control ancilla, from the output state of the two
 branches.This allows the branches to update the state of qubits used in the 
 original &quot;boolean statement&quot; as long as it is done in a 
 (reversible) known-manner.
 This is useful for the WALK algorithm, where TOPARENT and TOCHILD are controlled
 by the state of the direction register, but also change the state of the
 direction register.   </p></div></div><div class="top"><p class="src"><a id="v:if_then_elseQ" class="def">if_then_elseQ</a> :: <a href="Algorithms-BF-QuantumIf.html#t:Boolean">Boolean</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> () -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> () -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> () <a href="src/Algorithms/BF/QuantumIf.html#line-120" class="link">Source</a> <a href="#v:if_then_elseQ" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Algorithms-BF-QuantumIf.html#v:if_then_elseQinv">if_then_elseQinv</a></code>, but where the original &quot;boolean statement&quot; still
 holds after the branches have taken place.</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.17.3</p></div></body></html>
