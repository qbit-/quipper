<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>QuipperLib.ClassicalOptim.QuipperInterface</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_QuipperLib-ClassicalOptim-QuipperInterface.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/QuipperLib/ClassicalOptim/QuipperInterface.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">The Quipper System</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>None</td></tr></table><p class="caption">QuipperLib.ClassicalOptim.QuipperInterface</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Auxiliary functions</a></li><li><a href="#g:2">Quipper circuits to simple circuits</a></li><li><a href="#g:3">Simple circuits to Quipper circuits</a></li><li><a href="#g:4">Algebraic optimization of Quipper circuits</a></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>This module contains the interface between the simplified circuit
 model and Quipper's internal circuit model. The main useful
 exported functions are: </p><ul><li><code><code><a href="QuipperLib-ClassicalOptim-QuipperInterface.html#v:simplify_classical">simplify_classical</a></code></code>, which optimizes a classical circuit such
 as those coming from Template Haskell;</li><li><code><code><a href="QuipperLib-ClassicalOptim-QuipperInterface.html#v:classical_to_reversible_optim">classical_to_reversible_optim</a></code></code>, which provides a mechanism
 equivalent to <code><code><a href="Quipper-Classical.html#v:classical_to_reversible">classical_to_reversible</a></code></code>, but with optimization
 inlined.</li></ul></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><a href="#v:getListWire">getListWire</a> :: <a href="Quipper-QData.html#t:QData">QData</a> qc =&gt; qc -&gt; &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>&#93;</li><li class="src short"><a href="#v:quipperGateToMyGate">quipperGateToMyGate</a> :: (<a href="http://hackage.haskell.org/package/containers-0.5.7.1/docs/Data-IntSet.html#t:IntSet">IntSet</a>, <a href="http://hackage.haskell.org/package/containers-0.5.7.1/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> <a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>, <a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>) -&gt; <a href="Quipper-Circuit.html#t:Gate">Gate</a> -&gt; ((<a href="http://hackage.haskell.org/package/containers-0.5.7.1/docs/Data-IntSet.html#t:IntSet">IntSet</a>, <a href="http://hackage.haskell.org/package/containers-0.5.7.1/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> <a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>, <a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>), <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Maybe.html#t:Maybe">Maybe</a> <a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>)</li><li class="src short"><a href="#v:quipperGateInitW">quipperGateInitW</a> :: <a href="Quipper-Circuit.html#t:Gate">Gate</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Maybe.html#t:Maybe">Maybe</a> <a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a></li><li class="src short"><a href="#v:quipperGateFreshWire">quipperGateFreshWire</a> :: <a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a> -&gt; &#91;<a href="Quipper-Circuit.html#t:Gate">Gate</a>&#93; -&gt; <a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a></li><li class="src short"><a href="#v:quipperCircuitToMyCirc">quipperCircuitToMyCirc</a> :: <a href="Quipper-Circuit.html#t:Circuit">Circuit</a> -&gt; <a href="QuipperLib-ClassicalOptim-Circuit.html#t:CircState">CircState</a></li><li class="src short"><a href="#v:quipperBCircuitToMyCirc">quipperBCircuitToMyCirc</a> :: <a href="Quipper-Circuit.html#t:BCircuit">BCircuit</a> -&gt; <a href="QuipperLib-ClassicalOptim-Circuit.html#t:CircState">CircState</a></li><li class="src short"><a href="#v:myCircErrMsg">myCircErrMsg</a> :: <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-String.html#t:String">String</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-String.html#t:String">String</a></li><li class="src short"><a href="#v:quipperFunToMyCirc">quipperFunToMyCirc</a> :: (<a href="Quipper-QData.html#t:QData">QData</a> x, <a href="Quipper-QData.html#t:QData">QData</a> y) =&gt; (x -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> y) -&gt; x -&gt; (<a href="QuipperLib-ClassicalOptim-Circuit.html#t:CircState">CircState</a>, &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>&#93;)</li><li class="src short"><a href="#v:myGateToQuipperGate">myGateToQuipperGate</a> :: <a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a> -&gt; <a href="Quipper-Circuit.html#t:Gate">Gate</a></li><li class="src short"><a href="#v:makeComment">makeComment</a> :: <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-String.html#t:String">String</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-String.html#t:String">String</a> -&gt; &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>&#93; -&gt; <a href="Quipper-Circuit.html#t:Gate">Gate</a></li><li class="src short"><a href="#v:quipperBCircuitSimpl">quipperBCircuitSimpl</a> :: <a href="Quipper-Circuit.html#t:BCircuit">BCircuit</a> -&gt; &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>&#93; -&gt; (<a href="Quipper-Circuit.html#t:BCircuit">BCircuit</a>, &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>&#93;)</li><li class="src short"><a href="#v:simplify_classical-39-">simplify_classical'</a> :: (<a href="Quipper-QData.html#t:QData">QData</a> x, <a href="Quipper-QData.html#t:QData">QData</a> y) =&gt; (x -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> y) -&gt; x -&gt; (<a href="Quipper-Circuit.html#t:BCircuit">BCircuit</a>, &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>&#93;)</li><li class="src short"><a href="#v:simplify_classical">simplify_classical</a> :: (<a href="Quipper-QData.html#t:QData">QData</a> x, <a href="Quipper-QData.html#t:QData">QData</a> y) =&gt; (x -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> y) -&gt; x -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> y</li><li class="src short"><a href="#v:classical_to_reversible_optim">classical_to_reversible_optim</a> :: (<a href="Quipper-QData.html#t:QData">QData</a> qa, <a href="Quipper-QData.html#t:QData">QData</a> qb) =&gt; (qa -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> qb) -&gt; (qa, qb) -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> (qa, qb)</li><li class="src short"><a href="#v:box_classical_to_reversible_optim">box_classical_to_reversible_optim</a> :: (<a href="Quipper-QData.html#t:QData">QData</a> qa, <a href="Quipper-QData.html#t:QData">QData</a> qb) =&gt; <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-String.html#t:String">String</a> -&gt; (qa -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> qb) -&gt; (qa, qb) -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> (qa, qb)</li></ul></div><div id="interface"><h1 id="g:1">Auxiliary functions</h1><div class="top"><p class="src"><a id="v:getListWire" class="def">getListWire</a> :: <a href="Quipper-QData.html#t:QData">QData</a> qc =&gt; qc -&gt; &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>&#93; <a href="src/QuipperLib/ClassicalOptim/QuipperInterface.html#line-46" class="link">Source</a> <a href="#v:getListWire" class="selflink">#</a></p><div class="doc"><p>Extract the list of wires from a piece of quantum data.</p></div></div><h1 id="g:2">Quipper circuits to simple circuits</h1><div class="top"><p class="src"><a id="v:quipperGateToMyGate" class="def">quipperGateToMyGate</a> :: (<a href="http://hackage.haskell.org/package/containers-0.5.7.1/docs/Data-IntSet.html#t:IntSet">IntSet</a>, <a href="http://hackage.haskell.org/package/containers-0.5.7.1/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> <a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>, <a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>) -&gt; <a href="Quipper-Circuit.html#t:Gate">Gate</a> -&gt; ((<a href="http://hackage.haskell.org/package/containers-0.5.7.1/docs/Data-IntSet.html#t:IntSet">IntSet</a>, <a href="http://hackage.haskell.org/package/containers-0.5.7.1/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> <a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>, <a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>), <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Maybe.html#t:Maybe">Maybe</a> <a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>) <a href="src/QuipperLib/ClassicalOptim/QuipperInterface.html#line-62" class="link">Source</a> <a href="#v:quipperGateToMyGate" class="selflink">#</a></p><div class="doc"><p>Translates a Quipper circuit to a simple circuit. The only gates
 considered are initializations, terminations, and multi-controlled
 NOT gates. All other gates are ignored.</p><p>Note that simple circuits do not possess termination wires: these
 wires are simply not terminated, and all subsequent initializations
 using the same wire ID are sent to fresh wires.</p><p>The state of this function is a bit complex, as it keeps track of
 where the output wires are mapped to.</p></div></div><div class="top"><p class="src"><a id="v:quipperGateInitW" class="def">quipperGateInitW</a> :: <a href="Quipper-Circuit.html#t:Gate">Gate</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Maybe.html#t:Maybe">Maybe</a> <a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a> <a href="src/QuipperLib/ClassicalOptim/QuipperInterface.html#line-73" class="link">Source</a> <a href="#v:quipperGateInitW" class="selflink">#</a></p><div class="doc"><p>Get the wire initialized by the gate, if it is an initialization gate.</p></div></div><div class="top"><p class="src"><a id="v:quipperGateFreshWire" class="def">quipperGateFreshWire</a> :: <a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a> -&gt; &#91;<a href="Quipper-Circuit.html#t:Gate">Gate</a>&#93; -&gt; <a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a> <a href="src/QuipperLib/ClassicalOptim/QuipperInterface.html#line-78" class="link">Source</a> <a href="#v:quipperGateFreshWire" class="selflink">#</a></p><div class="doc"><p>Given a list of Quipper gates, get the smallest wire id not in use.</p></div></div><div class="top"><p class="src"><a id="v:quipperCircuitToMyCirc" class="def">quipperCircuitToMyCirc</a> :: <a href="Quipper-Circuit.html#t:Circuit">Circuit</a> -&gt; <a href="QuipperLib-ClassicalOptim-Circuit.html#t:CircState">CircState</a> <a href="src/QuipperLib/ClassicalOptim/QuipperInterface.html#line-82" class="link">Source</a> <a href="#v:quipperCircuitToMyCirc" class="selflink">#</a></p><div class="doc"><p>Send a Quipper <code><a href="Quipper-Circuit.html#t:Circuit">Circuit</a></code> to a <code><a href="QuipperLib-ClassicalOptim-Circuit.html#t:CircState">CircState</a></code>.</p></div></div><div class="top"><p class="src"><a id="v:quipperBCircuitToMyCirc" class="def">quipperBCircuitToMyCirc</a> :: <a href="Quipper-Circuit.html#t:BCircuit">BCircuit</a> -&gt; <a href="QuipperLib-ClassicalOptim-Circuit.html#t:CircState">CircState</a> <a href="src/QuipperLib/ClassicalOptim/QuipperInterface.html#line-90" class="link">Source</a> <a href="#v:quipperBCircuitToMyCirc" class="selflink">#</a></p><div class="doc"><p>Send a Quipper <code><a href="Quipper-Circuit.html#t:BCircuit">BCircuit</a></code> to a <code><a href="QuipperLib-ClassicalOptim-Circuit.html#t:CircState">CircState</a></code>.</p></div></div><div class="top"><p class="src"><a id="v:myCircErrMsg" class="def">myCircErrMsg</a> :: <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-String.html#t:String">String</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-String.html#t:String">String</a> <a href="src/QuipperLib/ClassicalOptim/QuipperInterface.html#line-94" class="link">Source</a> <a href="#v:myCircErrMsg" class="selflink">#</a></p><div class="doc"><p>Generate a custom error message.</p></div></div><div class="top"><p class="src"><a id="v:quipperFunToMyCirc" class="def">quipperFunToMyCirc</a> :: (<a href="Quipper-QData.html#t:QData">QData</a> x, <a href="Quipper-QData.html#t:QData">QData</a> y) =&gt; (x -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> y) -&gt; x -&gt; (<a href="QuipperLib-ClassicalOptim-Circuit.html#t:CircState">CircState</a>, &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>&#93;) <a href="src/QuipperLib/ClassicalOptim/QuipperInterface.html#line-100" class="link">Source</a> <a href="#v:quipperFunToMyCirc" class="selflink">#</a></p><div class="doc"><p>Given a Quipper circuit generating function and a shape argument,
 return a simple circuit together with the list of non-garbage
 circuit outputs.</p></div></div><h1 id="g:3">Simple circuits to Quipper circuits</h1><div class="top"><p class="src"><a id="v:myGateToQuipperGate" class="def">myGateToQuipperGate</a> :: <a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a> -&gt; <a href="Quipper-Circuit.html#t:Gate">Gate</a> <a href="src/QuipperLib/ClassicalOptim/QuipperInterface.html#line-110" class="link">Source</a> <a href="#v:myGateToQuipperGate" class="selflink">#</a></p><div class="doc"><p>Translate a gate from the simple circuit model into a Quipper gate.</p></div></div><div class="top"><p class="src"><a id="v:makeComment" class="def">makeComment</a> :: <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-String.html#t:String">String</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-String.html#t:String">String</a> -&gt; &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>&#93; -&gt; <a href="Quipper-Circuit.html#t:Gate">Gate</a> <a href="src/QuipperLib/ClassicalOptim/QuipperInterface.html#line-118" class="link">Source</a> <a href="#v:makeComment" class="selflink">#</a></p><div class="doc"><p>Generate a Quipper comment. The first argument is a comment
 string, and the second argument is a label to apply to the qubits
 in the third argument.</p></div></div><h1 id="g:4">Algebraic optimization of Quipper circuits</h1><div class="top"><p class="src"><a id="v:quipperBCircuitSimpl" class="def">quipperBCircuitSimpl</a> :: <a href="Quipper-Circuit.html#t:BCircuit">BCircuit</a> -&gt; &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>&#93; -&gt; (<a href="Quipper-Circuit.html#t:BCircuit">BCircuit</a>, &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>&#93;) <a href="src/QuipperLib/ClassicalOptim/QuipperInterface.html#line-129" class="link">Source</a> <a href="#v:quipperBCircuitSimpl" class="selflink">#</a></p><div class="doc"><p>Optimize a Quipper <code><a href="Quipper-Circuit.html#t:BCircuit">BCircuit</a></code>. The second argument is the list
 of non-garbage outputs. A corresponding list of outputs is also
 returned along with the circuit.</p></div></div><div class="top"><p class="src"><a id="v:simplify_classical-39-" class="def">simplify_classical'</a> :: (<a href="Quipper-QData.html#t:QData">QData</a> x, <a href="Quipper-QData.html#t:QData">QData</a> y) =&gt; (x -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> y) -&gt; x -&gt; (<a href="Quipper-Circuit.html#t:BCircuit">BCircuit</a>, &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>&#93;) <a href="src/QuipperLib/ClassicalOptim/QuipperInterface.html#line-147" class="link">Source</a> <a href="#v:simplify_classical-39-" class="selflink">#</a></p><div class="doc"><p>Optimize a Quipper circuit producing function (together with a
 shape argument). Return the optimized circuit as a Quipper
 <code>BCircuit</code>, along with a list of the non-garbage circuit outputs.</p></div></div><div class="top"><p class="src"><a id="v:simplify_classical" class="def">simplify_classical</a> :: (<a href="Quipper-QData.html#t:QData">QData</a> x, <a href="Quipper-QData.html#t:QData">QData</a> y) =&gt; (x -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> y) -&gt; x -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> y <a href="src/QuipperLib/ClassicalOptim/QuipperInterface.html#line-158" class="link">Source</a> <a href="#v:simplify_classical" class="selflink">#</a></p><div class="doc"><p>Optimize a Quipper circuit-producing function. This assumes that
 the function only consists of pseudo-classical quantum gates, i.e.,
 initializations, terminations, and (possibly multiply controlled)
 NOT gates. The behavior on other kinds of circuits is undefined.
 The second argument is a shape parameter.</p></div></div><div class="top"><p class="src"><a id="v:classical_to_reversible_optim" class="def">classical_to_reversible_optim</a> :: (<a href="Quipper-QData.html#t:QData">QData</a> qa, <a href="Quipper-QData.html#t:QData">QData</a> qb) =&gt; (qa -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> qb) -&gt; (qa, qb) -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> (qa, qb) <a href="src/QuipperLib/ClassicalOptim/QuipperInterface.html#line-166" class="link">Source</a> <a href="#v:classical_to_reversible_optim" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Quipper-Classical.html#v:classical_to_reversible">classical_to_reversible</a></code>, but also apply circuit optimization.</p></div></div><div class="top"><p class="src"><a id="v:box_classical_to_reversible_optim" class="def">box_classical_to_reversible_optim</a> :: (<a href="Quipper-QData.html#t:QData">QData</a> qa, <a href="Quipper-QData.html#t:QData">QData</a> qb) =&gt; <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-String.html#t:String">String</a> -&gt; (qa -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> qb) -&gt; (qa, qb) -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> (qa, qb) <a href="src/QuipperLib/ClassicalOptim/QuipperInterface.html#line-171" class="link">Source</a> <a href="#v:box_classical_to_reversible_optim" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="QuipperLib-ClassicalOptim-QuipperInterface.html#v:classical_to_reversible_optim">classical_to_reversible_optim</a></code>, but insert the optimized
 circuit as a boxed subroutine.</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.17.3</p></div></body></html>
